
/Users/bytedance/Documents/os/30dayos/code/build/source/kernel/kernel.elf:     file format elf32-i386
/Users/bytedance/Documents/os/30dayos/code/build/source/kernel/kernel.elf
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00008000

Program Header:
    LOAD off    0x00000000 vaddr 0x00007000 paddr 0x00007000 align 2**12
         filesz 0x00006ae8 memsz 0x00006ae8 flags r-x
    LOAD off    0x00006b00 vaddr 0x0000eb00 paddr 0x0000eb00 align 2**12
         filesz 0x00000159 memsz 0x00003340 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005956  00008000  00008000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00000190  0000d958  0000d958  00006958  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         00000159  0000eb00  0000eb00  00006b00  2**5
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          000031e0  0000ec60  0000ec60  00006c59  2**5
                  ALLOC
  4 .comment      00000012  00000000  00000000  00006c59  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000260  00000000  00000000  00006c70  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_info   00006085  00000000  00000000  00006ed0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_abbrev 00001e83  00000000  00000000  0000cf55  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_line   00002c9e  00000000  00000000  0000edd8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_frame  00001690  00000000  00000000  00011a78  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_str    00000b71  00000000  00000000  00013108  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_line_str 0000071a  00000000  00000000  00013c79  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_rnglists 00000072  00000000  00000000  00014393  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 start.S.o
00008000 l       .text	00000000 main
00000000 l    df *ABS*	00000000 anim.c
0000ec60 l     O .bss	00000004 frame
0000ec64 l     O .bss	00000004 imgs
0000ec68 l     O .bss	00000001 index
00000000 l    df *ABS*	00000000 console.c
000082ee l     F .text	00000007 cli
000082f5 l     F .text	00000007 sti
000082fc l     F .text	00000007 hlt
00008303 l     F .text	00000022 clump
0000eb00 l     O .data	00000008 code2char
0000ec6c l     O .bss	00000004 cursor_x
0000ec70 l     O .bss	00000004 cursor_y
0000ec74 l     O .bss	00000004 cursor_show
0000ec78 l     O .bss	00000004 shift_press
0000ec7c l     O .bss	00000004 frame
0000ec80 l     O .bss	00000004 task
00000000 l    df *ABS*	00000000 image.c
0000ec84 l     O .bss	00000004 frame
00000000 l    df *ABS*	00000000 line.c
0000ec88 l     O .bss	00000004 frame
00000000 l    df *ABS*	00000000 nano.c
000094e2 l     F .text	00000007 cli
000094e9 l     F .text	00000007 sti
000094f0 l     F .text	00000007 hlt
000094f7 l     F .text	00000015 max
0000ec8c l     O .bss	00000004 frame
0000ec90 l     O .bss	00000004 task
0000ec94 l     O .bss	00000004 offset
0000ec98 l     O .bss	00000004 has_more
0000ec9c l     O .bss	00000010 name
00000000 l    df *ABS*	00000000 desc.c
00009968 l     F .text	00000028 lgdt
00009990 l     F .text	00000028 lidt
0000ecac l     O .bss	00000004 gdt
0000ecb0 l     O .bss	00000004 idt
00000000 l    df *ABS*	00000000 dev.c
00009c25 l     F .text	0000001d inb
00009c42 l     F .text	0000001f outb
00009c61 l     F .text	00000022 clump
00000000 l    df *ABS*	00000000 fifo.c
00000000 l    df *ABS*	00000000 file.c
0000a092 l     F .text	0000001d inb
0000a0af l     F .text	0000001f inw
0000a0ce l     F .text	0000001f outb
0000a0ed l     F .text	00000021 outw
00000000 l    df *ABS*	00000000 frame.c
0000aba8 l     F .text	00000015 max
0000abbd l     F .text	00000015 min
0000ed00 l     O .bss	00000080 frames
0000ed80 l     O .bss	00000002 curr_order
0000ed84 l     O .bss	00000004 merge_vram
0000ed88 l     O .bss	00000004 cursor
0000ed8c l     O .bss	00000004 close
0000ed90 l     O .bss	00000004 img
00000000 l    df *ABS*	00000000 graphic.c
0000bbe0 l     F .text	0000001f outb
0000bbff l     F .text	00000007 cli
0000bc06 l     F .text	00000010 read_eflags
0000bc16 l     F .text	0000000b write_eflags
0000bc21 l     F .text	00000015 abs
0000bc36 l     F .text	00000015 max
0000bc4b l     F .text	00000015 min
0000ed94 l     O .bss	00000004 fonts
0000eb20 l     O .data	0000010e rgbs.0
00000000 l    df *ABS*	00000000 int.c
0000c4a5 l     F .text	0000001d inb
0000c4c2 l     F .text	0000001f outb
00000000 l    df *ABS*	00000000 kernel_16.c
0000c64b l     F .text	0000002a inb
0000c675 l     F .text	0000002d outb
0000c6a2 l     F .text	0000000b cli
0000c6ad l     F .text	00000036 lgdt
0000c6e3 l     F .text	0000001a read_cr0
0000c6fd l     F .text	00000012 write_cr0
0000c70f l     F .text	0000002b far_jump
0000ec30 l     O .data	00000018 gdt_table
0000c73a l     F .text	00000092 enter_protect_mode
0000c7cc l     F .text	00000113 detect_memory
00000000 l    df *ABS*	00000000 kernel_32.c
0000c8f5 l     F .text	00000007 cli
0000c8fc l     F .text	00000007 sti
0000c903 l     F .text	00000007 hlt
0000edb0 l     O .bss	00000004 active_frame
0000edb4 l     O .bss	00000004 move_frame
0000edb8 l     O .bss	00000004 offsetX
0000edbc l     O .bss	00000004 offsetY
00000000 l    df *ABS*	00000000 mem.c
0000ee20 l     O .bss	00003000 mems
00000000 l    df *ABS*	00000000 task.c
0000d05f l     F .text	0000001a far_jump
0000d079 l     F .text	00000007 hlt
0000d080 l     F .text	0000000c write_tr
00011e20 l     O .bss	00000002 tss_index
00011e24 l     O .bss	00000004 curr_task
00011e28 l     O .bss	00000004 task_die
00000000 l    df *ABS*	00000000 timer.c
00011e3c l     O .bss	00000004 curr_event
00000000 l    df *ABS*	00000000 tool.c
0000ec48 l     O .data	00000011 num2char
0000cd12 g     F .text	0000007d init_mem
0000a88e g     F .text	00000168 file_write
0000be4a g     F .text	000000e4 draw_block_sub
0000a3d8 g     F .text	00000155 file_open
0000cde4 g     F .text	000000fd mem_alloc
0000b5f7 g     F .text	000000e2 frame_alloc
0000982d g     F .text	000000a0 nano_init
0000bb4f g     F .text	00000091 click_frame
0000c446 g     F .text	0000005f init_graphic
0000b1ae g     F .text	00000275 draw_textbox
00009595 g     F .text	0000016b show_content
00009bcd g     F .text	00000058 set_gate_desc
0000c9ca g     F .text	00000348 kernel_main32
0000b176 g     F .text	00000038 window_init
0000af1a g     F .text	000001f2 draw_window
0000c11f g     F .text	00000146 draw_line
0000aa85 g     F .text	0000008d free_file_link
0000d51d g     F .text	00000022 remove_timer
0000a7c0 g     F .text	000000ce extend_file
00011e2c g     O .bss	00000004 timer
000090eb g     F .text	00000078 image_click
0000c265 g     F .text	000000b3 draw_char
0000c382 g     F .text	000000ad set_palette
00009e61 g     F .text	0000002d init_pit
00009fdf g     F .text	0000005c fifo_read
00009b48 g     F .text	00000085 set_seg_desc
0000c0d9 g     F .text	00000046 draw_point
0000c01e g     F .text	00000036 fill_alpha
000085ed g     F .text	0000048e console_exe
0000857a g     F .text	00000073 console_exit
000083d8 g     F .text	000000e3 add_char
0000807e g     F .text	000000b8 anim_step
0000cee1 g     F .text	0000017e mem_free
0000c4e1 g     F .text	00000093 init_pic
0000804e g       .text	00000000 int_handler_pit
0000ae88 g     F .text	00000092 cursor_init
00008036 g       .text	00000000 int_handler_mouse
00009f34 g     F .text	0000004e fifo_init
0000a9f6 g     F .text	0000003d file_flush
0000b945 g     F .text	000000bd draw_frame_sub
0000d427 g     F .text	0000001a init_timer
0000d930 g     F .text	00000026 str_len
0000b7ac g     F .text	00000075 frame_move
0000d5cf g     F .text	0000007e itoa
0000b10c g     F .text	0000006a window_close
0000bf2e g     F .text	000000f0 draw_block_sub_alpha
00009488 g     F .text	0000005a init_line
0000c42f g     F .text	00000017 palette_init
0000b423 g     F .text	00000186 init_frame
00009fae g     F .text	00000015 fifo_can_read
00009040 g     F .text	00000034 console_click
0000d24a g     F .text	00000120 create_task
0000a10e g     F .text	000000d5 disk_cmd
00008009 g       .text	00000000 protect_mode_main
0000c574 g     F .text	0000004e handler_kbd
00008fa0 g     F .text	000000a0 console_init
0000c054 g     F .text	00000085 fill_rect
0000d36a g     F .text	000000bd init_task
0000ece8 g     O .bss	00000004 window_frame
00008066 g       .text	00000000 int_handler_noise
0000d4d9 g     F .text	00000044 remove_event
0000d53f g     F .text	00000090 tick_timer
0000a340 g     F .text	00000098 find_empty_sel
0000cd8f g     F .text	00000055 mem_total
0000d864 g     F .text	0000008b mem_copy
000099b8 g     F .text	00000156 init_gdt_idt
0000c8df g     F .text	00000016 kernel_main16
0000bc60 g     F .text	000000ed draw_block
0000a2cb g     F .text	00000006 init_file
0000d48e g     F .text	0000004b add_timer
0000a5a1 g     F .text	0000013f file_read
00009d11 g     F .text	00000150 mouse_decode
00000000         *UND*	00000000 _start
0000852c g     F .text	00000028 get_param
0000c318 g     F .text	0000006a draw_str
00009163 g     F .text	00000108 image_init
0000d08c g     F .text	000000d0 idle_task
00009b0e g     F .text	0000003a create_seg_desc
0000c5dc g     F .text	0000005d handler_mouse
0000aa33 g     F .text	00000027 file_close
00009346 g     F .text	00000142 line_init
00008325 g     F .text	000000b3 cursor_blink
000098cd g     F .text	0000009b init_nano
0000ec59 g       .bss	00000000 __bss_start
0000a6e0 g     F .text	000000e0 file_next_sel
0000d1ec g     F .text	0000002a task_sleep
0000c5c2 g     F .text	0000001a handler_pit
0000ab12 g     F .text	00000096 file_delete
0000d8ef g     F .text	00000041 str_pfx
0000b6ff g     F .text	000000ad frame_sort
00009700 g     F .text	0000012d nano_task
0000a03b g     F .text	00000057 fifo_write
00008a7b g     F .text	00000525 console_task
00009074 g     F .text	00000077 init_console
0000edc0 g     O .bss	00000054 ram_info
0000b8ca g     F .text	0000007b frame_refresh
000084bb g     F .text	00000071 clear_cursor
0000ba02 g     F .text	0000014d frame_refresh_sub
0000d216 g     F .text	00000034 task_exit
0000801e g       .text	00000000 int_handler_kbd
0000926b g     F .text	00000063 init_image
00011e30 g     O .bss	0000000c timer_fifo
0000c639 g     F .text	00000012 handler_noise
0000d7c8 g     F .text	0000003a mem_set
0000bd4d g     F .text	000000fd draw_block_alpha
0000d15c g     F .text	00000090 task_switch
0000ecb4 g     O .bss	00000018 mouse
0000abd2 g     F .text	000002b6 bg_init
0000d686 g     F .text	00000142 fmt
00008554 g     F .text	00000026 trim_param
0000ec59 g       .data	00000000 _edata
00011e40 g       .bss	00000000 _end
0000a2d1 g     F .text	0000006f file_item2file
00009e8e g     F .text	000000a6 beep
00009c83 g     F .text	0000001d wait_kbd_ready
0000ed98 g     O .bss	0000000c kdb_fifo
0000a257 g     F .text	00000074 disk_write
00008136 g     F .text	0000009e anim_click
0000a52d g     F .text	00000074 make_sure_buff
0000d64d g     F .text	00000039 append
0000aa5a g     F .text	0000002b file_seek
0000c90a g     F .text	000000c0 test_task
00009cc8 g     F .text	00000049 init_mouse
0000b6d9 g     F .text	00000026 frame_top
0000ece4 g     O .bss	00000004 cursor_frame
00009f82 g     F .text	0000002c fifo_free
000092ce g     F .text	00000078 line_click
00008291 g     F .text	0000005d init_anim
0000a1e3 g     F .text	00000074 disk_read
0000950c g     F .text	00000089 nano_click
0000d441 g     F .text	0000004d insert_event
0000d802 g     F .text	00000062 mem_eq
0000ece0 g     O .bss	00000004 bg_frame
0000b821 g     F .text	000000a9 draw_frame
00009fc3 g     F .text	0000001c fifo_can_write
00009ca0 g     F .text	00000028 init_kbd
0000b5a9 g     F .text	0000004e frame_free
000081d4 g     F .text	000000bd anim_init
0000eda4 g     O .bss	0000000c mouse_fifo



Disassembly of section .text:

00008000 <main>:
	// 显示模式
    //	0x101 :  640 x  480 x 8bit 彩色
    //	0x103 :  800 x  600 x 8bit 彩色
    //	0x105 : 1024 x  768 x 8bit 彩色
    //	0x107 : 1280 x 1024 x 8bit 彩色
	mov	$0x13,%al
    8000:	b0 13                	mov    $0x13,%al
	mov	$0x00,%ah
    8002:	b4 00                	mov    $0x0,%ah
    int	$0x10
    8004:	cd 10                	int    $0x10
    //mov        $0x4f01,%ax
     //int        $0x10

	// 你可能会想，直接跳到kernel_main16，但这样需要先知识kernel_main16在哪儿
	// kernel没有这个能力做到，所以直接用汇编，以便main处于整个bin文件开头，这样boot直接跳到开头就可以
	jmp kernel_main16
    8006:	e9 d6 48             	jmp    c8df <kernel_main16>

00008009 <protect_mode_main>:
	.text
	.global protect_mode_main
	.extern kernel_main32
protect_mode_main:
	// 重新加载所有的数据段描述符
	mov $16, %ax		// 16为数据段选择子
    8009:	66 b8 10 00 8e d8    	mov    $0xd88e0010,%eax
	mov %ax, %ds
    mov %ax, %ss
    800f:	8e d0                	mov    %ax,%ss
    mov %ax, %es
    8011:	8e c0                	mov    %ax,%es
    mov %ax, %fs
    8013:	8e e0                	mov    %ax,%fs
    mov %ax, %gs
    8015:	8e e8                	mov    %ax,%gs

    // 长跳转进入到32位内核加载模式中
    jmp $8, $kernel_main32
    8017:	ea ca c9 00 00       	ljmp   $0x0,$0xc9ca
    801c:	08 00                	or     %al,(%bx,%si)

0000801e <int_handler_kbd>:
// 键盘中断处理函数 保护上下文，为调用函数初始化环境，iret返回中断 注意返回的中断还是返回到对应的段选择子，若是期间重新设置的gdt需要保证对应的选项与原来兼容(cpu会保存选择子)
	.text
	.global int_handler_kbd
	.extern handler_kbd
int_handler_kbd:
    pushal
    801e:	60                   	pusha
    push %ds
    801f:	1e                   	push   %ds
    push %es
    8020:	06                   	push   %es
    push %fs
    8021:	0f a0                	push   %fs
    push %gs
    8023:	0f a8                	push   %gs
    push %esp
    8025:	54                   	push   %sp
    call handler_kbd
    8026:	e8 49 45             	call   c572 <init_pic+0x91>
    8029:	00 00                	add    %al,(%bx,%si)
    add $(1*4), %esp
    802b:	83 c4 04             	add    $0x4,%sp
    pop %gs
    802e:	0f a9                	pop    %gs
    pop %fs
    8030:	0f a1                	pop    %fs
    pop %es
    8032:	07                   	pop    %es
    pop %ds
    8033:	1f                   	pop    %ds
    popal
    8034:	61                   	popa
    iret
    8035:	cf                   	iret

00008036 <int_handler_mouse>:
// 鼠标中断处理函数
	.text
	.global int_handler_mouse
	.extern handler_mouse
int_handler_mouse:
    pushal
    8036:	60                   	pusha
    push %ds
    8037:	1e                   	push   %ds
    push %es
    8038:	06                   	push   %es
    push %fs
    8039:	0f a0                	push   %fs
    push %gs
    803b:	0f a8                	push   %gs
    push %esp
    803d:	54                   	push   %sp
    call handler_mouse
    803e:	e8 99 45             	call   c5da <handler_pit+0x18>
    8041:	00 00                	add    %al,(%bx,%si)
    add $(1*4), %esp
    8043:	83 c4 04             	add    $0x4,%sp
    pop %gs
    8046:	0f a9                	pop    %gs
    pop %fs
    8048:	0f a1                	pop    %fs
    pop %es
    804a:	07                   	pop    %es
    pop %ds
    804b:	1f                   	pop    %ds
    popal
    804c:	61                   	popa
    iret
    804d:	cf                   	iret

0000804e <int_handler_pit>:

	.text
	.global int_handler_pit
	.extern handler_pit
int_handler_pit:
    pushal
    804e:	60                   	pusha
    push %ds
    804f:	1e                   	push   %ds
    push %es
    8050:	06                   	push   %es
    push %fs
    8051:	0f a0                	push   %fs
    push %gs
    8053:	0f a8                	push   %gs
    push %esp
    8055:	54                   	push   %sp
    call handler_pit
    8056:	e8 67 45             	call   c5c0 <handler_kbd+0x4c>
    8059:	00 00                	add    %al,(%bx,%si)
    add $(1*4), %esp
    805b:	83 c4 04             	add    $0x4,%sp
    pop %gs
    805e:	0f a9                	pop    %gs
    pop %fs
    8060:	0f a1                	pop    %fs
    pop %es
    8062:	07                   	pop    %es
    pop %ds
    8063:	1f                   	pop    %ds
    popal
    8064:	61                   	popa
    iret
    8065:	cf                   	iret

00008066 <int_handler_noise>:
// 噪声中断处理函数 详情参考 handler_noise
	.text
	.global int_handler_noise
	.extern handler_noise
int_handler_noise:
    pushal
    8066:	60                   	pusha
    push %ds
    8067:	1e                   	push   %ds
    push %es
    8068:	06                   	push   %es
    push %fs
    8069:	0f a0                	push   %fs
    push %gs
    806b:	0f a8                	push   %gs
    push %esp
    806d:	54                   	push   %sp
    call	handler_noise
    806e:	e8 c6 45             	call   c637 <handler_mouse+0x5b>
    8071:	00 00                	add    %al,(%bx,%si)
    add $(1*4), %esp
    8073:	83 c4 04             	add    $0x4,%sp
    pop %gs
    8076:	0f a9                	pop    %gs
    pop %fs
    8078:	0f a1                	pop    %fs
    pop %es
    807a:	07                   	pop    %es
    pop %ds
    807b:	1f                   	pop    %ds
    popal
    807c:	61                   	popa
    iret
    807d:	cf                   	iret

0000807e <anim_step>:

static frame_t *frame;
static uint8_t *imgs;
static uint8_t index;

void anim_step(){
    807e:	55                   	push   %bp
    807f:	89 e5                	mov    %sp,%bp
    8081:	53                   	push   %bx
    8082:	83 ec 04             	sub    $0x4,%sp
    add_timer(timer+10,anim_step);
    8085:	a1 2c 1e             	mov    0x1e2c,%ax
    8088:	01 00                	add    %ax,(%bx,%si)
    808a:	83 c0 0a             	add    $0xa,%ax
    808d:	83 ec 08             	sub    $0x8,%sp
    8090:	68 7e 80             	push   $0x807e
    8093:	00 00                	add    %al,(%bx,%si)
    8095:	50                   	push   %ax
    8096:	e8 f3 53             	call   d48c <insert_event+0x4b>
    8099:	00 00                	add    %al,(%bx,%si)
    809b:	83 c4 10             	add    $0x10,%sp
    index=(index+1)%ANIM_COUNT;
    809e:	0f b6 05             	movzbw (%di),%ax
    80a1:	68 ec 00             	push   $0xec
    80a4:	00 0f                	add    %cl,(%bx)
    80a6:	b6 c0                	mov    $0xc0,%dh
    80a8:	8d 50 01             	lea    0x1(%bx,%si),%dx
    80ab:	89 d0                	mov    %dx,%ax
    80ad:	c1 f8 1f             	sar    $0x1f,%ax
    80b0:	c1 e8 1c             	shr    $0x1c,%ax
    80b3:	01 c2                	add    %ax,%dx
    80b5:	83 e2 0f             	and    $0xf,%dx
    80b8:	29 c2                	sub    %ax,%dx
    80ba:	89 d0                	mov    %dx,%ax
    80bc:	a2 68 ec             	mov    %al,0xec68
    80bf:	00 00                	add    %al,(%bx,%si)
    draw_block(frame->vram,frame->w,frame->h,8,28,ANIM_W,ANIM_H,imgs+index*ANIM_W*ANIM_H);
    80c1:	a1 64 ec             	mov    0xec64,%ax
    80c4:	00 00                	add    %al,(%bx,%si)
    80c6:	0f b6 15             	movzbw (%di),%dx
    80c9:	68 ec 00             	push   $0xec
    80cc:	00 0f                	add    %cl,(%bx)
    80ce:	b6 d2                	mov    $0xd2,%dh
    80d0:	69 d2 95 0a          	imul   $0xa95,%dx,%dx
    80d4:	00 00                	add    %al,(%bx,%si)
    80d6:	8d 1c                	lea    (%si),%bx
    80d8:	10 a1 60 ec          	adc    %ah,-0x13a0(%bx,%di)
    80dc:	00 00                	add    %al,(%bx,%si)
    80de:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    80e2:	0f b7 c8             	movzww %ax,%cx
    80e5:	a1 60 ec             	mov    0xec60,%ax
    80e8:	00 00                	add    %al,(%bx,%si)
    80ea:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    80ee:	0f b7 d0             	movzww %ax,%dx
    80f1:	a1 60 ec             	mov    0xec60,%ax
    80f4:	00 00                	add    %al,(%bx,%si)
    80f6:	8b 00                	mov    (%bx,%si),%ax
    80f8:	53                   	push   %bx
    80f9:	6a 3f                	push   $0x3f
    80fb:	6a 2b                	push   $0x2b
    80fd:	6a 1c                	push   $0x1c
    80ff:	6a 08                	push   $0x8
    8101:	51                   	push   %cx
    8102:	52                   	push   %dx
    8103:	50                   	push   %ax
    8104:	e8 57 3b             	call   bc5e <min+0x13>
    8107:	00 00                	add    %al,(%bx,%si)
    8109:	83 c4 20             	add    $0x20,%sp
    frame_refresh_sub(frame->x+8,frame->y+28,ANIM_W,ANIM_H);
    810c:	a1 60 ec             	mov    0xec60,%ax
    810f:	00 00                	add    %al,(%bx,%si)
    8111:	8b 40 08             	mov    0x8(%bx,%si),%ax
    8114:	8d 50 1c             	lea    0x1c(%bx,%si),%dx
    8117:	a1 60 ec             	mov    0xec60,%ax
    811a:	00 00                	add    %al,(%bx,%si)
    811c:	8b 40 04             	mov    0x4(%bx,%si),%ax
    811f:	83 c0 08             	add    $0x8,%ax
    8122:	6a 3f                	push   $0x3f
    8124:	6a 2b                	push   $0x2b
    8126:	52                   	push   %dx
    8127:	50                   	push   %ax
    8128:	e8 d5 38             	call   ba00 <draw_frame_sub+0xbb>
    812b:	00 00                	add    %al,(%bx,%si)
    812d:	83 c4 10             	add    $0x10,%sp
}
    8130:	90                   	nop
    8131:	8b 5d fc             	mov    -0x4(%di),%bx
    8134:	c9                   	leave
    8135:	c3                   	ret

00008136 <anim_click>:

bool_t anim_click(int x,int y){
    8136:	55                   	push   %bp
    8137:	89 e5                	mov    %sp,%bp
    8139:	53                   	push   %bx
    813a:	83 ec 04             	sub    $0x4,%sp
    if(window_close(frame, x, y)){
    813d:	a1 60 ec             	mov    0xec60,%ax
    8140:	00 00                	add    %al,(%bx,%si)
    8142:	83 ec 04             	sub    $0x4,%sp
    8145:	ff 75 0c             	push   0xc(%di)
    8148:	ff 75 08             	push   0x8(%di)
    814b:	50                   	push   %ax
    814c:	e8 bb 2f             	call   b10a <draw_window+0x1f0>
    814f:	00 00                	add    %al,(%bx,%si)
    8151:	83 c4 10             	add    $0x10,%sp
    8154:	85 c0                	test   %ax,%ax
    8156:	74 72                	je     81ca <anim_click+0x94>
        remove_timer(anim_step);
    8158:	83 ec 0c             	sub    $0xc,%sp
    815b:	68 7e 80             	push   $0x807e
    815e:	00 00                	add    %al,(%bx,%si)
    8160:	e8 b8 53             	call   d51b <remove_event+0x42>
    8163:	00 00                	add    %al,(%bx,%si)
    8165:	83 c4 10             	add    $0x10,%sp
        mem_free(imgs,ANIM_SIZE);
    8168:	a1 64 ec             	mov    0xec64,%ax
    816b:	00 00                	add    %al,(%bx,%si)
    816d:	83 ec 08             	sub    $0x8,%sp
    8170:	68 50 a9             	push   $0xa950
    8173:	00 00                	add    %al,(%bx,%si)
    8175:	50                   	push   %ax
    8176:	e8 66 4d             	call   cedf <mem_alloc+0xfb>
    8179:	00 00                	add    %al,(%bx,%si)
    817b:	83 c4 10             	add    $0x10,%sp
        frame_free(frame);
    817e:	a1 60 ec             	mov    0xec60,%ax
    8181:	00 00                	add    %al,(%bx,%si)
    8183:	83 ec 0c             	sub    $0xc,%sp
    8186:	50                   	push   %ax
    8187:	e8 1d 34             	call   b5a7 <init_frame+0x184>
    818a:	00 00                	add    %al,(%bx,%si)
    818c:	83 c4 10             	add    $0x10,%sp
        frame_refresh_sub(frame->x, frame->y, frame->w, frame->h);
    818f:	a1 60 ec             	mov    0xec60,%ax
    8192:	00 00                	add    %al,(%bx,%si)
    8194:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    8198:	0f b7 d8             	movzww %ax,%bx
    819b:	a1 60 ec             	mov    0xec60,%ax
    819e:	00 00                	add    %al,(%bx,%si)
    81a0:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    81a4:	0f b7 c8             	movzww %ax,%cx
    81a7:	a1 60 ec             	mov    0xec60,%ax
    81aa:	00 00                	add    %al,(%bx,%si)
    81ac:	8b 50 08             	mov    0x8(%bx,%si),%dx
    81af:	a1 60 ec             	mov    0xec60,%ax
    81b2:	00 00                	add    %al,(%bx,%si)
    81b4:	8b 40 04             	mov    0x4(%bx,%si),%ax
    81b7:	53                   	push   %bx
    81b8:	51                   	push   %cx
    81b9:	52                   	push   %dx
    81ba:	50                   	push   %ax
    81bb:	e8 42 38             	call   ba00 <draw_frame_sub+0xbb>
    81be:	00 00                	add    %al,(%bx,%si)
    81c0:	83 c4 10             	add    $0x10,%sp
        return TRUE;
    81c3:	b8 01 00             	mov    $0x1,%ax
    81c6:	00 00                	add    %al,(%bx,%si)
    81c8:	eb 05                	jmp    81cf <anim_click+0x99>
    }
    return FALSE;
    81ca:	b8 00 00             	mov    $0x0,%ax
    81cd:	00 00                	add    %al,(%bx,%si)
}
    81cf:	8b 5d fc             	mov    -0x4(%di),%bx
    81d2:	c9                   	leave
    81d3:	c3                   	ret

000081d4 <anim_init>:

void anim_init() {
    81d4:	55                   	push   %bp
    81d5:	89 e5                	mov    %sp,%bp
    81d7:	53                   	push   %bx
    81d8:	83 ec 04             	sub    $0x4,%sp
    index=0;
    81db:	c6 05 68             	movb   $0x68,(%di)
    81de:	ec                   	in     (%dx),%al
    81df:	00 00                	add    %al,(%bx,%si)
    81e1:	00 a1 2c 1e          	add    %ah,0x1e2c(%bx,%di)
    add_timer(timer+10,anim_step);
    81e5:	01 00                	add    %ax,(%bx,%si)
    81e7:	83 c0 0a             	add    $0xa,%ax
    81ea:	83 ec 08             	sub    $0x8,%sp
    81ed:	68 7e 80             	push   $0x807e
    81f0:	00 00                	add    %al,(%bx,%si)
    81f2:	50                   	push   %ax
    81f3:	e8 96 52             	call   d48c <insert_event+0x4b>
    81f6:	00 00                	add    %al,(%bx,%si)
    81f8:	83 c4 10             	add    $0x10,%sp
    draw_window(frame->vram, frame->w, frame->h, "ANIM");
    81fb:	a1 60 ec             	mov    0xec60,%ax
    81fe:	00 00                	add    %al,(%bx,%si)
    8200:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    8204:	0f b7 c8             	movzww %ax,%cx
    8207:	a1 60 ec             	mov    0xec60,%ax
    820a:	00 00                	add    %al,(%bx,%si)
    820c:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    8210:	0f b7 d0             	movzww %ax,%dx
    8213:	a1 60 ec             	mov    0xec60,%ax
    8216:	00 00                	add    %al,(%bx,%si)
    8218:	8b 00                	mov    (%bx,%si),%ax
    821a:	68 58 d9             	push   $0xd958
    821d:	00 00                	add    %al,(%bx,%si)
    821f:	51                   	push   %cx
    8220:	52                   	push   %dx
    8221:	50                   	push   %ax
    8222:	e8 f3 2c             	call   af18 <cursor_init+0x90>
    8225:	00 00                	add    %al,(%bx,%si)
    8227:	83 c4 10             	add    $0x10,%sp
    frame_refresh_sub(frame->x,frame->y,frame->w,frame->h);
    822a:	a1 60 ec             	mov    0xec60,%ax
    822d:	00 00                	add    %al,(%bx,%si)
    822f:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    8233:	0f b7 d8             	movzww %ax,%bx
    8236:	a1 60 ec             	mov    0xec60,%ax
    8239:	00 00                	add    %al,(%bx,%si)
    823b:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    823f:	0f b7 c8             	movzww %ax,%cx
    8242:	a1 60 ec             	mov    0xec60,%ax
    8245:	00 00                	add    %al,(%bx,%si)
    8247:	8b 50 08             	mov    0x8(%bx,%si),%dx
    824a:	a1 60 ec             	mov    0xec60,%ax
    824d:	00 00                	add    %al,(%bx,%si)
    824f:	8b 40 04             	mov    0x4(%bx,%si),%ax
    8252:	53                   	push   %bx
    8253:	51                   	push   %cx
    8254:	52                   	push   %dx
    8255:	50                   	push   %ax
    8256:	e8 a7 37             	call   ba00 <draw_frame_sub+0xbb>
    8259:	00 00                	add    %al,(%bx,%si)
    825b:	83 c4 10             	add    $0x10,%sp
    imgs= mem_alloc(ANIM_SIZE);
    825e:	83 ec 0c             	sub    $0xc,%sp
    8261:	68 50 a9             	push   $0xa950
    8264:	00 00                	add    %al,(%bx,%si)
    8266:	e8 79 4b             	call   cde2 <mem_total+0x53>
    8269:	00 00                	add    %al,(%bx,%si)
    826b:	83 c4 10             	add    $0x10,%sp
    826e:	a3 64 ec             	mov    %ax,0xec64
    8271:	00 00                	add    %al,(%bx,%si)
    disk_read(ANIM_SEL,ANIM_SEL_SIZE,imgs);
    8273:	a1 64 ec             	mov    0xec64,%ax
    8276:	00 00                	add    %al,(%bx,%si)
    8278:	83 ec 04             	sub    $0x4,%sp
    827b:	50                   	push   %ax
    827c:	6a 55                	push   $0x55
    827e:	68 00 02             	push   $0x200
    8281:	00 00                	add    %al,(%bx,%si)
    8283:	e8 5b 1f             	call   a1e1 <disk_cmd+0xd3>
    8286:	00 00                	add    %al,(%bx,%si)
    8288:	83 c4 10             	add    $0x10,%sp
}
    828b:	90                   	nop
    828c:	8b 5d fc             	mov    -0x4(%di),%bx
    828f:	c9                   	leave
    8290:	c3                   	ret

00008291 <init_anim>:

void init_anim(){ // 暂时不考虑透明
    8291:	55                   	push   %bp
    8292:	89 e5                	mov    %sp,%bp
    8294:	83 ec 08             	sub    $0x8,%sp
    if(frame&&frame->used){// 防止多次开启
    8297:	a1 60 ec             	mov    0xec60,%ax
    829a:	00 00                	add    %al,(%bx,%si)
    829c:	85 c0                	test   %ax,%ax
    829e:	74 0c                	je     82ac <init_anim+0x1b>
    82a0:	a1 60 ec             	mov    0xec60,%ax
    82a3:	00 00                	add    %al,(%bx,%si)
    82a5:	8b 40 14             	mov    0x14(%bx,%si),%ax
    82a8:	85 c0                	test   %ax,%ax
    82aa:	75 3f                	jne    82eb <init_anim+0x5a>
        return;
    }
    frame= frame_alloc((SCREEN_W - ANIM_W) / 2, (SCREEN_H - ANIM_H) / 2, ANIM_W+8*2, ANIM_H+9+28);
    82ac:	6a 64                	push   $0x64
    82ae:	6a 3b                	push   $0x3b
    82b0:	6a 44                	push   $0x44
    82b2:	68 8a 00             	push   $0x8a
    82b5:	00 00                	add    %al,(%bx,%si)
    82b7:	e8 3b 33             	call   b5f5 <frame_free+0x4c>
    82ba:	00 00                	add    %al,(%bx,%si)
    82bc:	83 c4 10             	add    $0x10,%sp
    82bf:	a3 60 ec             	mov    %ax,0xec60
    82c2:	00 00                	add    %al,(%bx,%si)
    frame->flag|=FRAME_CLICK;
    82c4:	a1 60 ec             	mov    0xec60,%ax
    82c7:	00 00                	add    %al,(%bx,%si)
    82c9:	0f b6 50 12          	movzbw 0x12(%bx,%si),%dx
    82cd:	a1 60 ec             	mov    0xec60,%ax
    82d0:	00 00                	add    %al,(%bx,%si)
    82d2:	83 ca 04             	or     $0x4,%dx
    82d5:	88 50 12             	mov    %dl,0x12(%bx,%si)
    frame->click=anim_click;
    82d8:	a1 60 ec             	mov    0xec60,%ax
    82db:	00 00                	add    %al,(%bx,%si)
    82dd:	c7 40 18 36 81       	movw   $0x8136,0x18(%bx,%si)
    82e2:	00 00                	add    %al,(%bx,%si)
    anim_init();
    82e4:	e8 eb fe             	call   81d2 <anim_click+0x9c>
    82e7:	ff                   	(bad)
    82e8:	ff                   	(bad)
    82e9:	eb 01                	jmp    82ec <init_anim+0x5b>
        return;
    82eb:	90                   	nop
    82ec:	c9                   	leave
    82ed:	c3                   	ret

000082ee <cli>:

static inline void outw(uint16_t port, uint16_t data) {
	__asm__ __volatile__("out %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
}

static inline void cli() {
    82ee:	55                   	push   %bp
    82ef:	89 e5                	mov    %sp,%bp
	__asm__ __volatile__("cli");
    82f1:	fa                   	cli
}
    82f2:	90                   	nop
    82f3:	5d                   	pop    %bp
    82f4:	c3                   	ret

000082f5 <sti>:

static inline void sti() {
    82f5:	55                   	push   %bp
    82f6:	89 e5                	mov    %sp,%bp
	__asm__ __volatile__("sti");
    82f8:	fb                   	sti
}
    82f9:	90                   	nop
    82fa:	5d                   	pop    %bp
    82fb:	c3                   	ret

000082fc <hlt>:
	idt.limit = size - 1;

	__asm__ __volatile__("lidt %0"::"m"(idt));
}

static inline void hlt() {
    82fc:	55                   	push   %bp
    82fd:	89 e5                	mov    %sp,%bp
    __asm__ __volatile__("hlt");
    82ff:	f4                   	hlt
}
    8300:	90                   	nop
    8301:	5d                   	pop    %bp
    8302:	c3                   	ret

00008303 <clump>:
#ifndef MATH_H
#define MATH_H

static inline int clump(int val,int max,int min) {
    8303:	55                   	push   %bp
    8304:	89 e5                	mov    %sp,%bp
    if(val<min){
    8306:	8b 45 08             	mov    0x8(%di),%ax
    8309:	3b 45 10             	cmp    0x10(%di),%ax
    830c:	7d 05                	jge    8313 <clump+0x10>
        return min;
    830e:	8b 45 10             	mov    0x10(%di),%ax
    8311:	eb 10                	jmp    8323 <clump+0x20>
    }
    if(val>max){
    8313:	8b 45 08             	mov    0x8(%di),%ax
    8316:	3b 45 0c             	cmp    0xc(%di),%ax
    8319:	7e 05                	jle    8320 <clump+0x1d>
        return max;
    831b:	8b 45 0c             	mov    0xc(%di),%ax
    831e:	eb 03                	jmp    8323 <clump+0x20>
    }
    return val;
    8320:	8b 45 08             	mov    0x8(%di),%ax
}
    8323:	5d                   	pop    %bp
    8324:	c3                   	ret

00008325 <cursor_blink>:
static bool_t cursor_show;
static bool_t shift_press;
static frame_t *frame;
static task_t *task;

void cursor_blink(){
    8325:	55                   	push   %bp
    8326:	89 e5                	mov    %sp,%bp
    8328:	56                   	push   %si
    8329:	53                   	push   %bx
    832a:	83 ec 10             	sub    $0x10,%sp
    add_timer(timer + 50, cursor_blink);
    832d:	a1 2c 1e             	mov    0x1e2c,%ax
    8330:	01 00                	add    %ax,(%bx,%si)
    8332:	83 c0 32             	add    $0x32,%ax
    8335:	83 ec 08             	sub    $0x8,%sp
    8338:	68 25 83             	push   $0x8325
    833b:	00 00                	add    %al,(%bx,%si)
    833d:	50                   	push   %ax
    833e:	e8 4b 51             	call   d48c <insert_event+0x4b>
    8341:	00 00                	add    %al,(%bx,%si)
    8343:	83 c4 10             	add    $0x10,%sp
    uint8_t col=COL_000000;
    8346:	c6 45 f7 00          	movb   $0x0,-0x9(%di)
    if(cursor_show){
    834a:	a1 74 ec             	mov    0xec74,%ax
    834d:	00 00                	add    %al,(%bx,%si)
    834f:	85 c0                	test   %ax,%ax
    8351:	74 04                	je     8357 <cursor_blink+0x32>
        col=COL_FFFFFF;
    8353:	c6 45 f7 07          	movb   $0x7,-0x9(%di)
    }
    fill_rect(frame->vram, frame->w, cursor_x, cursor_y, 8, 16, col);
    8357:	0f b6 75 f7          	movzbw -0x9(%di),%si
    835b:	a1 70 ec             	mov    0xec70,%ax
    835e:	00 00                	add    %al,(%bx,%si)
    8360:	0f b7 d8             	movzww %ax,%bx
    8363:	a1 6c ec             	mov    0xec6c,%ax
    8366:	00 00                	add    %al,(%bx,%si)
    8368:	0f b7 c8             	movzww %ax,%cx
    836b:	a1 7c ec             	mov    0xec7c,%ax
    836e:	00 00                	add    %al,(%bx,%si)
    8370:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    8374:	0f b7 d0             	movzww %ax,%dx
    8377:	a1 7c ec             	mov    0xec7c,%ax
    837a:	00 00                	add    %al,(%bx,%si)
    837c:	8b 00                	mov    (%bx,%si),%ax
    837e:	83 ec 04             	sub    $0x4,%sp
    8381:	56                   	push   %si
    8382:	6a 10                	push   $0x10
    8384:	6a 08                	push   $0x8
    8386:	53                   	push   %bx
    8387:	51                   	push   %cx
    8388:	52                   	push   %dx
    8389:	50                   	push   %ax
    838a:	e8 c5 3c             	call   c052 <fill_alpha+0x34>
    838d:	00 00                	add    %al,(%bx,%si)
    838f:	83 c4 20             	add    $0x20,%sp
    frame_refresh_sub(frame->x + cursor_x, frame->y + cursor_y, 8, 16);
    8392:	a1 7c ec             	mov    0xec7c,%ax
    8395:	00 00                	add    %al,(%bx,%si)
    8397:	8b 50 08             	mov    0x8(%bx,%si),%dx
    839a:	a1 70 ec             	mov    0xec70,%ax
    839d:	00 00                	add    %al,(%bx,%si)
    839f:	01 c2                	add    %ax,%dx
    83a1:	a1 7c ec             	mov    0xec7c,%ax
    83a4:	00 00                	add    %al,(%bx,%si)
    83a6:	8b 48 04             	mov    0x4(%bx,%si),%cx
    83a9:	a1 6c ec             	mov    0xec6c,%ax
    83ac:	00 00                	add    %al,(%bx,%si)
    83ae:	01 c8                	add    %cx,%ax
    83b0:	6a 10                	push   $0x10
    83b2:	6a 08                	push   $0x8
    83b4:	52                   	push   %dx
    83b5:	50                   	push   %ax
    83b6:	e8 47 36             	call   ba00 <draw_frame_sub+0xbb>
    83b9:	00 00                	add    %al,(%bx,%si)
    83bb:	83 c4 10             	add    $0x10,%sp
    cursor_show=!cursor_show;
    83be:	a1 74 ec             	mov    0xec74,%ax
    83c1:	00 00                	add    %al,(%bx,%si)
    83c3:	85 c0                	test   %ax,%ax
    83c5:	0f 94 c0             	sete   %al
    83c8:	0f b6 c0             	movzbw %al,%ax
    83cb:	a3 74 ec             	mov    %ax,0xec74
    83ce:	00 00                	add    %al,(%bx,%si)
}
    83d0:	90                   	nop
    83d1:	8d 65 f8             	lea    -0x8(%di),%sp
    83d4:	5b                   	pop    %bx
    83d5:	5e                   	pop    %si
    83d6:	5d                   	pop    %bp
    83d7:	c3                   	ret

000083d8 <add_char>:

void add_char(char ch) {
    83d8:	55                   	push   %bp
    83d9:	89 e5                	mov    %sp,%bp
    83db:	56                   	push   %si
    83dc:	53                   	push   %bx
    83dd:	83 ec 10             	sub    $0x10,%sp
    83e0:	8b 45 08             	mov    0x8(%di),%ax
    83e3:	88 45 f4             	mov    %al,-0xc(%di)
    fill_rect(frame->vram, frame->w, cursor_x, cursor_y, 8, 16, COL_000000);
    83e6:	a1 70 ec             	mov    0xec70,%ax
    83e9:	00 00                	add    %al,(%bx,%si)
    83eb:	0f b7 d8             	movzww %ax,%bx
    83ee:	a1 6c ec             	mov    0xec6c,%ax
    83f1:	00 00                	add    %al,(%bx,%si)
    83f3:	0f b7 c8             	movzww %ax,%cx
    83f6:	a1 7c ec             	mov    0xec7c,%ax
    83f9:	00 00                	add    %al,(%bx,%si)
    83fb:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    83ff:	0f b7 d0             	movzww %ax,%dx
    8402:	a1 7c ec             	mov    0xec7c,%ax
    8405:	00 00                	add    %al,(%bx,%si)
    8407:	8b 00                	mov    (%bx,%si),%ax
    8409:	83 ec 04             	sub    $0x4,%sp
    840c:	6a 00                	push   $0x0
    840e:	6a 10                	push   $0x10
    8410:	6a 08                	push   $0x8
    8412:	53                   	push   %bx
    8413:	51                   	push   %cx
    8414:	52                   	push   %dx
    8415:	50                   	push   %ax
    8416:	e8 39 3c             	call   c052 <fill_alpha+0x34>
    8419:	00 00                	add    %al,(%bx,%si)
    841b:	83 c4 20             	add    $0x20,%sp
    draw_char(frame->vram, frame->w, cursor_x, cursor_y, ch, COL_FFFFFF);
    841e:	0f be 75 f4          	movsbw -0xc(%di),%si
    8422:	a1 70 ec             	mov    0xec70,%ax
    8425:	00 00                	add    %al,(%bx,%si)
    8427:	0f b7 d8             	movzww %ax,%bx
    842a:	a1 6c ec             	mov    0xec6c,%ax
    842d:	00 00                	add    %al,(%bx,%si)
    842f:	0f b7 c8             	movzww %ax,%cx
    8432:	a1 7c ec             	mov    0xec7c,%ax
    8435:	00 00                	add    %al,(%bx,%si)
    8437:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    843b:	0f b7 d0             	movzww %ax,%dx
    843e:	a1 7c ec             	mov    0xec7c,%ax
    8441:	00 00                	add    %al,(%bx,%si)
    8443:	8b 00                	mov    (%bx,%si),%ax
    8445:	83 ec 08             	sub    $0x8,%sp
    8448:	6a 07                	push   $0x7
    844a:	56                   	push   %si
    844b:	53                   	push   %bx
    844c:	51                   	push   %cx
    844d:	52                   	push   %dx
    844e:	50                   	push   %ax
    844f:	e8 11 3e             	call   c263 <draw_line+0x144>
    8452:	00 00                	add    %al,(%bx,%si)
    8454:	83 c4 20             	add    $0x20,%sp
    frame_refresh_sub(frame->x + cursor_x, frame->y + cursor_y, 8, 16);
    8457:	a1 7c ec             	mov    0xec7c,%ax
    845a:	00 00                	add    %al,(%bx,%si)
    845c:	8b 50 08             	mov    0x8(%bx,%si),%dx
    845f:	a1 70 ec             	mov    0xec70,%ax
    8462:	00 00                	add    %al,(%bx,%si)
    8464:	01 c2                	add    %ax,%dx
    8466:	a1 7c ec             	mov    0xec7c,%ax
    8469:	00 00                	add    %al,(%bx,%si)
    846b:	8b 48 04             	mov    0x4(%bx,%si),%cx
    846e:	a1 6c ec             	mov    0xec6c,%ax
    8471:	00 00                	add    %al,(%bx,%si)
    8473:	01 c8                	add    %cx,%ax
    8475:	6a 10                	push   $0x10
    8477:	6a 08                	push   $0x8
    8479:	52                   	push   %dx
    847a:	50                   	push   %ax
    847b:	e8 82 35             	call   ba00 <draw_frame_sub+0xbb>
    847e:	00 00                	add    %al,(%bx,%si)
    8480:	83 c4 10             	add    $0x10,%sp
    cursor_x+=8;
    8483:	a1 6c ec             	mov    0xec6c,%ax
    8486:	00 00                	add    %al,(%bx,%si)
    8488:	83 c0 08             	add    $0x8,%ax
    848b:	a3 6c ec             	mov    %ax,0xec6c
    848e:	00 00                	add    %al,(%bx,%si)
    if(cursor_x>240){
    8490:	a1 6c ec             	mov    0xec6c,%ax
    8493:	00 00                	add    %al,(%bx,%si)
    8495:	3d f0 00             	cmp    $0xf0,%ax
    8498:	00 00                	add    %al,(%bx,%si)
    849a:	7e 17                	jle    84b3 <add_char+0xdb>
        cursor_x=8;
    849c:	c7 05 6c ec          	movw   $0xec6c,(%di)
    84a0:	00 00                	add    %al,(%bx,%si)
    84a2:	08 00                	or     %al,(%bx,%si)
    84a4:	00 00                	add    %al,(%bx,%si)
        cursor_y+=16;
    84a6:	a1 70 ec             	mov    0xec70,%ax
    84a9:	00 00                	add    %al,(%bx,%si)
    84ab:	83 c0 10             	add    $0x10,%ax
    84ae:	a3 70 ec             	mov    %ax,0xec70
    84b1:	00 00                	add    %al,(%bx,%si)
    }
}
    84b3:	90                   	nop
    84b4:	8d 65 f8             	lea    -0x8(%di),%sp
    84b7:	5b                   	pop    %bx
    84b8:	5e                   	pop    %si
    84b9:	5d                   	pop    %bp
    84ba:	c3                   	ret

000084bb <clear_cursor>:

void clear_cursor() {
    84bb:	55                   	push   %bp
    84bc:	89 e5                	mov    %sp,%bp
    84be:	53                   	push   %bx
    84bf:	83 ec 04             	sub    $0x4,%sp
    fill_rect(frame->vram, frame->w, cursor_x, cursor_y, 8, 16, COL_000000);
    84c2:	a1 70 ec             	mov    0xec70,%ax
    84c5:	00 00                	add    %al,(%bx,%si)
    84c7:	0f b7 d8             	movzww %ax,%bx
    84ca:	a1 6c ec             	mov    0xec6c,%ax
    84cd:	00 00                	add    %al,(%bx,%si)
    84cf:	0f b7 c8             	movzww %ax,%cx
    84d2:	a1 7c ec             	mov    0xec7c,%ax
    84d5:	00 00                	add    %al,(%bx,%si)
    84d7:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    84db:	0f b7 d0             	movzww %ax,%dx
    84de:	a1 7c ec             	mov    0xec7c,%ax
    84e1:	00 00                	add    %al,(%bx,%si)
    84e3:	8b 00                	mov    (%bx,%si),%ax
    84e5:	83 ec 04             	sub    $0x4,%sp
    84e8:	6a 00                	push   $0x0
    84ea:	6a 10                	push   $0x10
    84ec:	6a 08                	push   $0x8
    84ee:	53                   	push   %bx
    84ef:	51                   	push   %cx
    84f0:	52                   	push   %dx
    84f1:	50                   	push   %ax
    84f2:	e8 5d 3b             	call   c052 <fill_alpha+0x34>
    84f5:	00 00                	add    %al,(%bx,%si)
    84f7:	83 c4 20             	add    $0x20,%sp
    frame_refresh_sub(frame->x + cursor_x, frame->y + cursor_y, 8, 16);
    84fa:	a1 7c ec             	mov    0xec7c,%ax
    84fd:	00 00                	add    %al,(%bx,%si)
    84ff:	8b 50 08             	mov    0x8(%bx,%si),%dx
    8502:	a1 70 ec             	mov    0xec70,%ax
    8505:	00 00                	add    %al,(%bx,%si)
    8507:	01 c2                	add    %ax,%dx
    8509:	a1 7c ec             	mov    0xec7c,%ax
    850c:	00 00                	add    %al,(%bx,%si)
    850e:	8b 48 04             	mov    0x4(%bx,%si),%cx
    8511:	a1 6c ec             	mov    0xec6c,%ax
    8514:	00 00                	add    %al,(%bx,%si)
    8516:	01 c8                	add    %cx,%ax
    8518:	6a 10                	push   $0x10
    851a:	6a 08                	push   $0x8
    851c:	52                   	push   %dx
    851d:	50                   	push   %ax
    851e:	e8 df 34             	call   ba00 <draw_frame_sub+0xbb>
    8521:	00 00                	add    %al,(%bx,%si)
    8523:	83 c4 10             	add    $0x10,%sp
}
    8526:	90                   	nop
    8527:	8b 5d fc             	mov    -0x4(%di),%bx
    852a:	c9                   	leave
    852b:	c3                   	ret

0000852c <get_param>:

// 参数通过空格分割，可以通过这个获取多个参数
char *get_param(char *cmd) {
    852c:	55                   	push   %bp
    852d:	89 e5                	mov    %sp,%bp
    while (*cmd!=' '){
    852f:	eb 04                	jmp    8535 <get_param+0x9>
        cmd++;
    8531:	83 45 08 01          	addw   $0x1,0x8(%di)
    while (*cmd!=' '){
    8535:	8b 45 08             	mov    0x8(%di),%ax
    8538:	0f b6 00             	movzbw (%bx,%si),%ax
    853b:	3c 20                	cmp    $0x20,%al
    853d:	75 f2                	jne    8531 <get_param+0x5>
    }
    while (*cmd==' '){
    853f:	eb 04                	jmp    8545 <get_param+0x19>
        cmd++;
    8541:	83 45 08 01          	addw   $0x1,0x8(%di)
    while (*cmd==' '){
    8545:	8b 45 08             	mov    0x8(%di),%ax
    8548:	0f b6 00             	movzbw (%bx,%si),%ax
    854b:	3c 20                	cmp    $0x20,%al
    854d:	74 f2                	je     8541 <get_param+0x15>
    }
    return cmd;
    854f:	8b 45 08             	mov    0x8(%di),%ax
}
    8552:	5d                   	pop    %bp
    8553:	c3                   	ret

00008554 <trim_param>:

// 多个参数前面的参数后面会有空格，使用改方法裁剪，先重复调用get_param获取所有参数，最后一个参数无需裁剪
void trim_param(char *param){
    8554:	55                   	push   %bp
    8555:	89 e5                	mov    %sp,%bp
    while (*param&&*param!=' '){
    8557:	eb 04                	jmp    855d <trim_param+0x9>
        param++;
    8559:	83 45 08 01          	addw   $0x1,0x8(%di)
    while (*param&&*param!=' '){
    855d:	8b 45 08             	mov    0x8(%di),%ax
    8560:	0f b6 00             	movzbw (%bx,%si),%ax
    8563:	84 c0                	test   %al,%al
    8565:	74 0a                	je     8571 <trim_param+0x1d>
    8567:	8b 45 08             	mov    0x8(%di),%ax
    856a:	0f b6 00             	movzbw (%bx,%si),%ax
    856d:	3c 20                	cmp    $0x20,%al
    856f:	75 e8                	jne    8559 <trim_param+0x5>
    }
    *param='\0';
    8571:	8b 45 08             	mov    0x8(%di),%ax
    8574:	c6 00 00             	movb   $0x0,(%bx,%si)
}
    8577:	90                   	nop
    8578:	5d                   	pop    %bp
    8579:	c3                   	ret

0000857a <console_exit>:

void console_exit() {
    857a:	55                   	push   %bp
    857b:	89 e5                	mov    %sp,%bp
    857d:	53                   	push   %bx
    857e:	83 ec 04             	sub    $0x4,%sp
    remove_timer(cursor_blink);// 移除回掉
    8581:	83 ec 0c             	sub    $0xc,%sp
    8584:	68 25 83             	push   $0x8325
    8587:	00 00                	add    %al,(%bx,%si)
    8589:	e8 8f 4f             	call   d51b <remove_event+0x42>
    858c:	00 00                	add    %al,(%bx,%si)
    858e:	83 c4 10             	add    $0x10,%sp
    frame_free(frame);
    8591:	a1 7c ec             	mov    0xec7c,%ax
    8594:	00 00                	add    %al,(%bx,%si)
    8596:	83 ec 0c             	sub    $0xc,%sp
    8599:	50                   	push   %ax
    859a:	e8 0a 30             	call   b5a7 <init_frame+0x184>
    859d:	00 00                	add    %al,(%bx,%si)
    859f:	83 c4 10             	add    $0x10,%sp
    // frame_refresh();
    frame_refresh_sub(frame->x, frame->y, frame->w, frame->h);
    85a2:	a1 7c ec             	mov    0xec7c,%ax
    85a5:	00 00                	add    %al,(%bx,%si)
    85a7:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    85ab:	0f b7 d8             	movzww %ax,%bx
    85ae:	a1 7c ec             	mov    0xec7c,%ax
    85b1:	00 00                	add    %al,(%bx,%si)
    85b3:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    85b7:	0f b7 c8             	movzww %ax,%cx
    85ba:	a1 7c ec             	mov    0xec7c,%ax
    85bd:	00 00                	add    %al,(%bx,%si)
    85bf:	8b 50 08             	mov    0x8(%bx,%si),%dx
    85c2:	a1 7c ec             	mov    0xec7c,%ax
    85c5:	00 00                	add    %al,(%bx,%si)
    85c7:	8b 40 04             	mov    0x4(%bx,%si),%ax
    85ca:	53                   	push   %bx
    85cb:	51                   	push   %cx
    85cc:	52                   	push   %dx
    85cd:	50                   	push   %ax
    85ce:	e8 2f 34             	call   ba00 <draw_frame_sub+0xbb>
    85d1:	00 00                	add    %al,(%bx,%si)
    85d3:	83 c4 10             	add    $0x10,%sp
    task_exit(task);// 可能是外部调用导致的必须指定当前进程
    85d6:	a1 80 ec             	mov    0xec80,%ax
    85d9:	00 00                	add    %al,(%bx,%si)
    85db:	83 ec 0c             	sub    $0xc,%sp
    85de:	50                   	push   %ax
    85df:	e8 32 4c             	call   d214 <task_sleep+0x28>
    85e2:	00 00                	add    %al,(%bx,%si)
    85e4:	83 c4 10             	add    $0x10,%sp
}
    85e7:	90                   	nop
    85e8:	8b 5d fc             	mov    -0x4(%di),%bx
    85eb:	c9                   	leave
    85ec:	c3                   	ret

000085ed <console_exe>:

uint8_t console_exe(char cmd[32], char *res[]){
    85ed:	55                   	push   %bp
    85ee:	89 e5                	mov    %sp,%bp
    85f0:	53                   	push   %bx
    85f1:	83 ec 44             	sub    $0x44,%sp
    if(str_len(cmd)==0){
    85f4:	83 ec 0c             	sub    $0xc,%sp
    85f7:	ff 75 08             	push   0x8(%di)
    85fa:	e8 31 53             	call   d92e <str_pfx+0x3f>
    85fd:	00 00                	add    %al,(%bx,%si)
    85ff:	83 c4 10             	add    $0x10,%sp
    8602:	85 c0                	test   %ax,%ax
    8604:	75 0a                	jne    8610 <console_exe+0x23>
        return 0;
    8606:	b8 00 00             	mov    $0x0,%ax
    8609:	00 00                	add    %al,(%bx,%si)
    860b:	e9 66 04             	jmp    8a74 <console_exe+0x487>
    860e:	00 00                	add    %al,(%bx,%si)
    }
    if(mem_eq(cmd,"mem")){
    8610:	83 ec 08             	sub    $0x8,%sp
    8613:	68 d7 d9             	push   $0xd9d7
    8616:	00 00                	add    %al,(%bx,%si)
    8618:	ff 75 08             	push   0x8(%di)
    861b:	e8 e2 51             	call   d800 <mem_set+0x38>
    861e:	00 00                	add    %al,(%bx,%si)
    8620:	83 c4 10             	add    $0x10,%sp
    8623:	85 c0                	test   %ax,%ax
    8625:	74 40                	je     8667 <console_exe+0x7a>
        mem_set(res[0],0,32);
    8627:	8b 45 0c             	mov    0xc(%di),%ax
    862a:	8b 00                	mov    (%bx,%si),%ax
    862c:	83 ec 04             	sub    $0x4,%sp
    862f:	6a 20                	push   $0x20
    8631:	6a 00                	push   $0x0
    8633:	50                   	push   %ax
    8634:	e8 8f 51             	call   d7c6 <fmt+0x140>
    8637:	00 00                	add    %al,(%bx,%si)
    8639:	83 c4 10             	add    $0x10,%sp
        fmt(res[0],"Mem %dM",mem_total()/1024/1024);
    863c:	e8 4e 47             	call   cd8d <init_mem+0x7b>
    863f:	00 00                	add    %al,(%bx,%si)
    8641:	c1 e8 14             	shr    $0x14,%ax
    8644:	89 c2                	mov    %ax,%dx
    8646:	8b 45 0c             	mov    0xc(%di),%ax
    8649:	8b 00                	mov    (%bx,%si),%ax
    864b:	83 ec 04             	sub    $0x4,%sp
    864e:	52                   	push   %dx
    864f:	68 db d9             	push   $0xd9db
    8652:	00 00                	add    %al,(%bx,%si)
    8654:	50                   	push   %ax
    8655:	e8 2c 50             	call   d684 <append+0x37>
    8658:	00 00                	add    %al,(%bx,%si)
    865a:	83 c4 10             	add    $0x10,%sp
        return 1;
    865d:	b8 01 00             	mov    $0x1,%ax
    8660:	00 00                	add    %al,(%bx,%si)
    8662:	e9 0f 04             	jmp    8a74 <console_exe+0x487>
    8665:	00 00                	add    %al,(%bx,%si)
    } else if(mem_eq(cmd,"ls")){
    8667:	83 ec 08             	sub    $0x8,%sp
    866a:	68 e3 d9             	push   $0xd9e3
    866d:	00 00                	add    %al,(%bx,%si)
    866f:	ff 75 08             	push   0x8(%di)
    8672:	e8 8b 51             	call   d800 <mem_set+0x38>
    8675:	00 00                	add    %al,(%bx,%si)
    8677:	83 c4 10             	add    $0x10,%sp
    867a:	85 c0                	test   %ax,%ax
    867c:	0f 84 d4 00          	je     8754 <console_exe+0x167>
    8680:	00 00                	add    %al,(%bx,%si)
        file_item_t *base_item= mem_alloc(SECTOR_SIZE);
    8682:	83 ec 0c             	sub    $0xc,%sp
    8685:	68 00 02             	push   $0x200
    8688:	00 00                	add    %al,(%bx,%si)
    868a:	e8 55 47             	call   cde2 <mem_total+0x53>
    868d:	00 00                	add    %al,(%bx,%si)
    868f:	83 c4 10             	add    $0x10,%sp
    8692:	89 45 c4             	mov    %ax,-0x3c(%di)
        disk_read(FILE_HEADER_SEL, 1, base_item);
    8695:	83 ec 04             	sub    $0x4,%sp
    8698:	ff 75 c4             	push   -0x3c(%di)
    869b:	6a 01                	push   $0x1
    869d:	68 00 01             	push   $0x100
    86a0:	00 00                	add    %al,(%bx,%si)
    86a2:	e8 3c 1b             	call   a1e1 <disk_cmd+0xd3>
    86a5:	00 00                	add    %al,(%bx,%si)
    86a7:	83 c4 10             	add    $0x10,%sp
        uint8_t count=0;
    86aa:	c6 45 f7 00          	movb   $0x0,-0x9(%di)
        for (int i = 0; i < FILE_ITEM_COUNT; ++i) {
    86ae:	c7 45 f0 00 00       	movw   $0x0,-0x10(%di)
    86b3:	00 00                	add    %al,(%bx,%si)
    86b5:	eb 7a                	jmp    8731 <console_exe+0x144>
            file_item_t *item=base_item+i;
    86b7:	8b 45 f0             	mov    -0x10(%di),%ax
    86ba:	c1 e0 04             	shl    $0x4,%ax
    86bd:	89 c2                	mov    %ax,%dx
    86bf:	8b 45 c4             	mov    -0x3c(%di),%ax
    86c2:	01 d0                	add    %dx,%ax
    86c4:	89 45 c0             	mov    %ax,-0x40(%di)
            if(item->name[0]!='\0'){
    86c7:	8b 45 c0             	mov    -0x40(%di),%ax
    86ca:	0f b6 00             	movzbw (%bx,%si),%ax
    86cd:	84 c0                	test   %al,%al
    86cf:	74 5c                	je     872d <console_exe+0x140>
                mem_set(res[count],0,32);
    86d1:	0f b6 45 f7          	movzbw -0x9(%di),%ax
    86d5:	8d 14                	lea    (%si),%dx
    86d7:	85 00                	test   %ax,(%bx,%si)
    86d9:	00 00                	add    %al,(%bx,%si)
    86db:	00 8b 45 0c          	add    %cl,0xc45(%bp,%di)
    86df:	01 d0                	add    %dx,%ax
    86e1:	8b 00                	mov    (%bx,%si),%ax
    86e3:	83 ec 04             	sub    $0x4,%sp
    86e6:	6a 20                	push   $0x20
    86e8:	6a 00                	push   $0x0
    86ea:	50                   	push   %ax
    86eb:	e8 d8 50             	call   d7c6 <fmt+0x140>
    86ee:	00 00                	add    %al,(%bx,%si)
    86f0:	83 c4 10             	add    $0x10,%sp
                fmt(res[count++],"%s %dbyte",item->name,item->size);
    86f3:	8b 45 c0             	mov    -0x40(%di),%ax
    86f6:	8b 58 0c             	mov    0xc(%bx,%si),%bx
    86f9:	8b 4d c0             	mov    -0x40(%di),%cx
    86fc:	0f b6 45 f7          	movzbw -0x9(%di),%ax
    8700:	8d 50 01             	lea    0x1(%bx,%si),%dx
    8703:	88 55 f7             	mov    %dl,-0x9(%di)
    8706:	0f b6 c0             	movzbw %al,%ax
    8709:	8d 14                	lea    (%si),%dx
    870b:	85 00                	test   %ax,(%bx,%si)
    870d:	00 00                	add    %al,(%bx,%si)
    870f:	00 8b 45 0c          	add    %cl,0xc45(%bp,%di)
    8713:	01 d0                	add    %dx,%ax
    8715:	8b 00                	mov    (%bx,%si),%ax
    8717:	53                   	push   %bx
    8718:	51                   	push   %cx
    8719:	68 e6 d9             	push   $0xd9e6
    871c:	00 00                	add    %al,(%bx,%si)
    871e:	50                   	push   %ax
    871f:	e8 62 4f             	call   d684 <append+0x37>
    8722:	00 00                	add    %al,(%bx,%si)
    8724:	83 c4 10             	add    $0x10,%sp
                if(count>=8){// 最多显示8个文件 命令行显示的内容太少了
    8727:	80 7d f7 07          	cmpb   $0x7,-0x9(%di)
    872b:	77 0c                	ja     8739 <console_exe+0x14c>
        for (int i = 0; i < FILE_ITEM_COUNT; ++i) {
    872d:	83 45 f0 01          	addw   $0x1,-0x10(%di)
    8731:	83 7d f0 1f          	cmpw   $0x1f,-0x10(%di)
    8735:	7e 80                	jle    86b7 <console_exe+0xca>
    8737:	eb 01                	jmp    873a <console_exe+0x14d>
                    break;
    8739:	90                   	nop
                }
            }
        }
        mem_free(base_item,SECTOR_SIZE);
    873a:	83 ec 08             	sub    $0x8,%sp
    873d:	68 00 02             	push   $0x200
    8740:	00 00                	add    %al,(%bx,%si)
    8742:	ff 75 c4             	push   -0x3c(%di)
    8745:	e8 97 47             	call   cedf <mem_alloc+0xfb>
    8748:	00 00                	add    %al,(%bx,%si)
    874a:	83 c4 10             	add    $0x10,%sp
        return count;
    874d:	0f b6 45 f7          	movzbw -0x9(%di),%ax
    8751:	e9 20 03             	jmp    8a74 <console_exe+0x487>
    8754:	00 00                	add    %al,(%bx,%si)
    }else if(mem_eq(cmd,"exit")){
    8756:	83 ec 08             	sub    $0x8,%sp
    8759:	68 f0 d9             	push   $0xd9f0
    875c:	00 00                	add    %al,(%bx,%si)
    875e:	ff 75 08             	push   0x8(%di)
    8761:	e8 9c 50             	call   d800 <mem_set+0x38>
    8764:	00 00                	add    %al,(%bx,%si)
    8766:	83 c4 10             	add    $0x10,%sp
    8769:	85 c0                	test   %ax,%ax
    876b:	74 0f                	je     877c <console_exe+0x18f>
        console_exit();// 直接通过这个退出没有解除激活窗口，可能有bug 推荐点击关闭
    876d:	e8 08 fe             	call   8578 <trim_param+0x24>
    8770:	ff                   	(bad)
    8771:	ff                   	(bad)
        return 0;
    8772:	b8 00 00             	mov    $0x0,%ax
    8775:	00 00                	add    %al,(%bx,%si)
    8777:	e9 fa 02             	jmp    8a74 <console_exe+0x487>
    877a:	00 00                	add    %al,(%bx,%si)
    }else if(mem_eq(cmd,"line")){
    877c:	83 ec 08             	sub    $0x8,%sp
    877f:	68 f5 d9             	push   $0xd9f5
    8782:	00 00                	add    %al,(%bx,%si)
    8784:	ff 75 08             	push   0x8(%di)
    8787:	e8 76 50             	call   d800 <mem_set+0x38>
    878a:	00 00                	add    %al,(%bx,%si)
    878c:	83 c4 10             	add    $0x10,%sp
    878f:	85 c0                	test   %ax,%ax
    8791:	74 0f                	je     87a2 <console_exe+0x1b5>
        init_line();
    8793:	e8 f0 0c             	call   9486 <line_init+0x140>
    8796:	00 00                	add    %al,(%bx,%si)
        return 0;
    8798:	b8 00 00             	mov    $0x0,%ax
    879b:	00 00                	add    %al,(%bx,%si)
    879d:	e9 d4 02             	jmp    8a74 <console_exe+0x487>
    87a0:	00 00                	add    %al,(%bx,%si)
    }else if(mem_eq(cmd,"anim")){
    87a2:	83 ec 08             	sub    $0x8,%sp
    87a5:	68 fa d9             	push   $0xd9fa
    87a8:	00 00                	add    %al,(%bx,%si)
    87aa:	ff 75 08             	push   0x8(%di)
    87ad:	e8 50 50             	call   d800 <mem_set+0x38>
    87b0:	00 00                	add    %al,(%bx,%si)
    87b2:	83 c4 10             	add    $0x10,%sp
    87b5:	85 c0                	test   %ax,%ax
    87b7:	74 0f                	je     87c8 <console_exe+0x1db>
        init_anim();
    87b9:	e8 d3 fa             	call   828f <anim_init+0xbb>
    87bc:	ff                   	(bad)
    87bd:	ff                   	(bad)
        return 0;
    87be:	b8 00 00             	mov    $0x0,%ax
    87c1:	00 00                	add    %al,(%bx,%si)
    87c3:	e9 ae 02             	jmp    8a74 <console_exe+0x487>
    87c6:	00 00                	add    %al,(%bx,%si)
    } else if(str_pfx(cmd,"cat")){
    87c8:	83 ec 08             	sub    $0x8,%sp
    87cb:	68 ff d9             	push   $0xd9ff
    87ce:	00 00                	add    %al,(%bx,%si)
    87d0:	ff 75 08             	push   0x8(%di)
    87d3:	e8 17 51             	call   d8ed <mem_copy+0x89>
    87d6:	00 00                	add    %al,(%bx,%si)
    87d8:	83 c4 10             	add    $0x10,%sp
    87db:	85 c0                	test   %ax,%ax
    87dd:	0f 84 d8 00          	je     88b9 <console_exe+0x2cc>
    87e1:	00 00                	add    %al,(%bx,%si)
        char *name=get_param(cmd);
    87e3:	83 ec 0c             	sub    $0xc,%sp
    87e6:	ff 75 08             	push   0x8(%di)
    87e9:	e8 3e fd             	call   852a <clear_cursor+0x6f>
    87ec:	ff                   	(bad)
    87ed:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    87f1:	89 45 cc             	mov    %ax,-0x34(%di)
        file_t *file=file_open(name,FALSE);
    87f4:	83 ec 08             	sub    $0x8,%sp
    87f7:	6a 00                	push   $0x0
    87f9:	ff 75 cc             	push   -0x34(%di)
    87fc:	e8 d7 1b             	call   a3d6 <find_empty_sel+0x96>
    87ff:	00 00                	add    %al,(%bx,%si)
    8801:	83 c4 10             	add    $0x10,%sp
    8804:	89 45 c8             	mov    %ax,-0x38(%di)
        if(file){
    8807:	83 7d c8 00          	cmpw   $0x0,-0x38(%di)
    880b:	0f 84 87 00          	je     8896 <console_exe+0x2a9>
    880f:	00 00                	add    %al,(%bx,%si)
            uint8_t count =0;
    8811:	c6 45 ef 00          	movb   $0x0,-0x11(%di)
            while (count<8&&file->pos<file->size){ // 最多读取8行
    8815:	eb 4e                	jmp    8865 <console_exe+0x278>
                mem_set(res[count],0,32);
    8817:	0f b6 45 ef          	movzbw -0x11(%di),%ax
    881b:	8d 14                	lea    (%si),%dx
    881d:	85 00                	test   %ax,(%bx,%si)
    881f:	00 00                	add    %al,(%bx,%si)
    8821:	00 8b 45 0c          	add    %cl,0xc45(%bp,%di)
    8825:	01 d0                	add    %dx,%ax
    8827:	8b 00                	mov    (%bx,%si),%ax
    8829:	83 ec 04             	sub    $0x4,%sp
    882c:	6a 20                	push   $0x20
    882e:	6a 00                	push   $0x0
    8830:	50                   	push   %ax
    8831:	e8 92 4f             	call   d7c6 <fmt+0x140>
    8834:	00 00                	add    %al,(%bx,%si)
    8836:	83 c4 10             	add    $0x10,%sp
                file_read(file,32,(uint8_t *)res[count++]);
    8839:	0f b6 45 ef          	movzbw -0x11(%di),%ax
    883d:	8d 50 01             	lea    0x1(%bx,%si),%dx
    8840:	88 55 ef             	mov    %dl,-0x11(%di)
    8843:	0f b6 c0             	movzbw %al,%ax
    8846:	8d 14                	lea    (%si),%dx
    8848:	85 00                	test   %ax,(%bx,%si)
    884a:	00 00                	add    %al,(%bx,%si)
    884c:	00 8b 45 0c          	add    %cl,0xc45(%bp,%di)
    8850:	01 d0                	add    %dx,%ax
    8852:	8b 00                	mov    (%bx,%si),%ax
    8854:	83 ec 04             	sub    $0x4,%sp
    8857:	50                   	push   %ax
    8858:	6a 20                	push   $0x20
    885a:	ff 75 c8             	push   -0x38(%di)
    885d:	e8 3f 1d             	call   a59f <make_sure_buff+0x72>
    8860:	00 00                	add    %al,(%bx,%si)
    8862:	83 c4 10             	add    $0x10,%sp
            while (count<8&&file->pos<file->size){ // 最多读取8行
    8865:	80 7d ef 07          	cmpb   $0x7,-0x11(%di)
    8869:	77 16                	ja     8881 <console_exe+0x294>
    886b:	8b 45 c8             	mov    -0x38(%di),%ax
    886e:	8b 90 10 02          	mov    0x210(%bx,%si),%dx
    8872:	00 00                	add    %al,(%bx,%si)
    8874:	8b 45 c8             	mov    -0x38(%di),%ax
    8877:	8b 80 14 02          	mov    0x214(%bx,%si),%ax
    887b:	00 00                	add    %al,(%bx,%si)
    887d:	39 c2                	cmp    %ax,%dx
    887f:	72 96                	jb     8817 <console_exe+0x22a>
            }
            file_close(file);
    8881:	83 ec 0c             	sub    $0xc,%sp
    8884:	ff 75 c8             	push   -0x38(%di)
    8887:	e8 a7 21             	call   aa31 <file_flush+0x3b>
    888a:	00 00                	add    %al,(%bx,%si)
    888c:	83 c4 10             	add    $0x10,%sp
            return count;
    888f:	0f b6 45 ef          	movzbw -0x11(%di),%ax
    8893:	e9 de 01             	jmp    8a74 <console_exe+0x487>
    8896:	00 00                	add    %al,(%bx,%si)
        } else{
            fmt(res[0],"file not find %s",name);
    8898:	8b 45 0c             	mov    0xc(%di),%ax
    889b:	8b 00                	mov    (%bx,%si),%ax
    889d:	83 ec 04             	sub    $0x4,%sp
    88a0:	ff 75 cc             	push   -0x34(%di)
    88a3:	68 03 da             	push   $0xda03
    88a6:	00 00                	add    %al,(%bx,%si)
    88a8:	50                   	push   %ax
    88a9:	e8 d8 4d             	call   d684 <append+0x37>
    88ac:	00 00                	add    %al,(%bx,%si)
    88ae:	83 c4 10             	add    $0x10,%sp
            return 1;
    88b1:	b8 01 00             	mov    $0x1,%ax
    88b4:	00 00                	add    %al,(%bx,%si)
    88b6:	e9 bb 01             	jmp    8a74 <console_exe+0x487>
    88b9:	00 00                	add    %al,(%bx,%si)
        }
    }else if(str_pfx(cmd,"write")){// write 文件名(没有自动创建) 内容
    88bb:	83 ec 08             	sub    $0x8,%sp
    88be:	68 14 da             	push   $0xda14
    88c1:	00 00                	add    %al,(%bx,%si)
    88c3:	ff 75 08             	push   0x8(%di)
    88c6:	e8 24 50             	call   d8ed <mem_copy+0x89>
    88c9:	00 00                	add    %al,(%bx,%si)
    88cb:	83 c4 10             	add    $0x10,%sp
    88ce:	85 c0                	test   %ax,%ax
    88d0:	74 7b                	je     894d <console_exe+0x360>
        char *name=get_param(cmd);
    88d2:	83 ec 0c             	sub    $0xc,%sp
    88d5:	ff 75 08             	push   0x8(%di)
    88d8:	e8 4f fc             	call   852a <clear_cursor+0x6f>
    88db:	ff                   	(bad)
    88dc:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    88e0:	89 45 d8             	mov    %ax,-0x28(%di)
        char *content= get_param(name);
    88e3:	83 ec 0c             	sub    $0xc,%sp
    88e6:	ff 75 d8             	push   -0x28(%di)
    88e9:	e8 3e fc             	call   852a <clear_cursor+0x6f>
    88ec:	ff                   	(bad)
    88ed:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    88f1:	89 45 d4             	mov    %ax,-0x2c(%di)
        trim_param(name);
    88f4:	83 ec 0c             	sub    $0xc,%sp
    88f7:	ff 75 d8             	push   -0x28(%di)
    88fa:	e8 55 fc             	call   8552 <get_param+0x26>
    88fd:	ff                   	(bad)
    88fe:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
        file_t *file=file_open(name,TRUE);
    8902:	83 ec 08             	sub    $0x8,%sp
    8905:	6a 01                	push   $0x1
    8907:	ff 75 d8             	push   -0x28(%di)
    890a:	e8 c9 1a             	call   a3d6 <find_empty_sel+0x96>
    890d:	00 00                	add    %al,(%bx,%si)
    890f:	83 c4 10             	add    $0x10,%sp
    8912:	89 45 d0             	mov    %ax,-0x30(%di)
        file_write(file, str_len(content),(uint8_t *)content);
    8915:	83 ec 0c             	sub    $0xc,%sp
    8918:	ff 75 d4             	push   -0x2c(%di)
    891b:	e8 10 50             	call   d92e <str_pfx+0x3f>
    891e:	00 00                	add    %al,(%bx,%si)
    8920:	83 c4 10             	add    $0x10,%sp
    8923:	83 ec 04             	sub    $0x4,%sp
    8926:	ff 75 d4             	push   -0x2c(%di)
    8929:	50                   	push   %ax
    892a:	ff 75 d0             	push   -0x30(%di)
    892d:	e8 5c 1f             	call   a88c <extend_file+0xcc>
    8930:	00 00                	add    %al,(%bx,%si)
    8932:	83 c4 10             	add    $0x10,%sp
        file_close(file);
    8935:	83 ec 0c             	sub    $0xc,%sp
    8938:	ff 75 d0             	push   -0x30(%di)
    893b:	e8 f3 20             	call   aa31 <file_flush+0x3b>
    893e:	00 00                	add    %al,(%bx,%si)
    8940:	83 c4 10             	add    $0x10,%sp
        return 0;
    8943:	b8 00 00             	mov    $0x0,%ax
    8946:	00 00                	add    %al,(%bx,%si)
    8948:	e9 29 01             	jmp    8a74 <console_exe+0x487>
    894b:	00 00                	add    %al,(%bx,%si)
    } else if(str_pfx(cmd,"rm")){// write 文件名(没有自动创建) 内容
    894d:	83 ec 08             	sub    $0x8,%sp
    8950:	68 1a da             	push   $0xda1a
    8953:	00 00                	add    %al,(%bx,%si)
    8955:	ff 75 08             	push   0x8(%di)
    8958:	e8 92 4f             	call   d8ed <mem_copy+0x89>
    895b:	00 00                	add    %al,(%bx,%si)
    895d:	83 c4 10             	add    $0x10,%sp
    8960:	85 c0                	test   %ax,%ax
    8962:	74 7a                	je     89de <console_exe+0x3f1>
        char *name=get_param(cmd);
    8964:	83 ec 0c             	sub    $0xc,%sp
    8967:	ff 75 08             	push   0x8(%di)
    896a:	e8 bd fb             	call   852a <clear_cursor+0x6f>
    896d:	ff                   	(bad)
    896e:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    8972:	89 45 e0             	mov    %ax,-0x20(%di)
        file_t *file=file_open(name,FALSE);
    8975:	83 ec 08             	sub    $0x8,%sp
    8978:	6a 00                	push   $0x0
    897a:	ff 75 e0             	push   -0x20(%di)
    897d:	e8 56 1a             	call   a3d6 <find_empty_sel+0x96>
    8980:	00 00                	add    %al,(%bx,%si)
    8982:	83 c4 10             	add    $0x10,%sp
    8985:	89 45 dc             	mov    %ax,-0x24(%di)
        if(file){
    8988:	83 7d dc 00          	cmpw   $0x0,-0x24(%di)
    898c:	74 18                	je     89a6 <console_exe+0x3b9>
            file_delete(file);
    898e:	83 ec 0c             	sub    $0xc,%sp
    8991:	ff 75 dc             	push   -0x24(%di)
    8994:	e8 79 21             	call   ab10 <free_file_link+0x8b>
    8997:	00 00                	add    %al,(%bx,%si)
    8999:	83 c4 10             	add    $0x10,%sp
            return 0;
    899c:	b8 00 00             	mov    $0x0,%ax
    899f:	00 00                	add    %al,(%bx,%si)
    89a1:	e9 d0 00             	jmp    8a74 <console_exe+0x487>
    89a4:	00 00                	add    %al,(%bx,%si)
        } else{
            mem_set(res[0],0,32);
    89a6:	8b 45 0c             	mov    0xc(%di),%ax
    89a9:	8b 00                	mov    (%bx,%si),%ax
    89ab:	83 ec 04             	sub    $0x4,%sp
    89ae:	6a 20                	push   $0x20
    89b0:	6a 00                	push   $0x0
    89b2:	50                   	push   %ax
    89b3:	e8 10 4e             	call   d7c6 <fmt+0x140>
    89b6:	00 00                	add    %al,(%bx,%si)
    89b8:	83 c4 10             	add    $0x10,%sp
            fmt(res[0],"file not find %s",name);
    89bb:	8b 45 0c             	mov    0xc(%di),%ax
    89be:	8b 00                	mov    (%bx,%si),%ax
    89c0:	83 ec 04             	sub    $0x4,%sp
    89c3:	ff 75 e0             	push   -0x20(%di)
    89c6:	68 03 da             	push   $0xda03
    89c9:	00 00                	add    %al,(%bx,%si)
    89cb:	50                   	push   %ax
    89cc:	e8 b5 4c             	call   d684 <append+0x37>
    89cf:	00 00                	add    %al,(%bx,%si)
    89d1:	83 c4 10             	add    $0x10,%sp
            return 1;
    89d4:	b8 01 00             	mov    $0x1,%ax
    89d7:	00 00                	add    %al,(%bx,%si)
    89d9:	e9 98 00             	jmp    8a74 <console_exe+0x487>
    89dc:	00 00                	add    %al,(%bx,%si)
        }
    } else if(str_pfx(cmd,"img")){
    89de:	83 ec 08             	sub    $0x8,%sp
    89e1:	68 1d da             	push   $0xda1d
    89e4:	00 00                	add    %al,(%bx,%si)
    89e6:	ff 75 08             	push   0x8(%di)
    89e9:	e8 01 4f             	call   d8ed <mem_copy+0x89>
    89ec:	00 00                	add    %al,(%bx,%si)
    89ee:	83 c4 10             	add    $0x10,%sp
    89f1:	85 c0                	test   %ax,%ax
    89f3:	74 26                	je     8a1b <console_exe+0x42e>
        char *path= get_param(cmd);
    89f5:	83 ec 0c             	sub    $0xc,%sp
    89f8:	ff 75 08             	push   0x8(%di)
    89fb:	e8 2c fb             	call   852a <clear_cursor+0x6f>
    89fe:	ff                   	(bad)
    89ff:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    8a03:	89 45 e4             	mov    %ax,-0x1c(%di)
        init_image(path);
    8a06:	83 ec 0c             	sub    $0xc,%sp
    8a09:	ff 75 e4             	push   -0x1c(%di)
    8a0c:	e8 5a 08             	call   9269 <image_init+0x106>
    8a0f:	00 00                	add    %al,(%bx,%si)
    8a11:	83 c4 10             	add    $0x10,%sp
        return 0;
    8a14:	b8 00 00             	mov    $0x0,%ax
    8a17:	00 00                	add    %al,(%bx,%si)
    8a19:	eb 5b                	jmp    8a76 <console_exe+0x489>
    }else if(str_pfx(cmd,"nano")){
    8a1b:	83 ec 08             	sub    $0x8,%sp
    8a1e:	68 21 da             	push   $0xda21
    8a21:	00 00                	add    %al,(%bx,%si)
    8a23:	ff 75 08             	push   0x8(%di)
    8a26:	e8 c4 4e             	call   d8ed <mem_copy+0x89>
    8a29:	00 00                	add    %al,(%bx,%si)
    8a2b:	83 c4 10             	add    $0x10,%sp
    8a2e:	85 c0                	test   %ax,%ax
    8a30:	74 26                	je     8a58 <console_exe+0x46b>
        char *path= get_param(cmd);
    8a32:	83 ec 0c             	sub    $0xc,%sp
    8a35:	ff 75 08             	push   0x8(%di)
    8a38:	e8 ef fa             	call   852a <clear_cursor+0x6f>
    8a3b:	ff                   	(bad)
    8a3c:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    8a40:	89 45 e8             	mov    %ax,-0x18(%di)
        init_nano(path);
    8a43:	83 ec 0c             	sub    $0xc,%sp
    8a46:	ff 75 e8             	push   -0x18(%di)
    8a49:	e8 7f 0e             	call   98cb <nano_init+0x9e>
    8a4c:	00 00                	add    %al,(%bx,%si)
    8a4e:	83 c4 10             	add    $0x10,%sp
        return 0;
    8a51:	b8 00 00             	mov    $0x0,%ax
    8a54:	00 00                	add    %al,(%bx,%si)
    8a56:	eb 1e                	jmp    8a76 <console_exe+0x489>
    }
    fmt(res[0],"No Cmd Of %s",cmd);
    8a58:	8b 45 0c             	mov    0xc(%di),%ax
    8a5b:	8b 00                	mov    (%bx,%si),%ax
    8a5d:	83 ec 04             	sub    $0x4,%sp
    8a60:	ff 75 08             	push   0x8(%di)
    8a63:	68 26 da             	push   $0xda26
    8a66:	00 00                	add    %al,(%bx,%si)
    8a68:	50                   	push   %ax
    8a69:	e8 18 4c             	call   d684 <append+0x37>
    8a6c:	00 00                	add    %al,(%bx,%si)
    8a6e:	83 c4 10             	add    $0x10,%sp
    return 1;
    8a71:	b8 01 00             	mov    $0x1,%ax
    8a74:	00 00                	add    %al,(%bx,%si)
}
    8a76:	8b 5d fc             	mov    -0x4(%di),%bx
    8a79:	c9                   	leave
    8a7a:	c3                   	ret

00008a7b <console_task>:

void console_task(){
    8a7b:	55                   	push   %bp
    8a7c:	89 e5                	mov    %sp,%bp
    8a7e:	56                   	push   %si
    8a7f:	53                   	push   %bx
    8a80:	83 ec 60             	sub    $0x60,%sp
    cursor_x=8;
    8a83:	c7 05 6c ec          	movw   $0xec6c,(%di)
    8a87:	00 00                	add    %al,(%bx,%si)
    8a89:	08 00                	or     %al,(%bx,%si)
    8a8b:	00 00                	add    %al,(%bx,%si)
    cursor_y=28;
    8a8d:	c7 05 70 ec          	movw   $0xec70,(%di)
    8a91:	00 00                	add    %al,(%bx,%si)
    8a93:	1c 00                	sbb    $0x0,%al
    8a95:	00 00                	add    %al,(%bx,%si)
    cursor_show=TRUE;
    8a97:	c7 05 74 ec          	movw   $0xec74,(%di)
    8a9b:	00 00                	add    %al,(%bx,%si)
    8a9d:	01 00                	add    %ax,(%bx,%si)
    8a9f:	00 00                	add    %al,(%bx,%si)
    shift_press=FALSE;
    8aa1:	c7 05 78 ec          	movw   $0xec78,(%di)
    8aa5:	00 00                	add    %al,(%bx,%si)
    8aa7:	00 00                	add    %al,(%bx,%si)
    8aa9:	00 00                	add    %al,(%bx,%si)
    add_timer(timer + 50, cursor_blink);
    8aab:	a1 2c 1e             	mov    0x1e2c,%ax
    8aae:	01 00                	add    %ax,(%bx,%si)
    8ab0:	83 c0 32             	add    $0x32,%ax
    8ab3:	83 ec 08             	sub    $0x8,%sp
    8ab6:	68 25 83             	push   $0x8325
    8ab9:	00 00                	add    %al,(%bx,%si)
    8abb:	50                   	push   %ax
    8abc:	e8 cd 49             	call   d48c <insert_event+0x4b>
    8abf:	00 00                	add    %al,(%bx,%si)
    8ac1:	83 c4 10             	add    $0x10,%sp
    char cmd_line[32];
    mem_set(cmd_line,0, sizeof(cmd_line));
    8ac4:	83 ec 04             	sub    $0x4,%sp
    8ac7:	6a 20                	push   $0x20
    8ac9:	6a 00                	push   $0x0
    8acb:	8d 45 c1             	lea    -0x3f(%di),%ax
    8ace:	50                   	push   %ax
    8acf:	e8 f4 4c             	call   d7c6 <fmt+0x140>
    8ad2:	00 00                	add    %al,(%bx,%si)
    8ad4:	83 c4 10             	add    $0x10,%sp
    uint8_t cmd_index=0;
    8ad7:	c6 45 f7 00          	movb   $0x0,-0x9(%di)
    char *res[8]; // 最多展示8行,每行最多32个字符
    for (int i = 0; i < 8; ++i) {
    8adb:	c7 45 f0 00 00       	movw   $0x0,-0x10(%di)
    8ae0:	00 00                	add    %al,(%bx,%si)
    8ae2:	eb 18                	jmp    8afc <console_task+0x81>
        res[i]= mem_alloc(32);
    8ae4:	83 ec 0c             	sub    $0xc,%sp
    8ae7:	6a 20                	push   $0x20
    8ae9:	e8 f6 42             	call   cde2 <mem_total+0x53>
    8aec:	00 00                	add    %al,(%bx,%si)
    8aee:	83 c4 10             	add    $0x10,%sp
    8af1:	8b 55 f0             	mov    -0x10(%di),%dx
    8af4:	89 44 95             	mov    %ax,-0x6b(%si)
    8af7:	a0 83 45             	mov    0x4583,%al
    for (int i = 0; i < 8; ++i) {
    8afa:	f0 01 83 7d f0       	lock add %ax,-0xf83(%bp,%di)
    8aff:	07                   	pop    %es
    8b00:	7e e2                	jle    8ae4 <console_task+0x69>
    }
    // 输出默认提示符
    add_char('>');
    8b02:	83 ec 0c             	sub    $0xc,%sp
    8b05:	6a 3e                	push   $0x3e
    8b07:	e8 cc f8             	call   83d6 <cursor_blink+0xb1>
    8b0a:	ff                   	(bad)
    8b0b:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    while (TRUE){
        cli();
    8b0f:	e8 da f7             	call   82ec <init_anim+0x5b>
    8b12:	ff                   	(bad)
    8b13:	ff a1 7c ec          	jmp    *-0x1384(%bx,%di)
        if(fifo_can_read(&frame->kdb_fifo)){
    8b17:	00 00                	add    %al,(%bx,%si)
    8b19:	83 c0 1c             	add    $0x1c,%ax
    8b1c:	83 ec 0c             	sub    $0xc,%sp
    8b1f:	50                   	push   %ax
    8b20:	e8 89 14             	call   9fac <fifo_free+0x2a>
    8b23:	00 00                	add    %al,(%bx,%si)
    8b25:	83 c4 10             	add    $0x10,%sp
    8b28:	85 c0                	test   %ax,%ax
    8b2a:	0f 84 61 04          	je     8f8f <console_task+0x514>
    8b2e:	00 00                	add    %al,(%bx,%si)
            uint8_t data= fifo_read(&frame->kdb_fifo);
    8b30:	a1 7c ec             	mov    0xec7c,%ax
    8b33:	00 00                	add    %al,(%bx,%si)
    8b35:	83 c0 1c             	add    $0x1c,%ax
    8b38:	83 ec 0c             	sub    $0xc,%sp
    8b3b:	50                   	push   %ax
    8b3c:	e8 9e 14             	call   9fdd <fifo_can_write+0x1a>
    8b3f:	00 00                	add    %al,(%bx,%si)
    8b41:	83 c4 10             	add    $0x10,%sp
    8b44:	88 45 e3             	mov    %al,-0x1d(%di)
            sti();
    8b47:	e8 a9 f7             	call   82f3 <cli+0x5>
    8b4a:	ff                   	(bad)
    8b4b:	ff 80 7d e3          	incw   -0x1c83(%bx,%si)
            if(data==42){// shift 按下 暂时只处理 左shift
    8b4f:	2a 75 0c             	sub    0xc(%di),%dh
                shift_press=TRUE;
    8b52:	c7 05 78 ec          	movw   $0xec78,(%di)
    8b56:	00 00                	add    %al,(%bx,%si)
    8b58:	01 00                	add    %ax,(%bx,%si)
    8b5a:	00 00                	add    %al,(%bx,%si)
    8b5c:	eb b1                	jmp    8b0f <console_task+0x94>
            } else if(data==170){// shift 松开
    8b5e:	80 7d e3 aa          	cmpb   $0xaa,-0x1d(%di)
    8b62:	75 0c                	jne    8b70 <console_task+0xf5>
                shift_press=FALSE;
    8b64:	c7 05 78 ec          	movw   $0xec78,(%di)
    8b68:	00 00                	add    %al,(%bx,%si)
    8b6a:	00 00                	add    %al,(%bx,%si)
    8b6c:	00 00                	add    %al,(%bx,%si)
    8b6e:	eb 9f                	jmp    8b0f <console_task+0x94>
            } else if(data==14){ // 删除键
    8b70:	80 7d e3 0e          	cmpb   $0xe,-0x1d(%di)
    8b74:	75 5b                	jne    8bd1 <console_task+0x156>
                // 清楚原来的防止留白
                clear_cursor();
    8b76:	e8 40 f9             	call   84b9 <add_char+0xe1>
    8b79:	ff                   	(bad)
    8b7a:	ff a1 6c ec          	jmp    *-0x1394(%bx,%di)
                if(cursor_x>8){
    8b7e:	00 00                	add    %al,(%bx,%si)
    8b80:	83 f8 08             	cmp    $0x8,%ax
    8b83:	7e 0f                	jle    8b94 <console_task+0x119>
                    cursor_x-=8;
    8b85:	a1 6c ec             	mov    0xec6c,%ax
    8b88:	00 00                	add    %al,(%bx,%si)
    8b8a:	83 e8 08             	sub    $0x8,%ax
    8b8d:	a3 6c ec             	mov    %ax,0xec6c
    8b90:	00 00                	add    %al,(%bx,%si)
    8b92:	eb 21                	jmp    8bb5 <console_task+0x13a>
                } else if(cursor_y>28){
    8b94:	a1 70 ec             	mov    0xec70,%ax
    8b97:	00 00                	add    %al,(%bx,%si)
    8b99:	83 f8 1c             	cmp    $0x1c,%ax
    8b9c:	7e 17                	jle    8bb5 <console_task+0x13a>
                    cursor_y-=16;
    8b9e:	a1 70 ec             	mov    0xec70,%ax
    8ba1:	00 00                	add    %al,(%bx,%si)
    8ba3:	83 e8 10             	sub    $0x10,%ax
    8ba6:	a3 70 ec             	mov    %ax,0xec70
    8ba9:	00 00                	add    %al,(%bx,%si)
                    cursor_x=240;
    8bab:	c7 05 6c ec          	movw   $0xec6c,(%di)
    8baf:	00 00                	add    %al,(%bx,%si)
    8bb1:	f0 00 00             	lock add %al,(%bx,%si)
    8bb4:	00 80 7d f7          	add    %al,-0x883(%bx,%si)
                }
                if(cmd_index>0){
    8bb8:	00 0f                	add    %cl,(%bx)
    8bba:	84 50 ff             	test   %dl,-0x1(%bx,%si)
    8bbd:	ff                   	(bad)
    8bbe:	ff 80 6d f7          	incw   -0x893(%bx,%si)
                    cmd_line[--cmd_index]='\0';
    8bc2:	01 0f                	add    %cx,(%bx)
    8bc4:	b6 45                	mov    $0x45,%dh
    8bc6:	f7 c6 44 05          	test   $0x544,%si
    8bca:	c1 00 e9             	rolw   $0xe9,(%bx,%si)
    8bcd:	3e ff                	ds (bad)
    8bcf:	ff                   	(bad)
    8bd0:	ff 80 7d e3          	incw   -0x1c83(%bx,%si)
                }
            } else if(data==15){ // 退格
    8bd4:	0f 75 3c             	pcmpeqw (%si),%mm7
                // 清楚原来的防止留白
                clear_cursor();
    8bd7:	e8 df f8             	call   84b9 <add_char+0xe1>
    8bda:	ff                   	(bad)
    8bdb:	ff a1 6c ec          	jmp    *-0x1394(%bx,%di)
                cursor_x= clump(cursor_x+4*8,240,8);
    8bdf:	00 00                	add    %al,(%bx,%si)
    8be1:	83 c0 20             	add    $0x20,%ax
    8be4:	83 ec 04             	sub    $0x4,%sp
    8be7:	6a 08                	push   $0x8
    8be9:	68 f0 00             	push   $0xf0
    8bec:	00 00                	add    %al,(%bx,%si)
    8bee:	50                   	push   %ax
    8bef:	e8 0f f7             	call   8301 <hlt+0x5>
    8bf2:	ff                   	(bad)
    8bf3:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    8bf7:	a3 6c ec             	mov    %ax,0xec6c
    8bfa:	00 00                	add    %al,(%bx,%si)
                cmd_line[cmd_index++]=' ';
    8bfc:	0f b6 45 f7          	movzbw -0x9(%di),%ax
    8c00:	8d 50 01             	lea    0x1(%bx,%si),%dx
    8c03:	88 55 f7             	mov    %dl,-0x9(%di)
    8c06:	0f b6 c0             	movzbw %al,%ax
    8c09:	c6 44 05 c1          	movb   $0xc1,0x5(%si)
    8c0d:	20 e9                	and    %ch,%cl
    8c0f:	fc                   	cld
    8c10:	fe                   	(bad)
    8c11:	ff                   	(bad)
    8c12:	ff 80 7d e3          	incw   -0x1c83(%bx,%si)
            } else if(data==28){ // 回车键
    8c16:	1c 0f                	sbb    $0xf,%al
    8c18:	85 28                	test   %bp,(%bx,%si)
    8c1a:	03 00                	add    (%bx,%si),%ax
    8c1c:	00 83 ec 08          	add    %al,0x8ec(%bp,%di)
                if(mem_eq(cmd_line,"cls")){// 比较特别不输出任何内容,清屏幕
    8c20:	68 33 da             	push   $0xda33
    8c23:	00 00                	add    %al,(%bx,%si)
    8c25:	8d 45 c1             	lea    -0x3f(%di),%ax
    8c28:	50                   	push   %ax
    8c29:	e8 d4 4b             	call   d800 <mem_set+0x38>
    8c2c:	00 00                	add    %al,(%bx,%si)
    8c2e:	83 c4 10             	add    $0x10,%sp
    8c31:	85 c0                	test   %ax,%ax
    8c33:	74 73                	je     8ca8 <console_task+0x22d>
                    fill_rect(frame->vram, frame->w, 8, 28, 240, 128, COL_000000);
    8c35:	a1 7c ec             	mov    0xec7c,%ax
    8c38:	00 00                	add    %al,(%bx,%si)
    8c3a:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    8c3e:	0f b7 d0             	movzww %ax,%dx
    8c41:	a1 7c ec             	mov    0xec7c,%ax
    8c44:	00 00                	add    %al,(%bx,%si)
    8c46:	8b 00                	mov    (%bx,%si),%ax
    8c48:	83 ec 04             	sub    $0x4,%sp
    8c4b:	6a 00                	push   $0x0
    8c4d:	68 80 00             	push   $0x80
    8c50:	00 00                	add    %al,(%bx,%si)
    8c52:	68 f0 00             	push   $0xf0
    8c55:	00 00                	add    %al,(%bx,%si)
    8c57:	6a 1c                	push   $0x1c
    8c59:	6a 08                	push   $0x8
    8c5b:	52                   	push   %dx
    8c5c:	50                   	push   %ax
    8c5d:	e8 f2 33             	call   c052 <fill_alpha+0x34>
    8c60:	00 00                	add    %al,(%bx,%si)
    8c62:	83 c4 20             	add    $0x20,%sp
                    frame_refresh_sub(frame->x + 8, frame->y + 28, 240, 128);
    8c65:	a1 7c ec             	mov    0xec7c,%ax
    8c68:	00 00                	add    %al,(%bx,%si)
    8c6a:	8b 40 08             	mov    0x8(%bx,%si),%ax
    8c6d:	8d 50 1c             	lea    0x1c(%bx,%si),%dx
    8c70:	a1 7c ec             	mov    0xec7c,%ax
    8c73:	00 00                	add    %al,(%bx,%si)
    8c75:	8b 40 04             	mov    0x4(%bx,%si),%ax
    8c78:	83 c0 08             	add    $0x8,%ax
    8c7b:	68 80 00             	push   $0x80
    8c7e:	00 00                	add    %al,(%bx,%si)
    8c80:	68 f0 00             	push   $0xf0
    8c83:	00 00                	add    %al,(%bx,%si)
    8c85:	52                   	push   %dx
    8c86:	50                   	push   %ax
    8c87:	e8 76 2d             	call   ba00 <draw_frame_sub+0xbb>
    8c8a:	00 00                	add    %al,(%bx,%si)
    8c8c:	83 c4 10             	add    $0x10,%sp
                    cursor_x=8;
    8c8f:	c7 05 6c ec          	movw   $0xec6c,(%di)
    8c93:	00 00                	add    %al,(%bx,%si)
    8c95:	08 00                	or     %al,(%bx,%si)
    8c97:	00 00                	add    %al,(%bx,%si)
                    cursor_y=28;
    8c99:	c7 05 70 ec          	movw   $0xec70,(%di)
    8c9d:	00 00                	add    %al,(%bx,%si)
    8c9f:	1c 00                	sbb    $0x0,%al
    8ca1:	00 00                	add    %al,(%bx,%si)
    8ca3:	e9 74 02             	jmp    8f1a <console_task+0x49f>
    8ca6:	00 00                	add    %al,(%bx,%si)
                } else{
                    uint8_t count= console_exe(cmd_line,res);
    8ca8:	83 ec 08             	sub    $0x8,%sp
    8cab:	8d 45 a0             	lea    -0x60(%di),%ax
    8cae:	50                   	push   %ax
    8caf:	8d 45 c1             	lea    -0x3f(%di),%ax
    8cb2:	50                   	push   %ax
    8cb3:	e8 35 f9             	call   85eb <console_exit+0x71>
    8cb6:	ff                   	(bad)
    8cb7:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    8cbb:	88 45 e1             	mov    %al,-0x1f(%di)
                    if(cursor_y+count*16<140){// 可以直接展示
    8cbe:	0f b6 45 e1          	movzbw -0x1f(%di),%ax
    8cc2:	c1 e0 04             	shl    $0x4,%ax
    8cc5:	89 c2                	mov    %ax,%dx
    8cc7:	a1 70 ec             	mov    0xec70,%ax
    8cca:	00 00                	add    %al,(%bx,%si)
    8ccc:	01 d0                	add    %dx,%ax
    8cce:	3d 8b 00             	cmp    $0x8b,%ax
    8cd1:	00 00                	add    %al,(%bx,%si)
    8cd3:	0f 8f c0 00          	jg     8d97 <console_task+0x31c>
    8cd7:	00 00                	add    %al,(%bx,%si)
                        // 清楚原来的防止留白
                        clear_cursor();
    8cd9:	e8 dd f7             	call   84b9 <add_char+0xe1>
    8cdc:	ff                   	(bad)
    8cdd:	ff a1 70 ec          	jmp    *-0x1390(%bx,%di)
                        cursor_y+=16;
    8ce1:	00 00                	add    %al,(%bx,%si)
    8ce3:	83 c0 10             	add    $0x10,%ax
    8ce6:	a3 70 ec             	mov    %ax,0xec70
    8ce9:	00 00                	add    %al,(%bx,%si)
                        cursor_x=8;
    8ceb:	c7 05 6c ec          	movw   $0xec6c,(%di)
    8cef:	00 00                	add    %al,(%bx,%si)
    8cf1:	08 00                	or     %al,(%bx,%si)
    8cf3:	00 00                	add    %al,(%bx,%si)
                        for (int i = 0; i < count; ++i) {
    8cf5:	c7 45 ec 00 00       	movw   $0x0,-0x14(%di)
    8cfa:	00 00                	add    %al,(%bx,%si)
    8cfc:	eb 4d                	jmp    8d4b <console_task+0x2d0>
                            draw_str(frame->vram, frame->w, cursor_x, cursor_y, res[i], COL_FFFFFF);
    8cfe:	8b 45 ec             	mov    -0x14(%di),%ax
    8d01:	8b 74 85             	mov    -0x7b(%si),%si
    8d04:	a0 a1 70             	mov    0x70a1,%al
    8d07:	ec                   	in     (%dx),%al
    8d08:	00 00                	add    %al,(%bx,%si)
    8d0a:	0f b7 d8             	movzww %ax,%bx
    8d0d:	a1 6c ec             	mov    0xec6c,%ax
    8d10:	00 00                	add    %al,(%bx,%si)
    8d12:	0f b7 c8             	movzww %ax,%cx
    8d15:	a1 7c ec             	mov    0xec7c,%ax
    8d18:	00 00                	add    %al,(%bx,%si)
    8d1a:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    8d1e:	0f b7 d0             	movzww %ax,%dx
    8d21:	a1 7c ec             	mov    0xec7c,%ax
    8d24:	00 00                	add    %al,(%bx,%si)
    8d26:	8b 00                	mov    (%bx,%si),%ax
    8d28:	83 ec 08             	sub    $0x8,%sp
    8d2b:	6a 07                	push   $0x7
    8d2d:	56                   	push   %si
    8d2e:	53                   	push   %bx
    8d2f:	51                   	push   %cx
    8d30:	52                   	push   %dx
    8d31:	50                   	push   %ax
    8d32:	e8 e1 35             	call   c316 <draw_char+0xb1>
    8d35:	00 00                	add    %al,(%bx,%si)
    8d37:	83 c4 20             	add    $0x20,%sp
                            cursor_y+=16;
    8d3a:	a1 70 ec             	mov    0xec70,%ax
    8d3d:	00 00                	add    %al,(%bx,%si)
    8d3f:	83 c0 10             	add    $0x10,%ax
    8d42:	a3 70 ec             	mov    %ax,0xec70
    8d45:	00 00                	add    %al,(%bx,%si)
                        for (int i = 0; i < count; ++i) {
    8d47:	83 45 ec 01          	addw   $0x1,-0x14(%di)
    8d4b:	0f b6 45 e1          	movzbw -0x1f(%di),%ax
    8d4f:	39 45 ec             	cmp    %ax,-0x14(%di)
    8d52:	7c aa                	jl     8cfe <console_task+0x283>
                        }
                        frame_refresh_sub(frame->x + 8, frame->y + cursor_y - count * 16, 240, 16 * count);
    8d54:	0f b6 45 e1          	movzbw -0x1f(%di),%ax
    8d58:	c1 e0 04             	shl    $0x4,%ax
    8d5b:	0f b7 c0             	movzww %ax,%ax
    8d5e:	8b 15                	mov    (%di),%dx
    8d60:	7c ec                	jl     8d4e <console_task+0x2d3>
    8d62:	00 00                	add    %al,(%bx,%si)
    8d64:	8b 4a 08             	mov    0x8(%bp,%si),%cx
    8d67:	8b 15                	mov    (%di),%dx
    8d69:	70 ec                	jo     8d57 <console_task+0x2dc>
    8d6b:	00 00                	add    %al,(%bx,%si)
    8d6d:	01 d1                	add    %dx,%cx
    8d6f:	0f b6 55 e1          	movzbw -0x1f(%di),%dx
    8d73:	c1 e2 04             	shl    $0x4,%dx
    8d76:	29 d1                	sub    %dx,%cx
    8d78:	8b 15                	mov    (%di),%dx
    8d7a:	7c ec                	jl     8d68 <console_task+0x2ed>
    8d7c:	00 00                	add    %al,(%bx,%si)
    8d7e:	8b 52 04             	mov    0x4(%bp,%si),%dx
    8d81:	83 c2 08             	add    $0x8,%dx
    8d84:	50                   	push   %ax
    8d85:	68 f0 00             	push   $0xf0
    8d88:	00 00                	add    %al,(%bx,%si)
    8d8a:	51                   	push   %cx
    8d8b:	52                   	push   %dx
    8d8c:	e8 71 2c             	call   ba00 <draw_frame_sub+0xbb>
    8d8f:	00 00                	add    %al,(%bx,%si)
    8d91:	83 c4 10             	add    $0x10,%sp
    8d94:	e9 83 01             	jmp    8f1a <console_task+0x49f>
    8d97:	00 00                	add    %al,(%bx,%si)
                    } else{// 需要滚屏了
                        // 依旧需要把原来的移除
                        fill_rect(frame->vram, frame->w, cursor_x, cursor_y, 8, 16, COL_000000);
    8d99:	a1 70 ec             	mov    0xec70,%ax
    8d9c:	00 00                	add    %al,(%bx,%si)
    8d9e:	0f b7 d8             	movzww %ax,%bx
    8da1:	a1 6c ec             	mov    0xec6c,%ax
    8da4:	00 00                	add    %al,(%bx,%si)
    8da6:	0f b7 c8             	movzww %ax,%cx
    8da9:	a1 7c ec             	mov    0xec7c,%ax
    8dac:	00 00                	add    %al,(%bx,%si)
    8dae:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    8db2:	0f b7 d0             	movzww %ax,%dx
    8db5:	a1 7c ec             	mov    0xec7c,%ax
    8db8:	00 00                	add    %al,(%bx,%si)
    8dba:	8b 00                	mov    (%bx,%si),%ax
    8dbc:	83 ec 04             	sub    $0x4,%sp
    8dbf:	6a 00                	push   $0x0
    8dc1:	6a 10                	push   $0x10
    8dc3:	6a 08                	push   $0x8
    8dc5:	53                   	push   %bx
    8dc6:	51                   	push   %cx
    8dc7:	52                   	push   %dx
    8dc8:	50                   	push   %ax
    8dc9:	e8 86 32             	call   c052 <fill_alpha+0x34>
    8dcc:	00 00                	add    %al,(%bx,%si)
    8dce:	83 c4 20             	add    $0x20,%sp
                        for (int y = 28; y < 140-16*count; ++y) {
    8dd1:	c7 45 e8 1c 00       	movw   $0x1c,-0x18(%di)
    8dd6:	00 00                	add    %al,(%bx,%si)
    8dd8:	eb 48                	jmp    8e22 <console_task+0x3a7>
                            mem_copy(frame->vram + y * 256 + 8, frame->vram + (y + 16 * count + 16) * 256 + 8, 240);
    8dda:	a1 7c ec             	mov    0xec7c,%ax
    8ddd:	00 00                	add    %al,(%bx,%si)
    8ddf:	8b 00                	mov    (%bx,%si),%ax
    8de1:	0f b6 55 e1          	movzbw -0x1f(%di),%dx
    8de5:	89 d1                	mov    %dx,%cx
    8de7:	c1 e1 04             	shl    $0x4,%cx
    8dea:	8b 55 e8             	mov    -0x18(%di),%dx
    8ded:	01 ca                	add    %cx,%dx
    8def:	83 c2 10             	add    $0x10,%dx
    8df2:	c1 e2 08             	shl    $0x8,%dx
    8df5:	83 c2 08             	add    $0x8,%dx
    8df8:	01 c2                	add    %ax,%dx
    8dfa:	a1 7c ec             	mov    0xec7c,%ax
    8dfd:	00 00                	add    %al,(%bx,%si)
    8dff:	8b 00                	mov    (%bx,%si),%ax
    8e01:	8b 4d e8             	mov    -0x18(%di),%cx
    8e04:	c1 e1 08             	shl    $0x8,%cx
    8e07:	83 c1 08             	add    $0x8,%cx
    8e0a:	01 c8                	add    %cx,%ax
    8e0c:	83 ec 04             	sub    $0x4,%sp
    8e0f:	68 f0 00             	push   $0xf0
    8e12:	00 00                	add    %al,(%bx,%si)
    8e14:	52                   	push   %dx
    8e15:	50                   	push   %ax
    8e16:	e8 49 4a             	call   d862 <mem_eq+0x60>
    8e19:	00 00                	add    %al,(%bx,%si)
    8e1b:	83 c4 10             	add    $0x10,%sp
                        for (int y = 28; y < 140-16*count; ++y) {
    8e1e:	83 45 e8 01          	addw   $0x1,-0x18(%di)
    8e22:	0f b6 45 e1          	movzbw -0x1f(%di),%ax
    8e26:	c1 e0 04             	shl    $0x4,%ax
    8e29:	89 c2                	mov    %ax,%dx
    8e2b:	b8 8c 00             	mov    $0x8c,%ax
    8e2e:	00 00                	add    %al,(%bx,%si)
    8e30:	29 d0                	sub    %dx,%ax
    8e32:	39 45 e8             	cmp    %ax,-0x18(%di)
    8e35:	7c a3                	jl     8dda <console_task+0x35f>
                        }
                        cursor_x=8;
    8e37:	c7 05 6c ec          	movw   $0xec6c,(%di)
    8e3b:	00 00                	add    %al,(%bx,%si)
    8e3d:	08 00                	or     %al,(%bx,%si)
    8e3f:	00 00                	add    %al,(%bx,%si)
                        cursor_y=140;
    8e41:	c7 05 70 ec          	movw   $0xec70,(%di)
    8e45:	00 00                	add    %al,(%bx,%si)
    8e47:	8c 00                	mov    %es,(%bx,%si)
    8e49:	00 00                	add    %al,(%bx,%si)
                        fill_rect(frame->vram, 256, 8, 140 - count * 16, 240, 16 + count * 16, COL_000000);
    8e4b:	0f b6 45 e1          	movzbw -0x1f(%di),%ax
    8e4f:	83 c0 01             	add    $0x1,%ax
    8e52:	c1 e0 04             	shl    $0x4,%ax
    8e55:	0f b7 c8             	movzww %ax,%cx
    8e58:	0f b6 45 e1          	movzbw -0x1f(%di),%ax
    8e5c:	c1 e0 04             	shl    $0x4,%ax
    8e5f:	89 c2                	mov    %ax,%dx
    8e61:	b8 8c 00             	mov    $0x8c,%ax
    8e64:	00 00                	add    %al,(%bx,%si)
    8e66:	29 d0                	sub    %dx,%ax
    8e68:	0f b7 d0             	movzww %ax,%dx
    8e6b:	a1 7c ec             	mov    0xec7c,%ax
    8e6e:	00 00                	add    %al,(%bx,%si)
    8e70:	8b 00                	mov    (%bx,%si),%ax
    8e72:	83 ec 04             	sub    $0x4,%sp
    8e75:	6a 00                	push   $0x0
    8e77:	51                   	push   %cx
    8e78:	68 f0 00             	push   $0xf0
    8e7b:	00 00                	add    %al,(%bx,%si)
    8e7d:	52                   	push   %dx
    8e7e:	6a 08                	push   $0x8
    8e80:	68 00 01             	push   $0x100
    8e83:	00 00                	add    %al,(%bx,%si)
    8e85:	50                   	push   %ax
    8e86:	e8 c9 31             	call   c052 <fill_alpha+0x34>
    8e89:	00 00                	add    %al,(%bx,%si)
    8e8b:	83 c4 20             	add    $0x20,%sp
                        for (int i = 0; i < count; ++i) {
    8e8e:	c7 45 e4 00 00       	movw   $0x0,-0x1c(%di)
    8e93:	00 00                	add    %al,(%bx,%si)
    8e95:	eb 52                	jmp    8ee9 <console_task+0x46e>
                            draw_str(frame->vram, frame->w, cursor_x, cursor_y - (count - i) * 16,
    8e97:	8b 45 e4             	mov    -0x1c(%di),%ax
    8e9a:	8b 74 85             	mov    -0x7b(%si),%si
    8e9d:	a0 a1 70             	mov    0x70a1,%al
    8ea0:	ec                   	in     (%dx),%al
    8ea1:	00 00                	add    %al,(%bx,%si)
    8ea3:	89 c1                	mov    %ax,%cx
    8ea5:	0f b6 45 e1          	movzbw -0x1f(%di),%ax
    8ea9:	2b 45 e4             	sub    -0x1c(%di),%ax
    8eac:	c1 e0 04             	shl    $0x4,%ax
    8eaf:	89 c2                	mov    %ax,%dx
    8eb1:	89 c8                	mov    %cx,%ax
    8eb3:	29 d0                	sub    %dx,%ax
    8eb5:	0f b7 d8             	movzww %ax,%bx
    8eb8:	a1 6c ec             	mov    0xec6c,%ax
    8ebb:	00 00                	add    %al,(%bx,%si)
    8ebd:	0f b7 c8             	movzww %ax,%cx
    8ec0:	a1 7c ec             	mov    0xec7c,%ax
    8ec3:	00 00                	add    %al,(%bx,%si)
    8ec5:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    8ec9:	0f b7 d0             	movzww %ax,%dx
    8ecc:	a1 7c ec             	mov    0xec7c,%ax
    8ecf:	00 00                	add    %al,(%bx,%si)
    8ed1:	8b 00                	mov    (%bx,%si),%ax
    8ed3:	83 ec 08             	sub    $0x8,%sp
    8ed6:	6a 07                	push   $0x7
    8ed8:	56                   	push   %si
    8ed9:	53                   	push   %bx
    8eda:	51                   	push   %cx
    8edb:	52                   	push   %dx
    8edc:	50                   	push   %ax
    8edd:	e8 36 34             	call   c316 <draw_char+0xb1>
    8ee0:	00 00                	add    %al,(%bx,%si)
    8ee2:	83 c4 20             	add    $0x20,%sp
                        for (int i = 0; i < count; ++i) {
    8ee5:	83 45 e4 01          	addw   $0x1,-0x1c(%di)
    8ee9:	0f b6 45 e1          	movzbw -0x1f(%di),%ax
    8eed:	39 45 e4             	cmp    %ax,-0x1c(%di)
    8ef0:	7c a5                	jl     8e97 <console_task+0x41c>
                                     res[i], COL_FFFFFF);
                        }
                        frame_refresh_sub(frame->x + 8, frame->y + 28, 240, 128);
    8ef2:	a1 7c ec             	mov    0xec7c,%ax
    8ef5:	00 00                	add    %al,(%bx,%si)
    8ef7:	8b 40 08             	mov    0x8(%bx,%si),%ax
    8efa:	8d 50 1c             	lea    0x1c(%bx,%si),%dx
    8efd:	a1 7c ec             	mov    0xec7c,%ax
    8f00:	00 00                	add    %al,(%bx,%si)
    8f02:	8b 40 04             	mov    0x4(%bx,%si),%ax
    8f05:	83 c0 08             	add    $0x8,%ax
    8f08:	68 80 00             	push   $0x80
    8f0b:	00 00                	add    %al,(%bx,%si)
    8f0d:	68 f0 00             	push   $0xf0
    8f10:	00 00                	add    %al,(%bx,%si)
    8f12:	52                   	push   %dx
    8f13:	50                   	push   %ax
    8f14:	e8 e9 2a             	call   ba00 <draw_frame_sub+0xbb>
    8f17:	00 00                	add    %al,(%bx,%si)
    8f19:	83 c4 10             	add    $0x10,%sp
                    }
                }
                // 输出默认提示符
                add_char('>');
    8f1c:	83 ec 0c             	sub    $0xc,%sp
    8f1f:	6a 3e                	push   $0x3e
    8f21:	e8 b2 f4             	call   83d6 <cursor_blink+0xb1>
    8f24:	ff                   	(bad)
    8f25:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
                mem_set(cmd_line,0, sizeof(cmd_line));
    8f29:	83 ec 04             	sub    $0x4,%sp
    8f2c:	6a 20                	push   $0x20
    8f2e:	6a 00                	push   $0x0
    8f30:	8d 45 c1             	lea    -0x3f(%di),%ax
    8f33:	50                   	push   %ax
    8f34:	e8 8f 48             	call   d7c6 <fmt+0x140>
    8f37:	00 00                	add    %al,(%bx,%si)
    8f39:	83 c4 10             	add    $0x10,%sp
                cmd_index=0;
    8f3c:	c6 45 f7 00          	movb   $0x0,-0x9(%di)
    8f40:	e9 ca fb             	jmp    8b0d <console_task+0x92>
    8f43:	ff                   	(bad)
    8f44:	ff 80 7d e3          	incw   -0x1c83(%bx,%si)
            } else if(data<58){// 普通有按钮映射的按键
    8f48:	39 0f                	cmp    %cx,(%bx)
    8f4a:	87 c0                	xchg   %ax,%ax
    8f4c:	fb                   	sti
    8f4d:	ff                   	(bad)
    8f4e:	ff a1 78 ec          	jmp    *-0x1388(%bx,%di)
                char ch =code2char[shift_press][data];
    8f52:	00 00                	add    %al,(%bx,%si)
    8f54:	8b 14                	mov    (%si),%dx
    8f56:	85 00                	test   %ax,(%bx,%si)
    8f58:	eb 00                	jmp    8f5a <console_task+0x4df>
    8f5a:	00 0f                	add    %cl,(%bx)
    8f5c:	b6 45                	mov    $0x45,%dh
    8f5e:	e3 01                	jcxz   8f61 <console_task+0x4e6>
    8f60:	d0 0f                	rorb   (%bx)
    8f62:	b6 00                	mov    $0x0,%dh
    8f64:	88 45 e2             	mov    %al,-0x1e(%di)
                cmd_line[cmd_index++]=ch;
    8f67:	0f b6 45 f7          	movzbw -0x9(%di),%ax
    8f6b:	8d 50 01             	lea    0x1(%bx,%si),%dx
    8f6e:	88 55 f7             	mov    %dl,-0x9(%di)
    8f71:	0f b6 c0             	movzbw %al,%ax
    8f74:	0f b6 55 e2          	movzbw -0x1e(%di),%dx
    8f78:	88 54 05             	mov    %dl,0x5(%si)
    8f7b:	c1 0f be             	rorw   $0xbe,(%bx)
                add_char(ch);
    8f7e:	45                   	inc    %bp
    8f7f:	e2 83                	loop   8f04 <console_task+0x489>
    8f81:	ec                   	in     (%dx),%al
    8f82:	0c 50                	or     $0x50,%al
    8f84:	e8 4f f4             	call   83d6 <cursor_blink+0xb1>
    8f87:	ff                   	(bad)
    8f88:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    8f8c:	e9 7e fb             	jmp    8b0d <console_task+0x92>
    8f8f:	ff                   	(bad)
    8f90:	ff                   	(bad)
            }
        } else{
            sti();
    8f91:	e8 5f f3             	call   82f3 <cli+0x5>
    8f94:	ff                   	(bad)
    8f95:	ff                   	(bad)
            hlt();
    8f96:	e8 61 f3             	call   82fa <sti+0x5>
    8f99:	ff                   	(bad)
    8f9a:	ff                   	(bad)
        cli();
    8f9b:	e9 6f fb             	jmp    8b0d <console_task+0x92>
    8f9e:	ff                   	(bad)
    8f9f:	ff                   	.byte 0xff

00008fa0 <console_init>:
        }
    }
}

void console_init() {
    8fa0:	55                   	push   %bp
    8fa1:	89 e5                	mov    %sp,%bp
    8fa3:	53                   	push   %bx
    8fa4:	83 ec 04             	sub    $0x4,%sp
    draw_window(frame->vram, frame->w, frame->h, "CONSOLE");
    8fa7:	a1 7c ec             	mov    0xec7c,%ax
    8faa:	00 00                	add    %al,(%bx,%si)
    8fac:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    8fb0:	0f b7 c8             	movzww %ax,%cx
    8fb3:	a1 7c ec             	mov    0xec7c,%ax
    8fb6:	00 00                	add    %al,(%bx,%si)
    8fb8:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    8fbc:	0f b7 d0             	movzww %ax,%dx
    8fbf:	a1 7c ec             	mov    0xec7c,%ax
    8fc2:	00 00                	add    %al,(%bx,%si)
    8fc4:	8b 00                	mov    (%bx,%si),%ax
    8fc6:	68 37 da             	push   $0xda37
    8fc9:	00 00                	add    %al,(%bx,%si)
    8fcb:	51                   	push   %cx
    8fcc:	52                   	push   %dx
    8fcd:	50                   	push   %ax
    8fce:	e8 47 1f             	call   af18 <cursor_init+0x90>
    8fd1:	00 00                	add    %al,(%bx,%si)
    8fd3:	83 c4 10             	add    $0x10,%sp
    draw_textbox(frame->vram, frame->w, 8, 28, 248, 156, COL_000000);
    8fd6:	a1 7c ec             	mov    0xec7c,%ax
    8fd9:	00 00                	add    %al,(%bx,%si)
    8fdb:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    8fdf:	0f b7 d0             	movzww %ax,%dx
    8fe2:	a1 7c ec             	mov    0xec7c,%ax
    8fe5:	00 00                	add    %al,(%bx,%si)
    8fe7:	8b 00                	mov    (%bx,%si),%ax
    8fe9:	83 ec 04             	sub    $0x4,%sp
    8fec:	6a 00                	push   $0x0
    8fee:	68 9c 00             	push   $0x9c
    8ff1:	00 00                	add    %al,(%bx,%si)
    8ff3:	68 f8 00             	push   $0xf8
    8ff6:	00 00                	add    %al,(%bx,%si)
    8ff8:	6a 1c                	push   $0x1c
    8ffa:	6a 08                	push   $0x8
    8ffc:	52                   	push   %dx
    8ffd:	50                   	push   %ax
    8ffe:	e8 ab 21             	call   b1ac <window_init+0x36>
    9001:	00 00                	add    %al,(%bx,%si)
    9003:	83 c4 20             	add    $0x20,%sp
    frame_refresh_sub(frame->x, frame->y, frame->w, frame->h);
    9006:	a1 7c ec             	mov    0xec7c,%ax
    9009:	00 00                	add    %al,(%bx,%si)
    900b:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    900f:	0f b7 d8             	movzww %ax,%bx
    9012:	a1 7c ec             	mov    0xec7c,%ax
    9015:	00 00                	add    %al,(%bx,%si)
    9017:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    901b:	0f b7 c8             	movzww %ax,%cx
    901e:	a1 7c ec             	mov    0xec7c,%ax
    9021:	00 00                	add    %al,(%bx,%si)
    9023:	8b 50 08             	mov    0x8(%bx,%si),%dx
    9026:	a1 7c ec             	mov    0xec7c,%ax
    9029:	00 00                	add    %al,(%bx,%si)
    902b:	8b 40 04             	mov    0x4(%bx,%si),%ax
    902e:	53                   	push   %bx
    902f:	51                   	push   %cx
    9030:	52                   	push   %dx
    9031:	50                   	push   %ax
    9032:	e8 cb 29             	call   ba00 <draw_frame_sub+0xbb>
    9035:	00 00                	add    %al,(%bx,%si)
    9037:	83 c4 10             	add    $0x10,%sp
}
    903a:	90                   	nop
    903b:	8b 5d fc             	mov    -0x4(%di),%bx
    903e:	c9                   	leave
    903f:	c3                   	ret

00009040 <console_click>:

bool_t console_click(int x,int y){// 暂时只判断关闭事件
    9040:	55                   	push   %bp
    9041:	89 e5                	mov    %sp,%bp
    9043:	83 ec 08             	sub    $0x8,%sp
    if(window_close(frame, x, y)){
    9046:	a1 7c ec             	mov    0xec7c,%ax
    9049:	00 00                	add    %al,(%bx,%si)
    904b:	83 ec 04             	sub    $0x4,%sp
    904e:	ff 75 0c             	push   0xc(%di)
    9051:	ff 75 08             	push   0x8(%di)
    9054:	50                   	push   %ax
    9055:	e8 b2 20             	call   b10a <draw_window+0x1f0>
    9058:	00 00                	add    %al,(%bx,%si)
    905a:	83 c4 10             	add    $0x10,%sp
    905d:	85 c0                	test   %ax,%ax
    905f:	74 0c                	je     906d <console_click+0x2d>
        console_exit();
    9061:	e8 14 f5             	call   8578 <trim_param+0x24>
    9064:	ff                   	(bad)
    9065:	ff                   	(bad)
        return TRUE;
    9066:	b8 01 00             	mov    $0x1,%ax
    9069:	00 00                	add    %al,(%bx,%si)
    906b:	eb 05                	jmp    9072 <console_click+0x32>
    }
    return FALSE;
    906d:	b8 00 00             	mov    $0x0,%ax
    9070:	00 00                	add    %al,(%bx,%si)
}
    9072:	c9                   	leave
    9073:	c3                   	ret

00009074 <init_console>:

void init_console(){
    9074:	55                   	push   %bp
    9075:	89 e5                	mov    %sp,%bp
    9077:	83 ec 08             	sub    $0x8,%sp
    if(frame&&frame->used){// 防止多次开启
    907a:	a1 7c ec             	mov    0xec7c,%ax
    907d:	00 00                	add    %al,(%bx,%si)
    907f:	85 c0                	test   %ax,%ax
    9081:	74 0c                	je     908f <init_console+0x1b>
    9083:	a1 7c ec             	mov    0xec7c,%ax
    9086:	00 00                	add    %al,(%bx,%si)
    9088:	8b 40 14             	mov    0x14(%bx,%si),%ax
    908b:	85 c0                	test   %ax,%ax
    908d:	75 59                	jne    90e8 <init_console+0x74>
        return;
    }
    frame= frame_alloc((SCREEN_W - 256) / 2, (SCREEN_H - 165) / 2, 256, 165);
    908f:	68 a5 00             	push   $0xa5
    9092:	00 00                	add    %al,(%bx,%si)
    9094:	68 00 01             	push   $0x100
    9097:	00 00                	add    %al,(%bx,%si)
    9099:	6a 11                	push   $0x11
    909b:	6a 20                	push   $0x20
    909d:	e8 55 25             	call   b5f5 <frame_free+0x4c>
    90a0:	00 00                	add    %al,(%bx,%si)
    90a2:	83 c4 10             	add    $0x10,%sp
    90a5:	a3 7c ec             	mov    %ax,0xec7c
    90a8:	00 00                	add    %al,(%bx,%si)
    frame->flag|=FRAME_CLICK;
    90aa:	a1 7c ec             	mov    0xec7c,%ax
    90ad:	00 00                	add    %al,(%bx,%si)
    90af:	0f b6 50 12          	movzbw 0x12(%bx,%si),%dx
    90b3:	a1 7c ec             	mov    0xec7c,%ax
    90b6:	00 00                	add    %al,(%bx,%si)
    90b8:	83 ca 04             	or     $0x4,%dx
    90bb:	88 50 12             	mov    %dl,0x12(%bx,%si)
    frame->click=console_click;
    90be:	a1 7c ec             	mov    0xec7c,%ax
    90c1:	00 00                	add    %al,(%bx,%si)
    90c3:	c7 40 18 40 90       	movw   $0x9040,0x18(%bx,%si)
    90c8:	00 00                	add    %al,(%bx,%si)
    console_init();
    90ca:	e8 d1 fe             	call   8f9e <console_task+0x523>
    90cd:	ff                   	(bad)
    90ce:	ff 83 ec 08          	incw   0x8ec(%bp,%di)
    task=create_task(console_task,3);
    90d2:	6a 03                	push   $0x3
    90d4:	68 7b 8a             	push   $0x8a7b
    90d7:	00 00                	add    %al,(%bx,%si)
    90d9:	e8 6c 41             	call   d248 <task_exit+0x32>
    90dc:	00 00                	add    %al,(%bx,%si)
    90de:	83 c4 10             	add    $0x10,%sp
    90e1:	a3 80 ec             	mov    %ax,0xec80
    90e4:	00 00                	add    %al,(%bx,%si)
    90e6:	eb 01                	jmp    90e9 <init_console+0x75>
        return;
    90e8:	90                   	nop
    90e9:	c9                   	leave
    90ea:	c3                   	ret

000090eb <image_click>:
#include "mem.h"
#include "graphic.h"

static frame_t *frame;

bool_t image_click(int x,int y){
    90eb:	55                   	push   %bp
    90ec:	89 e5                	mov    %sp,%bp
    90ee:	53                   	push   %bx
    90ef:	83 ec 04             	sub    $0x4,%sp
    if(window_close(frame, x, y)){
    90f2:	a1 84 ec             	mov    0xec84,%ax
    90f5:	00 00                	add    %al,(%bx,%si)
    90f7:	83 ec 04             	sub    $0x4,%sp
    90fa:	ff 75 0c             	push   0xc(%di)
    90fd:	ff 75 08             	push   0x8(%di)
    9100:	50                   	push   %ax
    9101:	e8 06 20             	call   b10a <draw_window+0x1f0>
    9104:	00 00                	add    %al,(%bx,%si)
    9106:	83 c4 10             	add    $0x10,%sp
    9109:	85 c0                	test   %ax,%ax
    910b:	74 4c                	je     9159 <image_click+0x6e>
        frame_free(frame);
    910d:	a1 84 ec             	mov    0xec84,%ax
    9110:	00 00                	add    %al,(%bx,%si)
    9112:	83 ec 0c             	sub    $0xc,%sp
    9115:	50                   	push   %ax
    9116:	e8 8e 24             	call   b5a7 <init_frame+0x184>
    9119:	00 00                	add    %al,(%bx,%si)
    911b:	83 c4 10             	add    $0x10,%sp
        frame_refresh_sub(frame->x, frame->y, frame->w, frame->h);
    911e:	a1 84 ec             	mov    0xec84,%ax
    9121:	00 00                	add    %al,(%bx,%si)
    9123:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    9127:	0f b7 d8             	movzww %ax,%bx
    912a:	a1 84 ec             	mov    0xec84,%ax
    912d:	00 00                	add    %al,(%bx,%si)
    912f:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    9133:	0f b7 c8             	movzww %ax,%cx
    9136:	a1 84 ec             	mov    0xec84,%ax
    9139:	00 00                	add    %al,(%bx,%si)
    913b:	8b 50 08             	mov    0x8(%bx,%si),%dx
    913e:	a1 84 ec             	mov    0xec84,%ax
    9141:	00 00                	add    %al,(%bx,%si)
    9143:	8b 40 04             	mov    0x4(%bx,%si),%ax
    9146:	53                   	push   %bx
    9147:	51                   	push   %cx
    9148:	52                   	push   %dx
    9149:	50                   	push   %ax
    914a:	e8 b3 28             	call   ba00 <draw_frame_sub+0xbb>
    914d:	00 00                	add    %al,(%bx,%si)
    914f:	83 c4 10             	add    $0x10,%sp
        return TRUE;
    9152:	b8 01 00             	mov    $0x1,%ax
    9155:	00 00                	add    %al,(%bx,%si)
    9157:	eb 05                	jmp    915e <image_click+0x73>
    }
    return FALSE;
    9159:	b8 00 00             	mov    $0x0,%ax
    915c:	00 00                	add    %al,(%bx,%si)
}
    915e:	8b 5d fc             	mov    -0x4(%di),%bx
    9161:	c9                   	leave
    9162:	c3                   	ret

00009163 <image_init>:

void image_init(char *path) {
    9163:	55                   	push   %bp
    9164:	89 e5                	mov    %sp,%bp
    9166:	53                   	push   %bx
    9167:	83 ec 14             	sub    $0x14,%sp
    draw_window(frame->vram, frame->w, frame->h, "IMG");
    916a:	a1 84 ec             	mov    0xec84,%ax
    916d:	00 00                	add    %al,(%bx,%si)
    916f:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    9173:	0f b7 c8             	movzww %ax,%cx
    9176:	a1 84 ec             	mov    0xec84,%ax
    9179:	00 00                	add    %al,(%bx,%si)
    917b:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    917f:	0f b7 d0             	movzww %ax,%dx
    9182:	a1 84 ec             	mov    0xec84,%ax
    9185:	00 00                	add    %al,(%bx,%si)
    9187:	8b 00                	mov    (%bx,%si),%ax
    9189:	68 3f da             	push   $0xda3f
    918c:	00 00                	add    %al,(%bx,%si)
    918e:	51                   	push   %cx
    918f:	52                   	push   %dx
    9190:	50                   	push   %ax
    9191:	e8 84 1d             	call   af18 <cursor_init+0x90>
    9194:	00 00                	add    %al,(%bx,%si)
    9196:	83 c4 10             	add    $0x10,%sp
    file_t *file=file_open(path,FALSE);
    9199:	83 ec 08             	sub    $0x8,%sp
    919c:	6a 00                	push   $0x0
    919e:	ff 75 08             	push   0x8(%di)
    91a1:	e8 32 12             	call   a3d6 <find_empty_sel+0x96>
    91a4:	00 00                	add    %al,(%bx,%si)
    91a6:	83 c4 10             	add    $0x10,%sp
    91a9:	89 45 f4             	mov    %ax,-0xc(%di)
    if(file){
    91ac:	83 7d f4 00          	cmpw   $0x0,-0xc(%di)
    91b0:	74 7f                	je     9231 <image_init+0xce>
        // 图像大小暂时固定
        uint8_t *buff= mem_alloc(32*32);
    91b2:	83 ec 0c             	sub    $0xc,%sp
    91b5:	68 00 04             	push   $0x400
    91b8:	00 00                	add    %al,(%bx,%si)
    91ba:	e8 25 3c             	call   cde2 <mem_total+0x53>
    91bd:	00 00                	add    %al,(%bx,%si)
    91bf:	83 c4 10             	add    $0x10,%sp
    91c2:	89 45 f0             	mov    %ax,-0x10(%di)
        file_read(file,32*32,buff);
    91c5:	83 ec 04             	sub    $0x4,%sp
    91c8:	ff 75 f0             	push   -0x10(%di)
    91cb:	68 00 04             	push   $0x400
    91ce:	00 00                	add    %al,(%bx,%si)
    91d0:	ff 75 f4             	push   -0xc(%di)
    91d3:	e8 c9 13             	call   a59f <make_sure_buff+0x72>
    91d6:	00 00                	add    %al,(%bx,%si)
    91d8:	83 c4 10             	add    $0x10,%sp
        file_close(file);
    91db:	83 ec 0c             	sub    $0xc,%sp
    91de:	ff 75 f4             	push   -0xc(%di)
    91e1:	e8 4d 18             	call   aa31 <file_flush+0x3b>
    91e4:	00 00                	add    %al,(%bx,%si)
    91e6:	83 c4 10             	add    $0x10,%sp
        draw_block(frame->vram,frame->w,frame->h,8,28,32,32,buff);
    91e9:	a1 84 ec             	mov    0xec84,%ax
    91ec:	00 00                	add    %al,(%bx,%si)
    91ee:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    91f2:	0f b7 c8             	movzww %ax,%cx
    91f5:	a1 84 ec             	mov    0xec84,%ax
    91f8:	00 00                	add    %al,(%bx,%si)
    91fa:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    91fe:	0f b7 d0             	movzww %ax,%dx
    9201:	a1 84 ec             	mov    0xec84,%ax
    9204:	00 00                	add    %al,(%bx,%si)
    9206:	8b 00                	mov    (%bx,%si),%ax
    9208:	ff 75 f0             	push   -0x10(%di)
    920b:	6a 20                	push   $0x20
    920d:	6a 20                	push   $0x20
    920f:	6a 1c                	push   $0x1c
    9211:	6a 08                	push   $0x8
    9213:	51                   	push   %cx
    9214:	52                   	push   %dx
    9215:	50                   	push   %ax
    9216:	e8 45 2a             	call   bc5e <min+0x13>
    9219:	00 00                	add    %al,(%bx,%si)
    921b:	83 c4 20             	add    $0x20,%sp
        mem_free(buff,32*32);
    921e:	83 ec 08             	sub    $0x8,%sp
    9221:	68 00 04             	push   $0x400
    9224:	00 00                	add    %al,(%bx,%si)
    9226:	ff 75 f0             	push   -0x10(%di)
    9229:	e8 b3 3c             	call   cedf <mem_alloc+0xfb>
    922c:	00 00                	add    %al,(%bx,%si)
    922e:	83 c4 10             	add    $0x10,%sp
    }
    frame_refresh_sub(frame->x,frame->y,frame->w,frame->h);
    9231:	a1 84 ec             	mov    0xec84,%ax
    9234:	00 00                	add    %al,(%bx,%si)
    9236:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    923a:	0f b7 d8             	movzww %ax,%bx
    923d:	a1 84 ec             	mov    0xec84,%ax
    9240:	00 00                	add    %al,(%bx,%si)
    9242:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    9246:	0f b7 c8             	movzww %ax,%cx
    9249:	a1 84 ec             	mov    0xec84,%ax
    924c:	00 00                	add    %al,(%bx,%si)
    924e:	8b 50 08             	mov    0x8(%bx,%si),%dx
    9251:	a1 84 ec             	mov    0xec84,%ax
    9254:	00 00                	add    %al,(%bx,%si)
    9256:	8b 40 04             	mov    0x4(%bx,%si),%ax
    9259:	53                   	push   %bx
    925a:	51                   	push   %cx
    925b:	52                   	push   %dx
    925c:	50                   	push   %ax
    925d:	e8 a0 27             	call   ba00 <draw_frame_sub+0xbb>
    9260:	00 00                	add    %al,(%bx,%si)
    9262:	83 c4 10             	add    $0x10,%sp
}
    9265:	90                   	nop
    9266:	8b 5d fc             	mov    -0x4(%di),%bx
    9269:	c9                   	leave
    926a:	c3                   	ret

0000926b <init_image>:

void init_image(char *path){
    926b:	55                   	push   %bp
    926c:	89 e5                	mov    %sp,%bp
    926e:	83 ec 08             	sub    $0x8,%sp
    if(frame&&frame->used){// 防止多次开启
    9271:	a1 84 ec             	mov    0xec84,%ax
    9274:	00 00                	add    %al,(%bx,%si)
    9276:	85 c0                	test   %ax,%ax
    9278:	74 0c                	je     9286 <init_image+0x1b>
    927a:	a1 84 ec             	mov    0xec84,%ax
    927d:	00 00                	add    %al,(%bx,%si)
    927f:	8b 40 14             	mov    0x14(%bx,%si),%ax
    9282:	85 c0                	test   %ax,%ax
    9284:	75 45                	jne    92cb <init_image+0x60>
        return;
    }
    // 暂时文件里面没有记录图片的长宽信息，先直接写死
    frame= frame_alloc((SCREEN_W - 256) / 2, (SCREEN_H - 165) / 2, 32+8*2, 32+9+28);
    9286:	6a 45                	push   $0x45
    9288:	6a 30                	push   $0x30
    928a:	6a 11                	push   $0x11
    928c:	6a 20                	push   $0x20
    928e:	e8 64 23             	call   b5f5 <frame_free+0x4c>
    9291:	00 00                	add    %al,(%bx,%si)
    9293:	83 c4 10             	add    $0x10,%sp
    9296:	a3 84 ec             	mov    %ax,0xec84
    9299:	00 00                	add    %al,(%bx,%si)
    frame->flag|=FRAME_CLICK;
    929b:	a1 84 ec             	mov    0xec84,%ax
    929e:	00 00                	add    %al,(%bx,%si)
    92a0:	0f b6 50 12          	movzbw 0x12(%bx,%si),%dx
    92a4:	a1 84 ec             	mov    0xec84,%ax
    92a7:	00 00                	add    %al,(%bx,%si)
    92a9:	83 ca 04             	or     $0x4,%dx
    92ac:	88 50 12             	mov    %dl,0x12(%bx,%si)
    frame->click=image_click;
    92af:	a1 84 ec             	mov    0xec84,%ax
    92b2:	00 00                	add    %al,(%bx,%si)
    92b4:	c7 40 18 eb 90       	movw   $0x90eb,0x18(%bx,%si)
    92b9:	00 00                	add    %al,(%bx,%si)
    image_init(path);
    92bb:	83 ec 0c             	sub    $0xc,%sp
    92be:	ff 75 08             	push   0x8(%di)
    92c1:	e8 9d fe             	call   9161 <image_click+0x76>
    92c4:	ff                   	(bad)
    92c5:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    92c9:	eb 01                	jmp    92cc <init_image+0x61>
        return;
    92cb:	90                   	nop
    92cc:	c9                   	leave
    92cd:	c3                   	ret

000092ce <line_click>:
#include "comm/config.h"
#include "graphic.h"

static frame_t *frame;

bool_t line_click(int x,int y){
    92ce:	55                   	push   %bp
    92cf:	89 e5                	mov    %sp,%bp
    92d1:	53                   	push   %bx
    92d2:	83 ec 04             	sub    $0x4,%sp
    if(window_close(frame, x, y)){
    92d5:	a1 88 ec             	mov    0xec88,%ax
    92d8:	00 00                	add    %al,(%bx,%si)
    92da:	83 ec 04             	sub    $0x4,%sp
    92dd:	ff 75 0c             	push   0xc(%di)
    92e0:	ff 75 08             	push   0x8(%di)
    92e3:	50                   	push   %ax
    92e4:	e8 23 1e             	call   b10a <draw_window+0x1f0>
    92e7:	00 00                	add    %al,(%bx,%si)
    92e9:	83 c4 10             	add    $0x10,%sp
    92ec:	85 c0                	test   %ax,%ax
    92ee:	74 4c                	je     933c <line_click+0x6e>
        frame_free(frame);
    92f0:	a1 88 ec             	mov    0xec88,%ax
    92f3:	00 00                	add    %al,(%bx,%si)
    92f5:	83 ec 0c             	sub    $0xc,%sp
    92f8:	50                   	push   %ax
    92f9:	e8 ab 22             	call   b5a7 <init_frame+0x184>
    92fc:	00 00                	add    %al,(%bx,%si)
    92fe:	83 c4 10             	add    $0x10,%sp
        frame_refresh_sub(frame->x, frame->y, frame->w, frame->h);
    9301:	a1 88 ec             	mov    0xec88,%ax
    9304:	00 00                	add    %al,(%bx,%si)
    9306:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    930a:	0f b7 d8             	movzww %ax,%bx
    930d:	a1 88 ec             	mov    0xec88,%ax
    9310:	00 00                	add    %al,(%bx,%si)
    9312:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    9316:	0f b7 c8             	movzww %ax,%cx
    9319:	a1 88 ec             	mov    0xec88,%ax
    931c:	00 00                	add    %al,(%bx,%si)
    931e:	8b 50 08             	mov    0x8(%bx,%si),%dx
    9321:	a1 88 ec             	mov    0xec88,%ax
    9324:	00 00                	add    %al,(%bx,%si)
    9326:	8b 40 04             	mov    0x4(%bx,%si),%ax
    9329:	53                   	push   %bx
    932a:	51                   	push   %cx
    932b:	52                   	push   %dx
    932c:	50                   	push   %ax
    932d:	e8 d0 26             	call   ba00 <draw_frame_sub+0xbb>
    9330:	00 00                	add    %al,(%bx,%si)
    9332:	83 c4 10             	add    $0x10,%sp
        return TRUE;
    9335:	b8 01 00             	mov    $0x1,%ax
    9338:	00 00                	add    %al,(%bx,%si)
    933a:	eb 05                	jmp    9341 <line_click+0x73>
    }
    return FALSE;
    933c:	b8 00 00             	mov    $0x0,%ax
    933f:	00 00                	add    %al,(%bx,%si)
}
    9341:	8b 5d fc             	mov    -0x4(%di),%bx
    9344:	c9                   	leave
    9345:	c3                   	ret

00009346 <line_init>:

void line_init() {
    9346:	55                   	push   %bp
    9347:	89 e5                	mov    %sp,%bp
    9349:	53                   	push   %bx
    934a:	83 ec 04             	sub    $0x4,%sp
    draw_window(frame->vram, frame->w, frame->h, "LINE");
    934d:	a1 88 ec             	mov    0xec88,%ax
    9350:	00 00                	add    %al,(%bx,%si)
    9352:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    9356:	0f b7 c8             	movzww %ax,%cx
    9359:	a1 88 ec             	mov    0xec88,%ax
    935c:	00 00                	add    %al,(%bx,%si)
    935e:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    9362:	0f b7 d0             	movzww %ax,%dx
    9365:	a1 88 ec             	mov    0xec88,%ax
    9368:	00 00                	add    %al,(%bx,%si)
    936a:	8b 00                	mov    (%bx,%si),%ax
    936c:	68 43 da             	push   $0xda43
    936f:	00 00                	add    %al,(%bx,%si)
    9371:	51                   	push   %cx
    9372:	52                   	push   %dx
    9373:	50                   	push   %ax
    9374:	e8 a1 1b             	call   af18 <cursor_init+0x90>
    9377:	00 00                	add    %al,(%bx,%si)
    9379:	83 c4 10             	add    $0x10,%sp
    draw_line(frame->vram,frame->w,8,28,8+64,28,COL_FF0000);
    937c:	a1 88 ec             	mov    0xec88,%ax
    937f:	00 00                	add    %al,(%bx,%si)
    9381:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    9385:	0f b7 d0             	movzww %ax,%dx
    9388:	a1 88 ec             	mov    0xec88,%ax
    938b:	00 00                	add    %al,(%bx,%si)
    938d:	8b 00                	mov    (%bx,%si),%ax
    938f:	83 ec 04             	sub    $0x4,%sp
    9392:	6a 01                	push   $0x1
    9394:	6a 1c                	push   $0x1c
    9396:	6a 48                	push   $0x48
    9398:	6a 1c                	push   $0x1c
    939a:	6a 08                	push   $0x8
    939c:	52                   	push   %dx
    939d:	50                   	push   %ax
    939e:	e8 7c 2d             	call   c11d <draw_point+0x44>
    93a1:	00 00                	add    %al,(%bx,%si)
    93a3:	83 c4 20             	add    $0x20,%sp
    draw_line(frame->vram,frame->w,8,28,8+64,28+32,COL_FF00FF);
    93a6:	a1 88 ec             	mov    0xec88,%ax
    93a9:	00 00                	add    %al,(%bx,%si)
    93ab:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    93af:	0f b7 d0             	movzww %ax,%dx
    93b2:	a1 88 ec             	mov    0xec88,%ax
    93b5:	00 00                	add    %al,(%bx,%si)
    93b7:	8b 00                	mov    (%bx,%si),%ax
    93b9:	83 ec 04             	sub    $0x4,%sp
    93bc:	6a 05                	push   $0x5
    93be:	6a 3c                	push   $0x3c
    93c0:	6a 48                	push   $0x48
    93c2:	6a 1c                	push   $0x1c
    93c4:	6a 08                	push   $0x8
    93c6:	52                   	push   %dx
    93c7:	50                   	push   %ax
    93c8:	e8 52 2d             	call   c11d <draw_point+0x44>
    93cb:	00 00                	add    %al,(%bx,%si)
    93cd:	83 c4 20             	add    $0x20,%sp
    draw_line(frame->vram,frame->w,8,28,8+64,28+64,COL_00FF00);
    93d0:	a1 88 ec             	mov    0xec88,%ax
    93d3:	00 00                	add    %al,(%bx,%si)
    93d5:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    93d9:	0f b7 d0             	movzww %ax,%dx
    93dc:	a1 88 ec             	mov    0xec88,%ax
    93df:	00 00                	add    %al,(%bx,%si)
    93e1:	8b 00                	mov    (%bx,%si),%ax
    93e3:	83 ec 04             	sub    $0x4,%sp
    93e6:	6a 02                	push   $0x2
    93e8:	6a 5c                	push   $0x5c
    93ea:	6a 48                	push   $0x48
    93ec:	6a 1c                	push   $0x1c
    93ee:	6a 08                	push   $0x8
    93f0:	52                   	push   %dx
    93f1:	50                   	push   %ax
    93f2:	e8 28 2d             	call   c11d <draw_point+0x44>
    93f5:	00 00                	add    %al,(%bx,%si)
    93f7:	83 c4 20             	add    $0x20,%sp
    draw_line(frame->vram,frame->w,8,28,8+32,28+64,COL_FFFF00);
    93fa:	a1 88 ec             	mov    0xec88,%ax
    93fd:	00 00                	add    %al,(%bx,%si)
    93ff:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    9403:	0f b7 d0             	movzww %ax,%dx
    9406:	a1 88 ec             	mov    0xec88,%ax
    9409:	00 00                	add    %al,(%bx,%si)
    940b:	8b 00                	mov    (%bx,%si),%ax
    940d:	83 ec 04             	sub    $0x4,%sp
    9410:	6a 03                	push   $0x3
    9412:	6a 5c                	push   $0x5c
    9414:	6a 28                	push   $0x28
    9416:	6a 1c                	push   $0x1c
    9418:	6a 08                	push   $0x8
    941a:	52                   	push   %dx
    941b:	50                   	push   %ax
    941c:	e8 fe 2c             	call   c11d <draw_point+0x44>
    941f:	00 00                	add    %al,(%bx,%si)
    9421:	83 c4 20             	add    $0x20,%sp
    draw_line(frame->vram,frame->w,8,28,8,28+64,COL_0000FF);
    9424:	a1 88 ec             	mov    0xec88,%ax
    9427:	00 00                	add    %al,(%bx,%si)
    9429:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    942d:	0f b7 d0             	movzww %ax,%dx
    9430:	a1 88 ec             	mov    0xec88,%ax
    9433:	00 00                	add    %al,(%bx,%si)
    9435:	8b 00                	mov    (%bx,%si),%ax
    9437:	83 ec 04             	sub    $0x4,%sp
    943a:	6a 04                	push   $0x4
    943c:	6a 5c                	push   $0x5c
    943e:	6a 08                	push   $0x8
    9440:	6a 1c                	push   $0x1c
    9442:	6a 08                	push   $0x8
    9444:	52                   	push   %dx
    9445:	50                   	push   %ax
    9446:	e8 d4 2c             	call   c11d <draw_point+0x44>
    9449:	00 00                	add    %al,(%bx,%si)
    944b:	83 c4 20             	add    $0x20,%sp
    frame_refresh_sub(frame->x,frame->y,frame->w,frame->h);
    944e:	a1 88 ec             	mov    0xec88,%ax
    9451:	00 00                	add    %al,(%bx,%si)
    9453:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    9457:	0f b7 d8             	movzww %ax,%bx
    945a:	a1 88 ec             	mov    0xec88,%ax
    945d:	00 00                	add    %al,(%bx,%si)
    945f:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    9463:	0f b7 c8             	movzww %ax,%cx
    9466:	a1 88 ec             	mov    0xec88,%ax
    9469:	00 00                	add    %al,(%bx,%si)
    946b:	8b 50 08             	mov    0x8(%bx,%si),%dx
    946e:	a1 88 ec             	mov    0xec88,%ax
    9471:	00 00                	add    %al,(%bx,%si)
    9473:	8b 40 04             	mov    0x4(%bx,%si),%ax
    9476:	53                   	push   %bx
    9477:	51                   	push   %cx
    9478:	52                   	push   %dx
    9479:	50                   	push   %ax
    947a:	e8 83 25             	call   ba00 <draw_frame_sub+0xbb>
    947d:	00 00                	add    %al,(%bx,%si)
    947f:	83 c4 10             	add    $0x10,%sp
}
    9482:	90                   	nop
    9483:	8b 5d fc             	mov    -0x4(%di),%bx
    9486:	c9                   	leave
    9487:	c3                   	ret

00009488 <init_line>:

void init_line(){
    9488:	55                   	push   %bp
    9489:	89 e5                	mov    %sp,%bp
    948b:	83 ec 08             	sub    $0x8,%sp
    if(frame&&frame->used){// 防止多次开启
    948e:	a1 88 ec             	mov    0xec88,%ax
    9491:	00 00                	add    %al,(%bx,%si)
    9493:	85 c0                	test   %ax,%ax
    9495:	74 0c                	je     94a3 <init_line+0x1b>
    9497:	a1 88 ec             	mov    0xec88,%ax
    949a:	00 00                	add    %al,(%bx,%si)
    949c:	8b 40 14             	mov    0x14(%bx,%si),%ax
    949f:	85 c0                	test   %ax,%ax
    94a1:	75 3c                	jne    94df <init_line+0x57>
        return;
    }
    // 暂时文件里面没有记录图片的长宽信息，先直接写死
    frame= frame_alloc((SCREEN_W - 256) / 2, (SCREEN_H - 165) / 2, 64+8*2, 64+9+28);
    94a3:	6a 65                	push   $0x65
    94a5:	6a 50                	push   $0x50
    94a7:	6a 11                	push   $0x11
    94a9:	6a 20                	push   $0x20
    94ab:	e8 47 21             	call   b5f5 <frame_free+0x4c>
    94ae:	00 00                	add    %al,(%bx,%si)
    94b0:	83 c4 10             	add    $0x10,%sp
    94b3:	a3 88 ec             	mov    %ax,0xec88
    94b6:	00 00                	add    %al,(%bx,%si)
    frame->flag|=FRAME_CLICK;
    94b8:	a1 88 ec             	mov    0xec88,%ax
    94bb:	00 00                	add    %al,(%bx,%si)
    94bd:	0f b6 50 12          	movzbw 0x12(%bx,%si),%dx
    94c1:	a1 88 ec             	mov    0xec88,%ax
    94c4:	00 00                	add    %al,(%bx,%si)
    94c6:	83 ca 04             	or     $0x4,%dx
    94c9:	88 50 12             	mov    %dl,0x12(%bx,%si)
    frame->click=line_click;
    94cc:	a1 88 ec             	mov    0xec88,%ax
    94cf:	00 00                	add    %al,(%bx,%si)
    94d1:	c7 40 18 ce 92       	movw   $0x92ce,0x18(%bx,%si)
    94d6:	00 00                	add    %al,(%bx,%si)
    line_init();
    94d8:	e8 69 fe             	call   9344 <line_click+0x76>
    94db:	ff                   	(bad)
    94dc:	ff                   	(bad)
    94dd:	eb 01                	jmp    94e0 <init_line+0x58>
        return;
    94df:	90                   	nop
    94e0:	c9                   	leave
    94e1:	c3                   	ret

000094e2 <cli>:
static inline void cli() {
    94e2:	55                   	push   %bp
    94e3:	89 e5                	mov    %sp,%bp
	__asm__ __volatile__("cli");
    94e5:	fa                   	cli
}
    94e6:	90                   	nop
    94e7:	5d                   	pop    %bp
    94e8:	c3                   	ret

000094e9 <sti>:
static inline void sti() {
    94e9:	55                   	push   %bp
    94ea:	89 e5                	mov    %sp,%bp
	__asm__ __volatile__("sti");
    94ec:	fb                   	sti
}
    94ed:	90                   	nop
    94ee:	5d                   	pop    %bp
    94ef:	c3                   	ret

000094f0 <hlt>:
static inline void hlt() {
    94f0:	55                   	push   %bp
    94f1:	89 e5                	mov    %sp,%bp
    __asm__ __volatile__("hlt");
    94f3:	f4                   	hlt
}
    94f4:	90                   	nop
    94f5:	5d                   	pop    %bp
    94f6:	c3                   	ret

000094f7 <max>:
        return -val;
    }
    return val;
}

static inline int max(int val1,int val2) {
    94f7:	55                   	push   %bp
    94f8:	89 e5                	mov    %sp,%bp
    if(val1>val2){
    94fa:	8b 45 08             	mov    0x8(%di),%ax
    94fd:	3b 45 0c             	cmp    0xc(%di),%ax
    9500:	7e 05                	jle    9507 <max+0x10>
        return val1;
    9502:	8b 45 08             	mov    0x8(%di),%ax
    9505:	eb 03                	jmp    950a <max+0x13>
    }
    return val2;
    9507:	8b 45 0c             	mov    0xc(%di),%ax
}
    950a:	5d                   	pop    %bp
    950b:	c3                   	ret

0000950c <nano_click>:
static task_t *task;
static int offset;
static bool_t has_more;
static char name[16]; // 用于保存文件名称

bool_t nano_click(int x,int y){// 暂时只判断关闭事件
    950c:	55                   	push   %bp
    950d:	89 e5                	mov    %sp,%bp
    950f:	53                   	push   %bx
    9510:	83 ec 04             	sub    $0x4,%sp
    if(window_close(frame, x, y)){
    9513:	a1 8c ec             	mov    0xec8c,%ax
    9516:	00 00                	add    %al,(%bx,%si)
    9518:	83 ec 04             	sub    $0x4,%sp
    951b:	ff 75 0c             	push   0xc(%di)
    951e:	ff 75 08             	push   0x8(%di)
    9521:	50                   	push   %ax
    9522:	e8 e5 1b             	call   b10a <draw_window+0x1f0>
    9525:	00 00                	add    %al,(%bx,%si)
    9527:	83 c4 10             	add    $0x10,%sp
    952a:	85 c0                	test   %ax,%ax
    952c:	74 5d                	je     958b <nano_click+0x7f>
        frame_free(frame);
    952e:	a1 8c ec             	mov    0xec8c,%ax
    9531:	00 00                	add    %al,(%bx,%si)
    9533:	83 ec 0c             	sub    $0xc,%sp
    9536:	50                   	push   %ax
    9537:	e8 6d 20             	call   b5a7 <init_frame+0x184>
    953a:	00 00                	add    %al,(%bx,%si)
    953c:	83 c4 10             	add    $0x10,%sp
        frame_refresh_sub(frame->x, frame->y, frame->w, frame->h);
    953f:	a1 8c ec             	mov    0xec8c,%ax
    9542:	00 00                	add    %al,(%bx,%si)
    9544:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    9548:	0f b7 d8             	movzww %ax,%bx
    954b:	a1 8c ec             	mov    0xec8c,%ax
    954e:	00 00                	add    %al,(%bx,%si)
    9550:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    9554:	0f b7 c8             	movzww %ax,%cx
    9557:	a1 8c ec             	mov    0xec8c,%ax
    955a:	00 00                	add    %al,(%bx,%si)
    955c:	8b 50 08             	mov    0x8(%bx,%si),%dx
    955f:	a1 8c ec             	mov    0xec8c,%ax
    9562:	00 00                	add    %al,(%bx,%si)
    9564:	8b 40 04             	mov    0x4(%bx,%si),%ax
    9567:	53                   	push   %bx
    9568:	51                   	push   %cx
    9569:	52                   	push   %dx
    956a:	50                   	push   %ax
    956b:	e8 92 24             	call   ba00 <draw_frame_sub+0xbb>
    956e:	00 00                	add    %al,(%bx,%si)
    9570:	83 c4 10             	add    $0x10,%sp
        task_exit(task);
    9573:	a1 90 ec             	mov    0xec90,%ax
    9576:	00 00                	add    %al,(%bx,%si)
    9578:	83 ec 0c             	sub    $0xc,%sp
    957b:	50                   	push   %ax
    957c:	e8 95 3c             	call   d214 <task_sleep+0x28>
    957f:	00 00                	add    %al,(%bx,%si)
    9581:	83 c4 10             	add    $0x10,%sp
        return TRUE;
    9584:	b8 01 00             	mov    $0x1,%ax
    9587:	00 00                	add    %al,(%bx,%si)
    9589:	eb 05                	jmp    9590 <nano_click+0x84>
    }
    return FALSE;
    958b:	b8 00 00             	mov    $0x0,%ax
    958e:	00 00                	add    %al,(%bx,%si)
}
    9590:	8b 5d fc             	mov    -0x4(%di),%bx
    9593:	c9                   	leave
    9594:	c3                   	ret

00009595 <show_content>:

// 30 * 8
void show_content() {
    9595:	55                   	push   %bp
    9596:	89 e5                	mov    %sp,%bp
    9598:	53                   	push   %bx
    9599:	83 ec 14             	sub    $0x14,%sp
    // 读取
    file_t *file =file_open(name,FALSE);
    959c:	83 ec 08             	sub    $0x8,%sp
    959f:	6a 00                	push   $0x0
    95a1:	68 9c ec             	push   $0xec9c
    95a4:	00 00                	add    %al,(%bx,%si)
    95a6:	e8 2d 0e             	call   a3d6 <find_empty_sel+0x96>
    95a9:	00 00                	add    %al,(%bx,%si)
    95ab:	83 c4 10             	add    $0x10,%sp
    95ae:	89 45 f0             	mov    %ax,-0x10(%di)
    if(!file){
    95b1:	83 7d f0 00          	cmpw   $0x0,-0x10(%di)
    95b5:	0f 84 3f 01          	je     96f8 <show_content+0x163>
    95b9:	00 00                	add    %al,(%bx,%si)
        return;
    }
    has_more=file->size>30*8+offset;
    95bb:	8b 45 f0             	mov    -0x10(%di),%ax
    95be:	8b 80 14 02          	mov    0x214(%bx,%si),%ax
    95c2:	00 00                	add    %al,(%bx,%si)
    95c4:	8b 15                	mov    (%di),%dx
    95c6:	94                   	xchg   %ax,%sp
    95c7:	ec                   	in     (%dx),%al
    95c8:	00 00                	add    %al,(%bx,%si)
    95ca:	81 c2 f0 00          	add    $0xf0,%dx
    95ce:	00 00                	add    %al,(%bx,%si)
    95d0:	39 c2                	cmp    %ax,%dx
    95d2:	0f 92 c0             	setb   %al
    95d5:	0f b6 c0             	movzbw %al,%ax
    95d8:	a3 98 ec             	mov    %ax,0xec98
    95db:	00 00                	add    %al,(%bx,%si)
    file_seek(file,offset);
    95dd:	a1 94 ec             	mov    0xec94,%ax
    95e0:	00 00                	add    %al,(%bx,%si)
    95e2:	83 ec 08             	sub    $0x8,%sp
    95e5:	50                   	push   %ax
    95e6:	ff 75 f0             	push   -0x10(%di)
    95e9:	e8 6c 14             	call   aa58 <file_close+0x25>
    95ec:	00 00                	add    %al,(%bx,%si)
    95ee:	83 c4 10             	add    $0x10,%sp
    char *buff= mem_alloc(30*8);
    95f1:	83 ec 0c             	sub    $0xc,%sp
    95f4:	68 f0 00             	push   $0xf0
    95f7:	00 00                	add    %al,(%bx,%si)
    95f9:	e8 e6 37             	call   cde2 <mem_total+0x53>
    95fc:	00 00                	add    %al,(%bx,%si)
    95fe:	83 c4 10             	add    $0x10,%sp
    9601:	89 45 ec             	mov    %ax,-0x14(%di)
    file_read(file,30*8,(uint8_t *)buff);
    9604:	83 ec 04             	sub    $0x4,%sp
    9607:	ff 75 ec             	push   -0x14(%di)
    960a:	68 f0 00             	push   $0xf0
    960d:	00 00                	add    %al,(%bx,%si)
    960f:	ff 75 f0             	push   -0x10(%di)
    9612:	e8 8a 0f             	call   a59f <make_sure_buff+0x72>
    9615:	00 00                	add    %al,(%bx,%si)
    9617:	83 c4 10             	add    $0x10,%sp
    // 绘制
    fill_rect(frame->vram,frame->w,8,28,240,128,COL_FFFFFF);
    961a:	a1 8c ec             	mov    0xec8c,%ax
    961d:	00 00                	add    %al,(%bx,%si)
    961f:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    9623:	0f b7 d0             	movzww %ax,%dx
    9626:	a1 8c ec             	mov    0xec8c,%ax
    9629:	00 00                	add    %al,(%bx,%si)
    962b:	8b 00                	mov    (%bx,%si),%ax
    962d:	83 ec 04             	sub    $0x4,%sp
    9630:	6a 07                	push   $0x7
    9632:	68 80 00             	push   $0x80
    9635:	00 00                	add    %al,(%bx,%si)
    9637:	68 f0 00             	push   $0xf0
    963a:	00 00                	add    %al,(%bx,%si)
    963c:	6a 1c                	push   $0x1c
    963e:	6a 08                	push   $0x8
    9640:	52                   	push   %dx
    9641:	50                   	push   %ax
    9642:	e8 0d 2a             	call   c052 <fill_alpha+0x34>
    9645:	00 00                	add    %al,(%bx,%si)
    9647:	83 c4 20             	add    $0x20,%sp
    for (int i = 7; i >=0; --i) {
    964a:	c7 45 f4 07 00       	movw   $0x7,-0xc(%di)
    964f:	00 00                	add    %al,(%bx,%si)
    9651:	eb 54                	jmp    96a7 <show_content+0x112>
        draw_str(frame->vram,frame->w,8,28+i*16,buff+i*30,COL_000000);
    9653:	8b 45 f4             	mov    -0xc(%di),%ax
    9656:	6b c0 1e             	imul   $0x1e,%ax,%ax
    9659:	89 c2                	mov    %ax,%dx
    965b:	8b 45 ec             	mov    -0x14(%di),%ax
    965e:	8d 1c                	lea    (%si),%bx
    9660:	02 8b 45 f4          	add    -0xbbb(%bp,%di),%cl
    9664:	c1 e0 04             	shl    $0x4,%ax
    9667:	83 c0 1c             	add    $0x1c,%ax
    966a:	0f b7 c8             	movzww %ax,%cx
    966d:	a1 8c ec             	mov    0xec8c,%ax
    9670:	00 00                	add    %al,(%bx,%si)
    9672:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    9676:	0f b7 d0             	movzww %ax,%dx
    9679:	a1 8c ec             	mov    0xec8c,%ax
    967c:	00 00                	add    %al,(%bx,%si)
    967e:	8b 00                	mov    (%bx,%si),%ax
    9680:	83 ec 08             	sub    $0x8,%sp
    9683:	6a 00                	push   $0x0
    9685:	53                   	push   %bx
    9686:	51                   	push   %cx
    9687:	6a 08                	push   $0x8
    9689:	52                   	push   %dx
    968a:	50                   	push   %ax
    968b:	e8 88 2c             	call   c316 <draw_char+0xb1>
    968e:	00 00                	add    %al,(%bx,%si)
    9690:	83 c4 20             	add    $0x20,%sp
        buff[i*30]='\0';// 显示完就就行截断
    9693:	8b 45 f4             	mov    -0xc(%di),%ax
    9696:	6b c0 1e             	imul   $0x1e,%ax,%ax
    9699:	89 c2                	mov    %ax,%dx
    969b:	8b 45 ec             	mov    -0x14(%di),%ax
    969e:	01 d0                	add    %dx,%ax
    96a0:	c6 00 00             	movb   $0x0,(%bx,%si)
    for (int i = 7; i >=0; --i) {
    96a3:	83 6d f4 01          	subw   $0x1,-0xc(%di)
    96a7:	83 7d f4 00          	cmpw   $0x0,-0xc(%di)
    96ab:	79 a6                	jns    9653 <show_content+0xbe>
    }
    frame_refresh_sub(frame->x+8,frame->y+28,240,128);
    96ad:	a1 8c ec             	mov    0xec8c,%ax
    96b0:	00 00                	add    %al,(%bx,%si)
    96b2:	8b 40 08             	mov    0x8(%bx,%si),%ax
    96b5:	8d 50 1c             	lea    0x1c(%bx,%si),%dx
    96b8:	a1 8c ec             	mov    0xec8c,%ax
    96bb:	00 00                	add    %al,(%bx,%si)
    96bd:	8b 40 04             	mov    0x4(%bx,%si),%ax
    96c0:	83 c0 08             	add    $0x8,%ax
    96c3:	68 80 00             	push   $0x80
    96c6:	00 00                	add    %al,(%bx,%si)
    96c8:	68 f0 00             	push   $0xf0
    96cb:	00 00                	add    %al,(%bx,%si)
    96cd:	52                   	push   %dx
    96ce:	50                   	push   %ax
    96cf:	e8 2e 23             	call   ba00 <draw_frame_sub+0xbb>
    96d2:	00 00                	add    %al,(%bx,%si)
    96d4:	83 c4 10             	add    $0x10,%sp
    // 回收
    file_close(file);
    96d7:	83 ec 0c             	sub    $0xc,%sp
    96da:	ff 75 f0             	push   -0x10(%di)
    96dd:	e8 51 13             	call   aa31 <file_flush+0x3b>
    96e0:	00 00                	add    %al,(%bx,%si)
    96e2:	83 c4 10             	add    $0x10,%sp
    mem_free(buff,30*8);
    96e5:	83 ec 08             	sub    $0x8,%sp
    96e8:	68 f0 00             	push   $0xf0
    96eb:	00 00                	add    %al,(%bx,%si)
    96ed:	ff 75 ec             	push   -0x14(%di)
    96f0:	e8 ec 37             	call   cedf <mem_alloc+0xfb>
    96f3:	00 00                	add    %al,(%bx,%si)
    96f5:	83 c4 10             	add    $0x10,%sp
    96f8:	eb 01                	jmp    96fb <show_content+0x166>
        return;
    96fa:	90                   	nop
}
    96fb:	8b 5d fc             	mov    -0x4(%di),%bx
    96fe:	c9                   	leave
    96ff:	c3                   	ret

00009700 <nano_task>:

void nano_task(){
    9700:	55                   	push   %bp
    9701:	89 e5                	mov    %sp,%bp
    9703:	83 ec 18             	sub    $0x18,%sp
    while (TRUE){
        cli();
    9706:	e8 d7 fd             	call   94e0 <init_line+0x58>
    9709:	ff                   	(bad)
    970a:	ff a1 8c ec          	jmp    *-0x1374(%bx,%di)
        if(fifo_can_read(&frame->kdb_fifo)){
    970e:	00 00                	add    %al,(%bx,%si)
    9710:	83 c0 1c             	add    $0x1c,%ax
    9713:	83 ec 0c             	sub    $0xc,%sp
    9716:	50                   	push   %ax
    9717:	e8 92 08             	call   9fac <fifo_free+0x2a>
    971a:	00 00                	add    %al,(%bx,%si)
    971c:	83 c4 10             	add    $0x10,%sp
    971f:	85 c0                	test   %ax,%ax
    9721:	0f 84 df 00          	je     9804 <nano_task+0x104>
    9725:	00 00                	add    %al,(%bx,%si)
            uint8_t data= fifo_read(&frame->kdb_fifo);
    9727:	a1 8c ec             	mov    0xec8c,%ax
    972a:	00 00                	add    %al,(%bx,%si)
    972c:	83 c0 1c             	add    $0x1c,%ax
    972f:	83 ec 0c             	sub    $0xc,%sp
    9732:	50                   	push   %ax
    9733:	e8 a7 08             	call   9fdd <fifo_can_write+0x1a>
    9736:	00 00                	add    %al,(%bx,%si)
    9738:	83 c4 10             	add    $0x10,%sp
    973b:	88 45 f7             	mov    %al,-0x9(%di)
            sti();
    973e:	e8 a6 fd             	call   94e7 <cli+0x5>
    9741:	ff                   	(bad)
    9742:	ff 0f                	decw   (%bx)
            switch (data) {
    9744:	b6 45                	mov    $0x45,%dh
    9746:	f7 83 f8 20 0f 84    	testw  $0x840f,0x20f8(%bp,%di)
    974c:	97                   	xchg   %ax,%di
    974d:	00 00                	add    %al,(%bx,%si)
    974f:	00 83 f8 20          	add    %al,0x20f8(%bp,%di)
    9753:	7f b1                	jg     9706 <nano_task+0x6>
    9755:	83 f8 1f             	cmp    $0x1f,%ax
    9758:	74 43                	je     979d <nano_task+0x9d>
    975a:	83 f8 1f             	cmp    $0x1f,%ax
    975d:	7f a7                	jg     9706 <nano_task+0x6>
    975f:	83 f8 11             	cmp    $0x11,%ax
    9762:	74 0a                	je     976e <nano_task+0x6e>
    9764:	83 f8 1e             	cmp    $0x1e,%ax
    9767:	74 51                	je     97ba <nano_task+0xba>
    9769:	e9 ba 00             	jmp    9826 <nano_task+0x126>
    976c:	00 00                	add    %al,(%bx,%si)
                case 17: // W
                    if(offset>0){// 向前1行
    976e:	a1 94 ec             	mov    0xec94,%ax
    9771:	00 00                	add    %al,(%bx,%si)
    9773:	85 c0                	test   %ax,%ax
    9775:	0f 8e 9a 00          	jle    9813 <nano_task+0x113>
    9779:	00 00                	add    %al,(%bx,%si)
                        offset=max(offset-30,0);
    977b:	a1 94 ec             	mov    0xec94,%ax
    977e:	00 00                	add    %al,(%bx,%si)
    9780:	83 e8 1e             	sub    $0x1e,%ax
    9783:	83 ec 08             	sub    $0x8,%sp
    9786:	6a 00                	push   $0x0
    9788:	50                   	push   %ax
    9789:	e8 69 fd             	call   94f5 <hlt+0x5>
    978c:	ff                   	(bad)
    978d:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    9791:	a3 94 ec             	mov    %ax,0xec94
    9794:	00 00                	add    %al,(%bx,%si)
                        show_content();
    9796:	e8 fa fd             	call   9593 <nano_click+0x87>
    9799:	ff                   	(bad)
    979a:	ff                   	(bad)
                    }
                    break;
    979b:	eb 78                	jmp    9815 <nano_task+0x115>
                case 31: // S
                    if(has_more){// 向后一行
    979d:	a1 98 ec             	mov    0xec98,%ax
    97a0:	00 00                	add    %al,(%bx,%si)
    97a2:	85 c0                	test   %ax,%ax
    97a4:	74 75                	je     981b <nano_task+0x11b>
                        offset+=30;
    97a6:	a1 94 ec             	mov    0xec94,%ax
    97a9:	00 00                	add    %al,(%bx,%si)
    97ab:	83 c0 1e             	add    $0x1e,%ax
    97ae:	a3 94 ec             	mov    %ax,0xec94
    97b1:	00 00                	add    %al,(%bx,%si)
                        show_content();
    97b3:	e8 dd fd             	call   9593 <nano_click+0x87>
    97b6:	ff                   	(bad)
    97b7:	ff                   	(bad)
                    }
                    break;
    97b8:	eb 61                	jmp    981b <nano_task+0x11b>
                case 30: // A
                    if(offset>0){// 向前1页
    97ba:	a1 94 ec             	mov    0xec94,%ax
    97bd:	00 00                	add    %al,(%bx,%si)
    97bf:	85 c0                	test   %ax,%ax
    97c1:	7e 5e                	jle    9821 <nano_task+0x121>
                        offset=max(offset-30*8,0);
    97c3:	a1 94 ec             	mov    0xec94,%ax
    97c6:	00 00                	add    %al,(%bx,%si)
    97c8:	2d f0 00             	sub    $0xf0,%ax
    97cb:	00 00                	add    %al,(%bx,%si)
    97cd:	83 ec 08             	sub    $0x8,%sp
    97d0:	6a 00                	push   $0x0
    97d2:	50                   	push   %ax
    97d3:	e8 1f fd             	call   94f5 <hlt+0x5>
    97d6:	ff                   	(bad)
    97d7:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    97db:	a3 94 ec             	mov    %ax,0xec94
    97de:	00 00                	add    %al,(%bx,%si)
                        show_content();
    97e0:	e8 b0 fd             	call   9593 <nano_click+0x87>
    97e3:	ff                   	(bad)
    97e4:	ff                   	(bad)
                    }
                    break;
    97e5:	eb 3a                	jmp    9821 <nano_task+0x121>
                case 32: // D
                    if(has_more){// 向后1页
    97e7:	a1 98 ec             	mov    0xec98,%ax
    97ea:	00 00                	add    %al,(%bx,%si)
    97ec:	85 c0                	test   %ax,%ax
    97ee:	74 37                	je     9827 <nano_task+0x127>
                        offset+=30*8;
    97f0:	a1 94 ec             	mov    0xec94,%ax
    97f3:	00 00                	add    %al,(%bx,%si)
    97f5:	05 f0 00             	add    $0xf0,%ax
    97f8:	00 00                	add    %al,(%bx,%si)
    97fa:	a3 94 ec             	mov    %ax,0xec94
    97fd:	00 00                	add    %al,(%bx,%si)
                        show_content();
    97ff:	e8 91 fd             	call   9593 <nano_click+0x87>
    9802:	ff                   	(bad)
    9803:	ff                   	(bad)
                    }
                    break;
    9804:	eb 21                	jmp    9827 <nano_task+0x127>
            }
        } else{
            sti();
    9806:	e8 de fc             	call   94e7 <cli+0x5>
    9809:	ff                   	(bad)
    980a:	ff                   	(bad)
            hlt();
    980b:	e8 e0 fc             	call   94ee <sti+0x5>
    980e:	ff                   	(bad)
    980f:	ff                   	(bad)
    9810:	e9 f1 fe             	jmp    9704 <nano_task+0x4>
    9813:	ff                   	(bad)
    9814:	ff 90 e9 eb          	call   *-0x1417(%bx,%si)
                    break;
    9818:	fe                   	(bad)
    9819:	ff                   	(bad)
    981a:	ff 90 e9 e5          	call   *-0x1a17(%bx,%si)
                    break;
    981e:	fe                   	(bad)
    981f:	ff                   	(bad)
    9820:	ff 90 e9 df          	call   *-0x2017(%bx,%si)
                    break;
    9824:	fe                   	(bad)
    9825:	ff                   	(bad)
    9826:	ff 90 e9 d9          	call   *-0x2617(%bx,%si)
        cli();
    982a:	fe                   	(bad)
    982b:	ff                   	(bad)
    982c:	ff                   	.byte 0xff

0000982d <nano_init>:
        }
    }
}

void nano_init() {
    982d:	55                   	push   %bp
    982e:	89 e5                	mov    %sp,%bp
    9830:	53                   	push   %bx
    9831:	83 ec 04             	sub    $0x4,%sp
    draw_window(frame->vram, frame->w, frame->h, "NANO");
    9834:	a1 8c ec             	mov    0xec8c,%ax
    9837:	00 00                	add    %al,(%bx,%si)
    9839:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    983d:	0f b7 c8             	movzww %ax,%cx
    9840:	a1 8c ec             	mov    0xec8c,%ax
    9843:	00 00                	add    %al,(%bx,%si)
    9845:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    9849:	0f b7 d0             	movzww %ax,%dx
    984c:	a1 8c ec             	mov    0xec8c,%ax
    984f:	00 00                	add    %al,(%bx,%si)
    9851:	8b 00                	mov    (%bx,%si),%ax
    9853:	68 48 da             	push   $0xda48
    9856:	00 00                	add    %al,(%bx,%si)
    9858:	51                   	push   %cx
    9859:	52                   	push   %dx
    985a:	50                   	push   %ax
    985b:	e8 ba 16             	call   af18 <cursor_init+0x90>
    985e:	00 00                	add    %al,(%bx,%si)
    9860:	83 c4 10             	add    $0x10,%sp
    draw_textbox(frame->vram, frame->w, 8, 28, 248, 156, COL_FFFFFF);
    9863:	a1 8c ec             	mov    0xec8c,%ax
    9866:	00 00                	add    %al,(%bx,%si)
    9868:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    986c:	0f b7 d0             	movzww %ax,%dx
    986f:	a1 8c ec             	mov    0xec8c,%ax
    9872:	00 00                	add    %al,(%bx,%si)
    9874:	8b 00                	mov    (%bx,%si),%ax
    9876:	83 ec 04             	sub    $0x4,%sp
    9879:	6a 07                	push   $0x7
    987b:	68 9c 00             	push   $0x9c
    987e:	00 00                	add    %al,(%bx,%si)
    9880:	68 f8 00             	push   $0xf8
    9883:	00 00                	add    %al,(%bx,%si)
    9885:	6a 1c                	push   $0x1c
    9887:	6a 08                	push   $0x8
    9889:	52                   	push   %dx
    988a:	50                   	push   %ax
    988b:	e8 1e 19             	call   b1ac <window_init+0x36>
    988e:	00 00                	add    %al,(%bx,%si)
    9890:	83 c4 20             	add    $0x20,%sp
    frame_refresh_sub(frame->x, frame->y, frame->w, frame->h);
    9893:	a1 8c ec             	mov    0xec8c,%ax
    9896:	00 00                	add    %al,(%bx,%si)
    9898:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    989c:	0f b7 d8             	movzww %ax,%bx
    989f:	a1 8c ec             	mov    0xec8c,%ax
    98a2:	00 00                	add    %al,(%bx,%si)
    98a4:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    98a8:	0f b7 c8             	movzww %ax,%cx
    98ab:	a1 8c ec             	mov    0xec8c,%ax
    98ae:	00 00                	add    %al,(%bx,%si)
    98b0:	8b 50 08             	mov    0x8(%bx,%si),%dx
    98b3:	a1 8c ec             	mov    0xec8c,%ax
    98b6:	00 00                	add    %al,(%bx,%si)
    98b8:	8b 40 04             	mov    0x4(%bx,%si),%ax
    98bb:	53                   	push   %bx
    98bc:	51                   	push   %cx
    98bd:	52                   	push   %dx
    98be:	50                   	push   %ax
    98bf:	e8 3e 21             	call   ba00 <draw_frame_sub+0xbb>
    98c2:	00 00                	add    %al,(%bx,%si)
    98c4:	83 c4 10             	add    $0x10,%sp
}
    98c7:	90                   	nop
    98c8:	8b 5d fc             	mov    -0x4(%di),%bx
    98cb:	c9                   	leave
    98cc:	c3                   	ret

000098cd <init_nano>:

void init_nano(char *path){
    98cd:	55                   	push   %bp
    98ce:	89 e5                	mov    %sp,%bp
    98d0:	83 ec 08             	sub    $0x8,%sp
    if(frame&&frame->used){// 防止多次开启
    98d3:	a1 8c ec             	mov    0xec8c,%ax
    98d6:	00 00                	add    %al,(%bx,%si)
    98d8:	85 c0                	test   %ax,%ax
    98da:	74 0c                	je     98e8 <init_nano+0x1b>
    98dc:	a1 8c ec             	mov    0xec8c,%ax
    98df:	00 00                	add    %al,(%bx,%si)
    98e1:	8b 40 14             	mov    0x14(%bx,%si),%ax
    98e4:	85 c0                	test   %ax,%ax
    98e6:	75 7d                	jne    9965 <init_nano+0x98>
        return;
    }
    frame= frame_alloc((SCREEN_W - 256) / 2, (SCREEN_H - 165) / 2, 256, 165);
    98e8:	68 a5 00             	push   $0xa5
    98eb:	00 00                	add    %al,(%bx,%si)
    98ed:	68 00 01             	push   $0x100
    98f0:	00 00                	add    %al,(%bx,%si)
    98f2:	6a 11                	push   $0x11
    98f4:	6a 20                	push   $0x20
    98f6:	e8 fc 1c             	call   b5f5 <frame_free+0x4c>
    98f9:	00 00                	add    %al,(%bx,%si)
    98fb:	83 c4 10             	add    $0x10,%sp
    98fe:	a3 8c ec             	mov    %ax,0xec8c
    9901:	00 00                	add    %al,(%bx,%si)
    frame->flag|=FRAME_CLICK;
    9903:	a1 8c ec             	mov    0xec8c,%ax
    9906:	00 00                	add    %al,(%bx,%si)
    9908:	0f b6 50 12          	movzbw 0x12(%bx,%si),%dx
    990c:	a1 8c ec             	mov    0xec8c,%ax
    990f:	00 00                	add    %al,(%bx,%si)
    9911:	83 ca 04             	or     $0x4,%dx
    9914:	88 50 12             	mov    %dl,0x12(%bx,%si)
    frame->click=nano_click;
    9917:	a1 8c ec             	mov    0xec8c,%ax
    991a:	00 00                	add    %al,(%bx,%si)
    991c:	c7 40 18 0c 95       	movw   $0x950c,0x18(%bx,%si)
    9921:	00 00                	add    %al,(%bx,%si)
    nano_init();
    9923:	e8 05 ff             	call   982b <nano_task+0x12b>
    9926:	ff                   	(bad)
    9927:	ff 83 ec 08          	incw   0x8ec(%bp,%di)
    task=create_task(nano_task,3);
    992b:	6a 03                	push   $0x3
    992d:	68 00 97             	push   $0x9700
    9930:	00 00                	add    %al,(%bx,%si)
    9932:	e8 13 39             	call   d248 <task_exit+0x32>
    9935:	00 00                	add    %al,(%bx,%si)
    9937:	83 c4 10             	add    $0x10,%sp
    993a:	a3 90 ec             	mov    %ax,0xec90
    993d:	00 00                	add    %al,(%bx,%si)
    offset=0;
    993f:	c7 05 94 ec          	movw   $0xec94,(%di)
    9943:	00 00                	add    %al,(%bx,%si)
    9945:	00 00                	add    %al,(%bx,%si)
    9947:	00 00                	add    %al,(%bx,%si)
    mem_copy(name,path,16);
    9949:	83 ec 04             	sub    $0x4,%sp
    994c:	6a 10                	push   $0x10
    994e:	ff 75 08             	push   0x8(%di)
    9951:	68 9c ec             	push   $0xec9c
    9954:	00 00                	add    %al,(%bx,%si)
    9956:	e8 09 3f             	call   d862 <mem_eq+0x60>
    9959:	00 00                	add    %al,(%bx,%si)
    995b:	83 c4 10             	add    $0x10,%sp
    show_content();
    995e:	e8 32 fc             	call   9593 <nano_click+0x87>
    9961:	ff                   	(bad)
    9962:	ff                   	(bad)
    9963:	eb 01                	jmp    9966 <init_nano+0x99>
        return;
    9965:	90                   	nop
//
//    char *temp ="I want to teach my students how to live this life on earth,To face its struggle and its strife and improve their worth.Not just the lesson in a book or how the rivers flow,But h ow to choose the proper path wherever they may go.To understand eternal truth and kn ow the right from wrong,And gather all the beauty of a flower and a song.For if I help th e world to grow in wisdom and in grace,Then,I shall feel that I have won and I have fill ed my place.And so I ask my guidance,God,that I may do my part,For character and confidence and happiness of heart.";
//    file_t *file= file_open("poem",TRUE);
//    file_write(file, str_len(temp),(uint8_t *)temp);
//    file_close(file);
    9966:	c9                   	leave
    9967:	c3                   	ret

00009968 <lgdt>:
static inline void lgdt(uint32_t start, uint32_t size) {
    9968:	55                   	push   %bp
    9969:	89 e5                	mov    %sp,%bp
    996b:	83 ec 10             	sub    $0x10,%sp
	gdt.start31_16 = start >> 16;
    996e:	8b 45 08             	mov    0x8(%di),%ax
    9971:	c1 e8 10             	shr    $0x10,%ax
    9974:	66 89 45 fe          	mov    %eax,-0x2(%di)
	gdt.start15_0 = start & 0xFFFF;
    9978:	8b 45 08             	mov    0x8(%di),%ax
    997b:	66 89 45 fc          	mov    %eax,-0x4(%di)
	gdt.limit = size - 1;
    997f:	8b 45 0c             	mov    0xc(%di),%ax
    9982:	83 e8 01             	sub    $0x1,%ax
    9985:	66 89 45 fa          	mov    %eax,-0x6(%di)
	__asm__ __volatile__("lgdt %[g]"::[g]"m"(gdt));
    9989:	0f 01 55 fa          	lgdtw  -0x6(%di)
}
    998d:	90                   	nop
    998e:	c9                   	leave
    998f:	c3                   	ret

00009990 <lidt>:
static inline void lidt(uint32_t start, uint32_t size) {
    9990:	55                   	push   %bp
    9991:	89 e5                	mov    %sp,%bp
    9993:	83 ec 10             	sub    $0x10,%sp
	idt.start31_16 = start >> 16;
    9996:	8b 45 08             	mov    0x8(%di),%ax
    9999:	c1 e8 10             	shr    $0x10,%ax
    999c:	66 89 45 fe          	mov    %eax,-0x2(%di)
	idt.start15_0 = start & 0xFFFF;
    99a0:	8b 45 08             	mov    0x8(%di),%ax
    99a3:	66 89 45 fc          	mov    %eax,-0x4(%di)
	idt.limit = size - 1;
    99a7:	8b 45 0c             	mov    0xc(%di),%ax
    99aa:	83 e8 01             	sub    $0x1,%ax
    99ad:	66 89 45 fa          	mov    %eax,-0x6(%di)
	__asm__ __volatile__("lidt %0"::"m"(idt));
    99b1:	0f 01 5d fa          	lidtw  -0x6(%di)
}
    99b5:	90                   	nop
    99b6:	c9                   	leave
    99b7:	c3                   	ret

000099b8 <init_gdt_idt>:
#include "mem.h"

static seg_desc_t *gdt;
static gate_desc_t *idt;

void init_gdt_idt(){
    99b8:	55                   	push   %bp
    99b9:	89 e5                	mov    %sp,%bp
    99bb:	83 ec 18             	sub    $0x18,%sp
    gdt= mem_alloc(sizeof(seg_desc_t)*GDT_COUNT);
    99be:	83 ec 0c             	sub    $0xc,%sp
    99c1:	68 00 20             	push   $0x2000
    99c4:	00 00                	add    %al,(%bx,%si)
    99c6:	e8 19 34             	call   cde2 <mem_total+0x53>
    99c9:	00 00                	add    %al,(%bx,%si)
    99cb:	83 c4 10             	add    $0x10,%sp
    99ce:	a3 ac ec             	mov    %ax,0xecac
    99d1:	00 00                	add    %al,(%bx,%si)
    // 第一个必须是空表项目 gdt初始化
    set_seg_desc(gdt, 0, 0, 0);// 若需要添加段注意总数量 注意这里是先代码段再数据段
    99d3:	a1 ac ec             	mov    0xecac,%ax
    99d6:	00 00                	add    %al,(%bx,%si)
    99d8:	6a 00                	push   $0x0
    99da:	6a 00                	push   $0x0
    99dc:	6a 00                	push   $0x0
    99de:	50                   	push   %ax
    99df:	e8 64 01             	call   9b46 <create_seg_desc+0x38>
    99e2:	00 00                	add    %al,(%bx,%si)
    99e4:	83 c4 10             	add    $0x10,%sp
    set_seg_desc(gdt + 1, 0xffffffff, 0x00000000, 0x409a);// 仅可执行的段 代码段
    99e7:	a1 ac ec             	mov    0xecac,%ax
    99ea:	00 00                	add    %al,(%bx,%si)
    99ec:	83 c0 08             	add    $0x8,%ax
    99ef:	68 9a 40             	push   $0x409a
    99f2:	00 00                	add    %al,(%bx,%si)
    99f4:	6a 00                	push   $0x0
    99f6:	6a ff                	push   $0xffff
    99f8:	50                   	push   %ax
    99f9:	e8 4a 01             	call   9b46 <create_seg_desc+0x38>
    99fc:	00 00                	add    %al,(%bx,%si)
    99fe:	83 c4 10             	add    $0x10,%sp
    set_seg_desc(gdt + 2, 0xffffffff, 0x00000000, 0x4092);// 读写段 数据段
    9a01:	a1 ac ec             	mov    0xecac,%ax
    9a04:	00 00                	add    %al,(%bx,%si)
    9a06:	83 c0 10             	add    $0x10,%ax
    9a09:	68 92 40             	push   $0x4092
    9a0c:	00 00                	add    %al,(%bx,%si)
    9a0e:	6a 00                	push   $0x0
    9a10:	6a ff                	push   $0xffff
    9a12:	50                   	push   %ax
    9a13:	e8 30 01             	call   9b46 <create_seg_desc+0x38>
    9a16:	00 00                	add    %al,(%bx,%si)
    9a18:	83 c4 10             	add    $0x10,%sp
    lgdt((uint32_t)gdt, sizeof(seg_desc_t)*GDT_COUNT);
    9a1b:	a1 ac ec             	mov    0xecac,%ax
    9a1e:	00 00                	add    %al,(%bx,%si)
    9a20:	83 ec 08             	sub    $0x8,%sp
    9a23:	68 00 20             	push   $0x2000
    9a26:	00 00                	add    %al,(%bx,%si)
    9a28:	50                   	push   %ax
    9a29:	e8 3a ff             	call   9966 <init_nano+0x99>
    9a2c:	ff                   	(bad)
    9a2d:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    idt= mem_alloc(sizeof(gate_desc_t)*IDT_COUNT);
    9a31:	83 ec 0c             	sub    $0xc,%sp
    9a34:	68 00 02             	push   $0x200
    9a37:	00 00                	add    %al,(%bx,%si)
    9a39:	e8 a6 33             	call   cde2 <mem_total+0x53>
    9a3c:	00 00                	add    %al,(%bx,%si)
    9a3e:	83 c4 10             	add    $0x10,%sp
    9a41:	a3 b0 ec             	mov    %ax,0xecb0
    9a44:	00 00                	add    %al,(%bx,%si)
    /* IDT初始化 */
    for (int i = 0; i < 64; ++i) {
    9a46:	c7 45 f4 00 00       	movw   $0x0,-0xc(%di)
    9a4b:	00 00                	add    %al,(%bx,%si)
    9a4d:	eb 20                	jmp    9a6f <init_gdt_idt+0xb7>
        set_gate_desc(idt + i, 0, 0, 0);
    9a4f:	a1 b0 ec             	mov    0xecb0,%ax
    9a52:	00 00                	add    %al,(%bx,%si)
    9a54:	8b 55 f4             	mov    -0xc(%di),%dx
    9a57:	c1 e2 03             	shl    $0x3,%dx
    9a5a:	01 d0                	add    %dx,%ax
    9a5c:	6a 00                	push   $0x0
    9a5e:	6a 00                	push   $0x0
    9a60:	6a 00                	push   $0x0
    9a62:	50                   	push   %ax
    9a63:	e8 65 01             	call   9bcb <set_seg_desc+0x83>
    9a66:	00 00                	add    %al,(%bx,%si)
    9a68:	83 c4 10             	add    $0x10,%sp
    for (int i = 0; i < 64; ++i) {
    9a6b:	83 45 f4 01          	addw   $0x1,-0xc(%di)
    9a6f:	83 7d f4 3f          	cmpw   $0x3f,-0xc(%di)
    9a73:	7e da                	jle    9a4f <init_gdt_idt+0x97>
    }
    set_gate_desc(idt + 0x21, (uint32_t )int_handler_kbd, 1 * 8, ATTR_INT_GATE);
    9a75:	ba 1e 80             	mov    $0x801e,%dx
    9a78:	00 00                	add    %al,(%bx,%si)
    9a7a:	a1 b0 ec             	mov    0xecb0,%ax
    9a7d:	00 00                	add    %al,(%bx,%si)
    9a7f:	05 08 01             	add    $0x108,%ax
    9a82:	00 00                	add    %al,(%bx,%si)
    9a84:	68 8e 00             	push   $0x8e
    9a87:	00 00                	add    %al,(%bx,%si)
    9a89:	6a 08                	push   $0x8
    9a8b:	52                   	push   %dx
    9a8c:	50                   	push   %ax
    9a8d:	e8 3b 01             	call   9bcb <set_seg_desc+0x83>
    9a90:	00 00                	add    %al,(%bx,%si)
    9a92:	83 c4 10             	add    $0x10,%sp
    set_gate_desc(idt + 0x2c, (uint32_t )int_handler_mouse, 1 * 8, ATTR_INT_GATE);
    9a95:	ba 36 80             	mov    $0x8036,%dx
    9a98:	00 00                	add    %al,(%bx,%si)
    9a9a:	a1 b0 ec             	mov    0xecb0,%ax
    9a9d:	00 00                	add    %al,(%bx,%si)
    9a9f:	05 60 01             	add    $0x160,%ax
    9aa2:	00 00                	add    %al,(%bx,%si)
    9aa4:	68 8e 00             	push   $0x8e
    9aa7:	00 00                	add    %al,(%bx,%si)
    9aa9:	6a 08                	push   $0x8
    9aab:	52                   	push   %dx
    9aac:	50                   	push   %ax
    9aad:	e8 1b 01             	call   9bcb <set_seg_desc+0x83>
    9ab0:	00 00                	add    %al,(%bx,%si)
    9ab2:	83 c4 10             	add    $0x10,%sp
    set_gate_desc(idt + 0x20, (uint32_t )int_handler_pit, 1 * 8, ATTR_INT_GATE);
    9ab5:	ba 4e 80             	mov    $0x804e,%dx
    9ab8:	00 00                	add    %al,(%bx,%si)
    9aba:	a1 b0 ec             	mov    0xecb0,%ax
    9abd:	00 00                	add    %al,(%bx,%si)
    9abf:	05 00 01             	add    $0x100,%ax
    9ac2:	00 00                	add    %al,(%bx,%si)
    9ac4:	68 8e 00             	push   $0x8e
    9ac7:	00 00                	add    %al,(%bx,%si)
    9ac9:	6a 08                	push   $0x8
    9acb:	52                   	push   %dx
    9acc:	50                   	push   %ax
    9acd:	e8 fb 00             	call   9bcb <set_seg_desc+0x83>
    9ad0:	00 00                	add    %al,(%bx,%si)
    9ad2:	83 c4 10             	add    $0x10,%sp
    set_gate_desc(idt + 0x27, (uint32_t )int_handler_noise, 1 * 8, ATTR_INT_GATE);
    9ad5:	ba 66 80             	mov    $0x8066,%dx
    9ad8:	00 00                	add    %al,(%bx,%si)
    9ada:	a1 b0 ec             	mov    0xecb0,%ax
    9add:	00 00                	add    %al,(%bx,%si)
    9adf:	05 38 01             	add    $0x138,%ax
    9ae2:	00 00                	add    %al,(%bx,%si)
    9ae4:	68 8e 00             	push   $0x8e
    9ae7:	00 00                	add    %al,(%bx,%si)
    9ae9:	6a 08                	push   $0x8
    9aeb:	52                   	push   %dx
    9aec:	50                   	push   %ax
    9aed:	e8 db 00             	call   9bcb <set_seg_desc+0x83>
    9af0:	00 00                	add    %al,(%bx,%si)
    9af2:	83 c4 10             	add    $0x10,%sp
    lidt((uint32_t)idt, sizeof(gate_desc_t)*IDT_COUNT);
    9af5:	a1 b0 ec             	mov    0xecb0,%ax
    9af8:	00 00                	add    %al,(%bx,%si)
    9afa:	83 ec 08             	sub    $0x8,%sp
    9afd:	68 00 02             	push   $0x200
    9b00:	00 00                	add    %al,(%bx,%si)
    9b02:	50                   	push   %ax
    9b03:	e8 88 fe             	call   998e <lgdt+0x26>
    9b06:	ff                   	(bad)
    9b07:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
    9b0b:	90                   	nop
    9b0c:	c9                   	leave
    9b0d:	c3                   	ret

00009b0e <create_seg_desc>:

void create_seg_desc(uint16_t index, uint32_t limit, uint32_t base, uint16_t attr){
    9b0e:	55                   	push   %bp
    9b0f:	89 e5                	mov    %sp,%bp
    9b11:	83 ec 18             	sub    $0x18,%sp
    9b14:	8b 55 08             	mov    0x8(%di),%dx
    9b17:	8b 45 14             	mov    0x14(%di),%ax
    9b1a:	66 89 55 f4          	mov    %edx,-0xc(%di)
    9b1e:	66 89 45 f0          	mov    %eax,-0x10(%di)
    set_seg_desc(gdt + index, limit, base, attr);
    9b22:	0f b7 45 f0          	movzww -0x10(%di),%ax
    9b26:	8b 15                	mov    (%di),%dx
    9b28:	ac                   	lods   %ds:(%si),%al
    9b29:	ec                   	in     (%dx),%al
    9b2a:	00 00                	add    %al,(%bx,%si)
    9b2c:	0f b7 4d f4          	movzww -0xc(%di),%cx
    9b30:	c1 e1 03             	shl    $0x3,%cx
    9b33:	01 ca                	add    %cx,%dx
    9b35:	50                   	push   %ax
    9b36:	ff 75 10             	push   0x10(%di)
    9b39:	ff 75 0c             	push   0xc(%di)
    9b3c:	52                   	push   %dx
    9b3d:	e8 06 00             	call   9b46 <create_seg_desc+0x38>
    9b40:	00 00                	add    %al,(%bx,%si)
    9b42:	83 c4 10             	add    $0x10,%sp
}
    9b45:	90                   	nop
    9b46:	c9                   	leave
    9b47:	c3                   	ret

00009b48 <set_seg_desc>:

void set_seg_desc(seg_desc_t *seg, uint32_t limit, uint32_t base, uint16_t attr){
    9b48:	55                   	push   %bp
    9b49:	89 e5                	mov    %sp,%bp
    9b4b:	83 ec 04             	sub    $0x4,%sp
    9b4e:	8b 45 14             	mov    0x14(%di),%ax
    9b51:	66 89 45 fc          	mov    %eax,-0x4(%di)
    if (limit > 0xfffff) {
    9b55:	81 7d 0c ff ff       	cmpw   $0xffff,0xc(%di)
    9b5a:	0f 00                	(bad)
    9b5c:	76 0f                	jbe    9b6d <set_seg_desc+0x25>
        attr |= 0x8000; /* G_bit = 1 */
    9b5e:	66 81 4d fc 00 80 8b 	orl    $0x458b8000,-0x4(%di)
    9b65:	45 
        limit /= 0x1000;
    9b66:	0c c1                	or     $0xc1,%al
    9b68:	e8 0c 89             	call   2477 <main-0x5b89>
    9b6b:	45                   	inc    %bp
    9b6c:	0c 8b                	or     $0x8b,%al
    }
    seg->limit_low    = limit & 0xffff;
    9b6e:	45                   	inc    %bp
    9b6f:	0c 89                	or     $0x89,%al
    9b71:	c2 8b 45             	ret    $0x458b
    9b74:	08 66 89             	or     %ah,-0x77(%bp)
    9b77:	10 8b 45 10          	adc    %cl,0x1045(%bp,%di)
    seg->base_low     = base & 0xffff;
    9b7b:	89 c2                	mov    %ax,%dx
    9b7d:	8b 45 08             	mov    0x8(%di),%ax
    9b80:	66 89 50 02          	mov    %edx,0x2(%bx,%si)
    seg->base_mid     = (base >> 16) & 0xff;
    9b84:	8b 45 10             	mov    0x10(%di),%ax
    9b87:	c1 e8 10             	shr    $0x10,%ax
    9b8a:	89 c2                	mov    %ax,%dx
    9b8c:	8b 45 08             	mov    0x8(%di),%ax
    9b8f:	88 50 04             	mov    %dl,0x4(%bx,%si)
    seg->access_right = attr & 0xff;
    9b92:	0f b7 45 fc          	movzww -0x4(%di),%ax
    9b96:	89 c2                	mov    %ax,%dx
    9b98:	8b 45 08             	mov    0x8(%di),%ax
    9b9b:	88 50 05             	mov    %dl,0x5(%bx,%si)
    seg->limit_high   = ((limit >> 16) & 0x0f) | ((attr >> 8) & 0xf0);
    9b9e:	8b 45 0c             	mov    0xc(%di),%ax
    9ba1:	c1 e8 10             	shr    $0x10,%ax
    9ba4:	83 e0 0f             	and    $0xf,%ax
    9ba7:	89 c2                	mov    %ax,%dx
    9ba9:	0f b7 45 fc          	movzww -0x4(%di),%ax
    9bad:	66 c1 e8 08          	shr    $0x8,%eax
    9bb1:	83 e0 f0             	and    $0xfff0,%ax
    9bb4:	09 c2                	or     %ax,%dx
    9bb6:	8b 45 08             	mov    0x8(%di),%ax
    9bb9:	88 50 06             	mov    %dl,0x6(%bx,%si)
    seg->base_high    = (base >> 24) & 0xff;
    9bbc:	8b 45 10             	mov    0x10(%di),%ax
    9bbf:	c1 e8 18             	shr    $0x18,%ax
    9bc2:	89 c2                	mov    %ax,%dx
    9bc4:	8b 45 08             	mov    0x8(%di),%ax
    9bc7:	88 50 07             	mov    %dl,0x7(%bx,%si)
}
    9bca:	90                   	nop
    9bcb:	c9                   	leave
    9bcc:	c3                   	ret

00009bcd <set_gate_desc>:

void set_gate_desc(gate_desc_t *gate, uint32_t offset, uint16_t selector, uint16_t attr){
    9bcd:	55                   	push   %bp
    9bce:	89 e5                	mov    %sp,%bp
    9bd0:	83 ec 08             	sub    $0x8,%sp
    9bd3:	8b 55 10             	mov    0x10(%di),%dx
    9bd6:	8b 45 14             	mov    0x14(%di),%ax
    9bd9:	66 89 55 fc          	mov    %edx,-0x4(%di)
    9bdd:	66 89 45 f8          	mov    %eax,-0x8(%di)
    gate->offset_low   = offset & 0xffff;
    9be1:	8b 45 0c             	mov    0xc(%di),%ax
    9be4:	89 c2                	mov    %ax,%dx
    9be6:	8b 45 08             	mov    0x8(%di),%ax
    9be9:	66 89 10             	mov    %edx,(%bx,%si)
    gate->selector     = selector;
    9bec:	8b 45 08             	mov    0x8(%di),%ax
    9bef:	0f b7 55 fc          	movzww -0x4(%di),%dx
    9bf3:	66 89 50 02          	mov    %edx,0x2(%bx,%si)
    gate->dw_count     = (attr >> 8) & 0xff;
    9bf7:	0f b7 45 f8          	movzww -0x8(%di),%ax
    9bfb:	66 c1 e8 08          	shr    $0x8,%eax
    9bff:	89 c2                	mov    %ax,%dx
    9c01:	8b 45 08             	mov    0x8(%di),%ax
    9c04:	88 50 04             	mov    %dl,0x4(%bx,%si)
    gate->access_right = attr & 0xff;
    9c07:	0f b7 45 f8          	movzww -0x8(%di),%ax
    9c0b:	89 c2                	mov    %ax,%dx
    9c0d:	8b 45 08             	mov    0x8(%di),%ax
    9c10:	88 50 05             	mov    %dl,0x5(%bx,%si)
    gate->offset_high  = (offset >> 16) & 0xffff;
    9c13:	8b 45 0c             	mov    0xc(%di),%ax
    9c16:	c1 e8 10             	shr    $0x10,%ax
    9c19:	89 c2                	mov    %ax,%dx
    9c1b:	8b 45 08             	mov    0x8(%di),%ax
    9c1e:	66 89 50 06          	mov    %edx,0x6(%bx,%si)
    9c22:	90                   	nop
    9c23:	c9                   	leave
    9c24:	c3                   	ret

00009c25 <inb>:
static inline uint8_t inb(uint16_t  port) {
    9c25:	55                   	push   %bp
    9c26:	89 e5                	mov    %sp,%bp
    9c28:	83 ec 14             	sub    $0x14,%sp
    9c2b:	8b 45 08             	mov    0x8(%di),%ax
    9c2e:	66 89 45 ec          	mov    %eax,-0x14(%di)
	__asm__ __volatile__("inb %[p], %[v]" : [v]"=a" (rv) : [p]"d"(port));
    9c32:	0f b7 45 ec          	movzww -0x14(%di),%ax
    9c36:	89 c2                	mov    %ax,%dx
    9c38:	ec                   	in     (%dx),%al
    9c39:	88 45 ff             	mov    %al,-0x1(%di)
	return rv;
    9c3c:	0f b6 45 ff          	movzbw -0x1(%di),%ax
}
    9c40:	c9                   	leave
    9c41:	c3                   	ret

00009c42 <outb>:
static inline void outb(uint16_t port, uint8_t data) {
    9c42:	55                   	push   %bp
    9c43:	89 e5                	mov    %sp,%bp
    9c45:	83 ec 08             	sub    $0x8,%sp
    9c48:	8b 55 08             	mov    0x8(%di),%dx
    9c4b:	8b 45 0c             	mov    0xc(%di),%ax
    9c4e:	66 89 55 fc          	mov    %edx,-0x4(%di)
    9c52:	88 45 f8             	mov    %al,-0x8(%di)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
    9c55:	0f b7 55 fc          	movzww -0x4(%di),%dx
    9c59:	0f b6 45 f8          	movzbw -0x8(%di),%ax
    9c5d:	ee                   	out    %al,(%dx)
}
    9c5e:	90                   	nop
    9c5f:	c9                   	leave
    9c60:	c3                   	ret

00009c61 <clump>:
static inline int clump(int val,int max,int min) {
    9c61:	55                   	push   %bp
    9c62:	89 e5                	mov    %sp,%bp
    if(val<min){
    9c64:	8b 45 08             	mov    0x8(%di),%ax
    9c67:	3b 45 10             	cmp    0x10(%di),%ax
    9c6a:	7d 05                	jge    9c71 <clump+0x10>
        return min;
    9c6c:	8b 45 10             	mov    0x10(%di),%ax
    9c6f:	eb 10                	jmp    9c81 <clump+0x20>
    if(val>max){
    9c71:	8b 45 08             	mov    0x8(%di),%ax
    9c74:	3b 45 0c             	cmp    0xc(%di),%ax
    9c77:	7e 05                	jle    9c7e <clump+0x1d>
        return max;
    9c79:	8b 45 0c             	mov    0xc(%di),%ax
    9c7c:	eb 03                	jmp    9c81 <clump+0x20>
    return val;
    9c7e:	8b 45 08             	mov    0x8(%di),%ax
}
    9c81:	5d                   	pop    %bp
    9c82:	c3                   	ret

00009c83 <wait_kbd_ready>:
#include "comm/math.h"

mouse_t mouse;

/* 等待键盘控制电路准备完毕 */
void wait_kbd_ready(){
    9c83:	55                   	push   %bp
    9c84:	89 e5                	mov    %sp,%bp
    for (;;) {
        if (!(inb(PORT_KBD_STA) & KBD_NOT_READY)) {
    9c86:	6a 64                	push   $0x64
    9c88:	e8 98 ff             	call   9c23 <set_gate_desc+0x56>
    9c8b:	ff                   	(bad)
    9c8c:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
    9c90:	0f b6 c0             	movzbw %al,%ax
    9c93:	83 e0 02             	and    $0x2,%ax
    9c96:	85 c0                	test   %ax,%ax
    9c98:	74 02                	je     9c9c <wait_kbd_ready+0x19>
    9c9a:	eb ea                	jmp    9c86 <wait_kbd_ready+0x3>
            break;
    9c9c:	90                   	nop
        }
    }
}
    9c9d:	90                   	nop
    9c9e:	c9                   	leave
    9c9f:	c3                   	ret

00009ca0 <init_kbd>:

/* 初始化键盘控制电路 */
void init_kbd() {
    9ca0:	55                   	push   %bp
    9ca1:	89 e5                	mov    %sp,%bp
    wait_kbd_ready();
    9ca3:	e8 db ff             	call   9c81 <clump+0x20>
    9ca6:	ff                   	(bad)
    9ca7:	ff 6a 60             	ljmp   *0x60(%bp,%si)
    outb(PORT_KBD_CMD, KBD_WRITE_MODE);
    9caa:	6a 64                	push   $0x64
    9cac:	e8 91 ff             	call   9c40 <inb+0x1b>
    9caf:	ff                   	(bad)
    9cb0:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    wait_kbd_ready();
    9cb4:	e8 ca ff             	call   9c81 <clump+0x20>
    9cb7:	ff                   	(bad)
    9cb8:	ff 6a 47             	ljmp   *0x47(%bp,%si)
    outb(PORT_KBD_DAT, KBC_MODE);
    9cbb:	6a 60                	push   $0x60
    9cbd:	e8 80 ff             	call   9c40 <inb+0x1b>
    9cc0:	ff                   	(bad)
    9cc1:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
}
    9cc5:	90                   	nop
    9cc6:	c9                   	leave
    9cc7:	c3                   	ret

00009cc8 <init_mouse>:

/* 激活鼠标 */
void init_mouse(){
    9cc8:	55                   	push   %bp
    9cc9:	89 e5                	mov    %sp,%bp
    wait_kbd_ready();
    9ccb:	e8 b3 ff             	call   9c81 <clump+0x20>
    9cce:	ff                   	(bad)
    9ccf:	ff 68 d4             	ljmp   *-0x2c(%bx,%si)
    outb(PORT_KBD_CMD, KBD_TO_MOUSE);
    9cd2:	00 00                	add    %al,(%bx,%si)
    9cd4:	00 6a 64             	add    %ch,0x64(%bp,%si)
    9cd7:	e8 66 ff             	call   9c40 <inb+0x1b>
    9cda:	ff                   	(bad)
    9cdb:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    wait_kbd_ready();
    9cdf:	e8 9f ff             	call   9c81 <clump+0x20>
    9ce2:	ff                   	(bad)
    9ce3:	ff 68 f4             	ljmp   *-0xc(%bx,%si)
    // 准备好后会立即触发一个中断  0xfa
    outb(PORT_KBD_DAT, MOUSE_ENABLE);
    9ce6:	00 00                	add    %al,(%bx,%si)
    9ce8:	00 6a 60             	add    %ch,0x60(%bp,%si)
    9ceb:	e8 52 ff             	call   9c40 <inb+0x1b>
    9cee:	ff                   	(bad)
    9cef:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    mouse.state=-1;// 默认设置为没有准备完毕
    9cf3:	c6 05 b4             	movb   $0xb4,(%di)
    9cf6:	ec                   	in     (%dx),%al
    9cf7:	00 00                	add    %al,(%bx,%si)
    9cf9:	ff c7                	inc    %di
    mouse.x= SCREEN_W / 2;
    9cfb:	05 c4 ec             	add    $0xecc4,%ax
    9cfe:	00 00                	add    %al,(%bx,%si)
    9d00:	a0 00 00             	mov    0x0,%al
    9d03:	00 c7                	add    %al,%bh
    mouse.y= SCREEN_H / 2;
    9d05:	05 c8 ec             	add    $0xecc8,%ax
    9d08:	00 00                	add    %al,(%bx,%si)
    9d0a:	64 00 00             	add    %al,%fs:(%bx,%si)
    9d0d:	00 90 c9 c3          	add    %dl,-0x3c37(%bx,%si)

00009d11 <mouse_decode>:
}

bool_t mouse_decode(uint8_t data){
    9d11:	55                   	push   %bp
    9d12:	89 e5                	mov    %sp,%bp
    9d14:	83 ec 04             	sub    $0x4,%sp
    9d17:	8b 45 08             	mov    0x8(%di),%ax
    9d1a:	88 45 fc             	mov    %al,-0x4(%di)
    if(mouse.state==-1){// 没有激活等待激活
    9d1d:	0f b6 05             	movzbw (%di),%ax
    9d20:	b4 ec                	mov    $0xec,%ah
    9d22:	00 00                	add    %al,(%bx,%si)
    9d24:	3c ff                	cmp    $0xff,%al
    9d26:	75 16                	jne    9d3e <mouse_decode+0x2d>
        if(data==0xfa){
    9d28:	80 7d fc fa          	cmpb   $0xfa,-0x4(%di)
    9d2c:	0f 85 28 01          	jne    9e58 <mouse_decode+0x147>
    9d30:	00 00                	add    %al,(%bx,%si)
            mouse.state=0;
    9d32:	c6 05 b4             	movb   $0xb4,(%di)
    9d35:	ec                   	in     (%dx),%al
    9d36:	00 00                	add    %al,(%bx,%si)
    9d38:	00 e9                	add    %ch,%cl
    9d3a:	1c 01                	sbb    $0x1,%al
    9d3c:	00 00                	add    %al,(%bx,%si)
        }
    } else{// 激活了收集数据 3个一组
        if(mouse.state==0&&(data&0xc8)!=0x08){
    9d3e:	0f b6 05             	movzbw (%di),%ax
    9d41:	b4 ec                	mov    $0xec,%ah
    9d43:	00 00                	add    %al,(%bx,%si)
    9d45:	84 c0                	test   %al,%al
    9d47:	75 18                	jne    9d61 <mouse_decode+0x50>
    9d49:	0f b6 45 fc          	movzbw -0x4(%di),%ax
    9d4d:	25 c8 00             	and    $0xc8,%ax
    9d50:	00 00                	add    %al,(%bx,%si)
    9d52:	83 f8 08             	cmp    $0x8,%ax
    9d55:	74 0a                	je     9d61 <mouse_decode+0x50>
            return FALSE; // 第一个字节主要记录键位信息 需要保证其合法性  鼠标信息可能断连导致数据错位使用这个校验
    9d57:	b8 00 00             	mov    $0x0,%ax
    9d5a:	00 00                	add    %al,(%bx,%si)
    9d5c:	e9 fe 00             	jmp    9e5d <mouse_decode+0x14c>
    9d5f:	00 00                	add    %al,(%bx,%si)
        }
        mouse.buff[mouse.state++]=data;
    9d61:	0f b6 05             	movzbw (%di),%ax
    9d64:	b4 ec                	mov    $0xec,%ah
    9d66:	00 00                	add    %al,(%bx,%si)
    9d68:	89 c2                	mov    %ax,%dx
    9d6a:	83 c2 01             	add    $0x1,%dx
    9d6d:	88 15                	mov    %dl,(%di)
    9d6f:	b4 ec                	mov    $0xec,%ah
    9d71:	00 00                	add    %al,(%bx,%si)
    9d73:	0f be c0             	movsbw %al,%ax
    9d76:	0f b6 55 fc          	movzbw -0x4(%di),%dx
    9d7a:	88 90 b5 ec          	mov    %dl,-0x134b(%bx,%si)
    9d7e:	00 00                	add    %al,(%bx,%si)
        if(mouse.state>=3){// 开始解析数据
    9d80:	0f b6 05             	movzbw (%di),%ax
    9d83:	b4 ec                	mov    $0xec,%ah
    9d85:	00 00                	add    %al,(%bx,%si)
    9d87:	3c 02                	cmp    $0x2,%al
    9d89:	0f 8e cb 00          	jle    9e58 <mouse_decode+0x147>
    9d8d:	00 00                	add    %al,(%bx,%si)
            mouse.state=0;
    9d8f:	c6 05 b4             	movb   $0xb4,(%di)
    9d92:	ec                   	in     (%dx),%al
    9d93:	00 00                	add    %al,(%bx,%si)
    9d95:	00 0f                	add    %cl,(%bx)
            mouse.btn = mouse.buff[0] & 0x07; // 只放在了低3位
    9d97:	b6 05                	mov    $0x5,%dh
    9d99:	b5 ec                	mov    $0xec,%ch
    9d9b:	00 00                	add    %al,(%bx,%si)
    9d9d:	83 e0 07             	and    $0x7,%ax
    9da0:	a2 b8 ec             	mov    %al,0xecb8
    9da3:	00 00                	add    %al,(%bx,%si)
            mouse.offX = mouse.buff[1];
    9da5:	0f b6 05             	movzbw (%di),%ax
    9da8:	b6 ec                	mov    $0xec,%dh
    9daa:	00 00                	add    %al,(%bx,%si)
    9dac:	0f b6 c0             	movzbw %al,%ax
    9daf:	a3 bc ec             	mov    %ax,0xecbc
    9db2:	00 00                	add    %al,(%bx,%si)
            mouse.offY = mouse.buff[2];
    9db4:	0f b6 05             	movzbw (%di),%ax
    9db7:	b7 ec                	mov    $0xec,%bh
    9db9:	00 00                	add    %al,(%bx,%si)
    9dbb:	0f b6 c0             	movzbw %al,%ax
    9dbe:	a3 c0 ec             	mov    %ax,0xecc0
    9dc1:	00 00                	add    %al,(%bx,%si)
            // 处理负数
            if ((mouse.buff[0] & 0x10) != 0) {
    9dc3:	0f b6 05             	movzbw (%di),%ax
    9dc6:	b5 ec                	mov    $0xec,%ch
    9dc8:	00 00                	add    %al,(%bx,%si)
    9dca:	0f b6 c0             	movzbw %al,%ax
    9dcd:	83 e0 10             	and    $0x10,%ax
    9dd0:	85 c0                	test   %ax,%ax
    9dd2:	74 0f                	je     9de3 <mouse_decode+0xd2>
                mouse.offX |= 0xffffff00;
    9dd4:	a1 bc ec             	mov    0xecbc,%ax
    9dd7:	00 00                	add    %al,(%bx,%si)
    9dd9:	0d 00 ff             	or     $0xff00,%ax
    9ddc:	ff                   	(bad)
    9ddd:	ff a3 bc ec          	jmp    *-0x1344(%bp,%di)
    9de1:	00 00                	add    %al,(%bx,%si)
            }
            if ((mouse.buff[0] & 0x20) != 0) {
    9de3:	0f b6 05             	movzbw (%di),%ax
    9de6:	b5 ec                	mov    $0xec,%ch
    9de8:	00 00                	add    %al,(%bx,%si)
    9dea:	0f b6 c0             	movzbw %al,%ax
    9ded:	83 e0 20             	and    $0x20,%ax
    9df0:	85 c0                	test   %ax,%ax
    9df2:	74 0f                	je     9e03 <mouse_decode+0xf2>
                mouse.offY |= 0xffffff00;
    9df4:	a1 c0 ec             	mov    0xecc0,%ax
    9df7:	00 00                	add    %al,(%bx,%si)
    9df9:	0d 00 ff             	or     $0xff00,%ax
    9dfc:	ff                   	(bad)
    9dfd:	ff a3 c0 ec          	jmp    *-0x1340(%bp,%di)
    9e01:	00 00                	add    %al,(%bx,%si)
            }
            /* 鼠标的y方向与画面符号相反 */
            mouse.offY = - mouse.offY;
    9e03:	a1 c0 ec             	mov    0xecc0,%ax
    9e06:	00 00                	add    %al,(%bx,%si)
    9e08:	f7 d8                	neg    %ax
    9e0a:	a3 c0 ec             	mov    %ax,0xecc0
    9e0d:	00 00                	add    %al,(%bx,%si)
            mouse.x= clump(mouse.x+mouse.offX, SCREEN_W, 0);
    9e0f:	8b 15                	mov    (%di),%dx
    9e11:	c4                   	(bad)
    9e12:	ec                   	in     (%dx),%al
    9e13:	00 00                	add    %al,(%bx,%si)
    9e15:	a1 bc ec             	mov    0xecbc,%ax
    9e18:	00 00                	add    %al,(%bx,%si)
    9e1a:	01 d0                	add    %dx,%ax
    9e1c:	6a 00                	push   $0x0
    9e1e:	68 40 01             	push   $0x140
    9e21:	00 00                	add    %al,(%bx,%si)
    9e23:	50                   	push   %ax
    9e24:	e8 38 fe             	call   9c5f <outb+0x1d>
    9e27:	ff                   	(bad)
    9e28:	ff 83 c4 0c          	incw   0xcc4(%bp,%di)
    9e2c:	a3 c4 ec             	mov    %ax,0xecc4
    9e2f:	00 00                	add    %al,(%bx,%si)
            mouse.y=clump(mouse.y+mouse.offY, SCREEN_H, 0);
    9e31:	8b 15                	mov    (%di),%dx
    9e33:	c8 ec 00 00          	enter  $0xec,$0x0
    9e37:	a1 c0 ec             	mov    0xecc0,%ax
    9e3a:	00 00                	add    %al,(%bx,%si)
    9e3c:	01 d0                	add    %dx,%ax
    9e3e:	6a 00                	push   $0x0
    9e40:	68 c8 00             	push   $0xc8
    9e43:	00 00                	add    %al,(%bx,%si)
    9e45:	50                   	push   %ax
    9e46:	e8 16 fe             	call   9c5f <outb+0x1d>
    9e49:	ff                   	(bad)
    9e4a:	ff 83 c4 0c          	incw   0xcc4(%bp,%di)
    9e4e:	a3 c8 ec             	mov    %ax,0xecc8
    9e51:	00 00                	add    %al,(%bx,%si)
            return TRUE;
    9e53:	b8 01 00             	mov    $0x1,%ax
    9e56:	00 00                	add    %al,(%bx,%si)
    9e58:	eb 05                	jmp    9e5f <mouse_decode+0x14e>
        }
    }
    return FALSE;
    9e5a:	b8 00 00             	mov    $0x0,%ax
    9e5d:	00 00                	add    %al,(%bx,%si)
}
    9e5f:	c9                   	leave
    9e60:	c3                   	ret

00009e61 <init_pit>:

void init_pit(){
    9e61:	55                   	push   %bp
    9e62:	89 e5                	mov    %sp,%bp
    // 先准备设置中断间隔，然后依次写入中断间隔
    outb(PIT_CTRL,0x34);
    9e64:	6a 34                	push   $0x34
    9e66:	6a 43                	push   $0x43
    9e68:	e8 d5 fd             	call   9c40 <inb+0x1b>
    9e6b:	ff                   	(bad)
    9e6c:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    // 设置为 1秒100次中断
    outb(PIT_CNT0,0x9c);
    9e70:	68 9c 00             	push   $0x9c
    9e73:	00 00                	add    %al,(%bx,%si)
    9e75:	6a 40                	push   $0x40
    9e77:	e8 c6 fd             	call   9c40 <inb+0x1b>
    9e7a:	ff                   	(bad)
    9e7b:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(PIT_CNT0,0x2e);
    9e7f:	6a 2e                	push   $0x2e
    9e81:	6a 40                	push   $0x40
    9e83:	e8 ba fd             	call   9c40 <inb+0x1b>
    9e86:	ff                   	(bad)
    9e87:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
}
    9e8b:	90                   	nop
    9e8c:	c9                   	leave
    9e8d:	c3                   	ret

00009e8e <beep>:

// qemu 没有蜂鸣器
void beep(uint32_t hz){
    9e8e:	55                   	push   %bp
    9e8f:	89 e5                	mov    %sp,%bp
    9e91:	83 ec 10             	sub    $0x10,%sp
    if(hz<20000||hz>20000000){
    9e94:	81 7d 08 1f 4e       	cmpw   $0x4e1f,0x8(%di)
    9e99:	00 00                	add    %al,(%bx,%si)
    9e9b:	76 09                	jbe    9ea6 <beep+0x18>
    9e9d:	81 7d 08 00 2d       	cmpw   $0x2d00,0x8(%di)
    9ea2:	31 01                	xor    %ax,(%bx,%di)
    9ea4:	76 21                	jbe    9ec7 <beep+0x39>
        // 关闭设备
       uint8_t sign= inb(0x61);
    9ea6:	6a 61                	push   $0x61
    9ea8:	e8 78 fd             	call   9c23 <set_gate_desc+0x56>
    9eab:	ff                   	(bad)
    9eac:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
    9eb0:	88 45 fe             	mov    %al,-0x2(%di)
        outb(0x61,sign&0x0d);
    9eb3:	0f b6 45 fe          	movzbw -0x2(%di),%ax
    9eb7:	83 e0 0d             	and    $0xd,%ax
    9eba:	50                   	push   %ax
    9ebb:	6a 61                	push   $0x61
    9ebd:	e8 80 fd             	call   9c40 <inb+0x1b>
    9ec0:	ff                   	(bad)
    9ec1:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    if(hz<20000||hz>20000000){
    9ec5:	eb 6a                	jmp    9f31 <beep+0xa3>
    } else{
        hz=1193180000/hz;
    9ec7:	b8 60 7b             	mov    $0x7b60,%ax
    9eca:	1e                   	push   %ds
    9ecb:	47                   	inc    %di
    9ecc:	ba 00 00             	mov    $0x0,%dx
    9ecf:	00 00                	add    %al,(%bx,%si)
    9ed1:	f7 75 08             	divw   0x8(%di)
    9ed4:	89 45 08             	mov    %ax,0x8(%di)
        outb(0x43,0xb6); // 开始设置音高
    9ed7:	68 b6 00             	push   $0xb6
    9eda:	00 00                	add    %al,(%bx,%si)
    9edc:	6a 43                	push   $0x43
    9ede:	e8 5f fd             	call   9c40 <inb+0x1b>
    9ee1:	ff                   	(bad)
    9ee2:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
        // 先设置低8位再设置高8位
        outb(0x42,hz&0xff);
    9ee6:	8b 45 08             	mov    0x8(%di),%ax
    9ee9:	0f b6 c0             	movzbw %al,%ax
    9eec:	50                   	push   %ax
    9eed:	6a 42                	push   $0x42
    9eef:	e8 4e fd             	call   9c40 <inb+0x1b>
    9ef2:	ff                   	(bad)
    9ef3:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
        outb(0x42,(hz>>8)&0xff);
    9ef7:	8b 45 08             	mov    0x8(%di),%ax
    9efa:	c1 e8 08             	shr    $0x8,%ax
    9efd:	0f b6 c0             	movzbw %al,%ax
    9f00:	50                   	push   %ax
    9f01:	6a 42                	push   $0x42
    9f03:	e8 3a fd             	call   9c40 <inb+0x1b>
    9f06:	ff                   	(bad)
    9f07:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
        // 打开设备
        uint8_t sign= inb(0x61);
    9f0b:	6a 61                	push   $0x61
    9f0d:	e8 13 fd             	call   9c23 <set_gate_desc+0x56>
    9f10:	ff                   	(bad)
    9f11:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
    9f15:	88 45 ff             	mov    %al,-0x1(%di)
        outb(0x61,(sign|0x03)&0x0f);
    9f18:	0f b6 45 ff          	movzbw -0x1(%di),%ax
    9f1c:	83 c8 03             	or     $0x3,%ax
    9f1f:	0f b6 c0             	movzbw %al,%ax
    9f22:	83 e0 0f             	and    $0xf,%ax
    9f25:	50                   	push   %ax
    9f26:	6a 61                	push   $0x61
    9f28:	e8 15 fd             	call   9c40 <inb+0x1b>
    9f2b:	ff                   	(bad)
    9f2c:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    }
    9f30:	90                   	nop
    9f31:	90                   	nop
    9f32:	c9                   	leave
    9f33:	c3                   	ret

00009f34 <fifo_init>:
#include "fifo.h"
#include "mem.h"

void fifo_init(fifo_t *fifo,uint16_t size){
    9f34:	55                   	push   %bp
    9f35:	89 e5                	mov    %sp,%bp
    9f37:	83 ec 18             	sub    $0x18,%sp
    9f3a:	8b 45 0c             	mov    0xc(%di),%ax
    9f3d:	66 89 45 f4          	mov    %eax,-0xc(%di)
    fifo->count=0;
    9f41:	8b 45 08             	mov    0x8(%di),%ax
    9f44:	66 c7 40 08 00 00 8b 	movl   $0x458b0000,0x8(%bx,%si)
    9f4b:	45 
    fifo->read=0;
    9f4c:	08 66 c7             	or     %ah,-0x39(%bp)
    9f4f:	40                   	inc    %ax
    9f50:	04 00                	add    $0x0,%al
    9f52:	00 8b 45 08          	add    %cl,0x845(%bp,%di)
    fifo->write=0;
    9f56:	66 c7 40 06 00 00 8b 	movl   $0x458b0000,0x6(%bx,%si)
    9f5d:	45 
    fifo->size=size;
    9f5e:	08 0f                	or     %cl,(%bx)
    9f60:	b7 55                	mov    $0x55,%bh
    9f62:	f4                   	hlt
    9f63:	66 89 50 0a          	mov    %edx,0xa(%bx,%si)
    fifo->data= mem_alloc(size* sizeof(uint32_t));
    9f67:	0f b7 45 f4          	movzww -0xc(%di),%ax
    9f6b:	c1 e0 02             	shl    $0x2,%ax
    9f6e:	83 ec 0c             	sub    $0xc,%sp
    9f71:	50                   	push   %ax
    9f72:	e8 6d 2e             	call   cde2 <mem_total+0x53>
    9f75:	00 00                	add    %al,(%bx,%si)
    9f77:	83 c4 10             	add    $0x10,%sp
    9f7a:	8b 55 08             	mov    0x8(%di),%dx
    9f7d:	89 02                	mov    %ax,(%bp,%si)
}
    9f7f:	90                   	nop
    9f80:	c9                   	leave
    9f81:	c3                   	ret

00009f82 <fifo_free>:

void fifo_free(fifo_t *fifo){
    9f82:	55                   	push   %bp
    9f83:	89 e5                	mov    %sp,%bp
    9f85:	83 ec 08             	sub    $0x8,%sp
    mem_free(fifo->data,fifo->size* sizeof(uint32_t));
    9f88:	8b 45 08             	mov    0x8(%di),%ax
    9f8b:	0f b7 40 0a          	movzww 0xa(%bx,%si),%ax
    9f8f:	0f b7 c0             	movzww %ax,%ax
    9f92:	8d 14                	lea    (%si),%dx
    9f94:	85 00                	test   %ax,(%bx,%si)
    9f96:	00 00                	add    %al,(%bx,%si)
    9f98:	00 8b 45 08          	add    %cl,0x845(%bp,%di)
    9f9c:	8b 00                	mov    (%bx,%si),%ax
    9f9e:	83 ec 08             	sub    $0x8,%sp
    9fa1:	52                   	push   %dx
    9fa2:	50                   	push   %ax
    9fa3:	e8 39 2f             	call   cedf <mem_alloc+0xfb>
    9fa6:	00 00                	add    %al,(%bx,%si)
    9fa8:	83 c4 10             	add    $0x10,%sp
}
    9fab:	90                   	nop
    9fac:	c9                   	leave
    9fad:	c3                   	ret

00009fae <fifo_can_read>:

bool_t fifo_can_read(fifo_t *fifo){
    9fae:	55                   	push   %bp
    9faf:	89 e5                	mov    %sp,%bp
    return fifo->count>0;
    9fb1:	8b 45 08             	mov    0x8(%di),%ax
    9fb4:	0f b7 40 08          	movzww 0x8(%bx,%si),%ax
    9fb8:	66 85 c0             	test   %eax,%eax
    9fbb:	0f 95 c0             	setne  %al
    9fbe:	0f b6 c0             	movzbw %al,%ax
}
    9fc1:	5d                   	pop    %bp
    9fc2:	c3                   	ret

00009fc3 <fifo_can_write>:

bool_t fifo_can_write(fifo_t *fifo){
    9fc3:	55                   	push   %bp
    9fc4:	89 e5                	mov    %sp,%bp
    return fifo->count<fifo->size;
    9fc6:	8b 45 08             	mov    0x8(%di),%ax
    9fc9:	0f b7 50 08          	movzww 0x8(%bx,%si),%dx
    9fcd:	8b 45 08             	mov    0x8(%di),%ax
    9fd0:	0f b7 40 0a          	movzww 0xa(%bx,%si),%ax
    9fd4:	66 39 c2             	cmp    %eax,%edx
    9fd7:	0f 92 c0             	setb   %al
    9fda:	0f b6 c0             	movzbw %al,%ax
}
    9fdd:	5d                   	pop    %bp
    9fde:	c3                   	ret

00009fdf <fifo_read>:

uint32_t fifo_read(fifo_t *fifo){
    9fdf:	55                   	push   %bp
    9fe0:	89 e5                	mov    %sp,%bp
    9fe2:	83 ec 10             	sub    $0x10,%sp
    fifo->count--;
    9fe5:	8b 45 08             	mov    0x8(%di),%ax
    9fe8:	0f b7 40 08          	movzww 0x8(%bx,%si),%ax
    9fec:	8d 50 ff             	lea    -0x1(%bx,%si),%dx
    9fef:	8b 45 08             	mov    0x8(%di),%ax
    9ff2:	66 89 50 08          	mov    %edx,0x8(%bx,%si)
    uint32_t res = fifo->data[fifo->read];
    9ff6:	8b 45 08             	mov    0x8(%di),%ax
    9ff9:	8b 10                	mov    (%bx,%si),%dx
    9ffb:	8b 45 08             	mov    0x8(%di),%ax
    9ffe:	0f b7 40 04          	movzww 0x4(%bx,%si),%ax
    a002:	0f b7 c0             	movzww %ax,%ax
    a005:	c1 e0 02             	shl    $0x2,%ax
    a008:	01 d0                	add    %dx,%ax
    a00a:	8b 00                	mov    (%bx,%si),%ax
    a00c:	89 45 fc             	mov    %ax,-0x4(%di)
    fifo->read=(fifo->read+1)%fifo->size;
    a00f:	8b 45 08             	mov    0x8(%di),%ax
    a012:	0f b7 40 04          	movzww 0x4(%bx,%si),%ax
    a016:	0f b7 c0             	movzww %ax,%ax
    a019:	8d 50 01             	lea    0x1(%bx,%si),%dx
    a01c:	8b 45 08             	mov    0x8(%di),%ax
    a01f:	0f b7 40 0a          	movzww 0xa(%bx,%si),%ax
    a023:	0f b7 c8             	movzww %ax,%cx
    a026:	89 d0                	mov    %dx,%ax
    a028:	99                   	cwtd
    a029:	f7 f9                	idiv   %cx
    a02b:	89 d0                	mov    %dx,%ax
    a02d:	89 c2                	mov    %ax,%dx
    a02f:	8b 45 08             	mov    0x8(%di),%ax
    a032:	66 89 50 04          	mov    %edx,0x4(%bx,%si)
    return res;
    a036:	8b 45 fc             	mov    -0x4(%di),%ax
}
    a039:	c9                   	leave
    a03a:	c3                   	ret

0000a03b <fifo_write>:

void fifo_write(fifo_t *fifo, uint32_t val){
    a03b:	55                   	push   %bp
    a03c:	89 e5                	mov    %sp,%bp
    fifo->count++;
    a03e:	8b 45 08             	mov    0x8(%di),%ax
    a041:	0f b7 40 08          	movzww 0x8(%bx,%si),%ax
    a045:	8d 50 01             	lea    0x1(%bx,%si),%dx
    a048:	8b 45 08             	mov    0x8(%di),%ax
    a04b:	66 89 50 08          	mov    %edx,0x8(%bx,%si)
    fifo->data[fifo->write]=val;
    a04f:	8b 45 08             	mov    0x8(%di),%ax
    a052:	8b 10                	mov    (%bx,%si),%dx
    a054:	8b 45 08             	mov    0x8(%di),%ax
    a057:	0f b7 40 06          	movzww 0x6(%bx,%si),%ax
    a05b:	0f b7 c0             	movzww %ax,%ax
    a05e:	c1 e0 02             	shl    $0x2,%ax
    a061:	01 c2                	add    %ax,%dx
    a063:	8b 45 0c             	mov    0xc(%di),%ax
    a066:	89 02                	mov    %ax,(%bp,%si)
    fifo->write=(fifo->write+1)%fifo->size;
    a068:	8b 45 08             	mov    0x8(%di),%ax
    a06b:	0f b7 40 06          	movzww 0x6(%bx,%si),%ax
    a06f:	0f b7 c0             	movzww %ax,%ax
    a072:	8d 50 01             	lea    0x1(%bx,%si),%dx
    a075:	8b 45 08             	mov    0x8(%di),%ax
    a078:	0f b7 40 0a          	movzww 0xa(%bx,%si),%ax
    a07c:	0f b7 c8             	movzww %ax,%cx
    a07f:	89 d0                	mov    %dx,%ax
    a081:	99                   	cwtd
    a082:	f7 f9                	idiv   %cx
    a084:	89 d0                	mov    %dx,%ax
    a086:	89 c2                	mov    %ax,%dx
    a088:	8b 45 08             	mov    0x8(%di),%ax
    a08b:	66 89 50 06          	mov    %edx,0x6(%bx,%si)
}
    a08f:	90                   	nop
    a090:	5d                   	pop    %bp
    a091:	c3                   	ret

0000a092 <inb>:
static inline uint8_t inb(uint16_t  port) {
    a092:	55                   	push   %bp
    a093:	89 e5                	mov    %sp,%bp
    a095:	83 ec 14             	sub    $0x14,%sp
    a098:	8b 45 08             	mov    0x8(%di),%ax
    a09b:	66 89 45 ec          	mov    %eax,-0x14(%di)
	__asm__ __volatile__("inb %[p], %[v]" : [v]"=a" (rv) : [p]"d"(port));
    a09f:	0f b7 45 ec          	movzww -0x14(%di),%ax
    a0a3:	89 c2                	mov    %ax,%dx
    a0a5:	ec                   	in     (%dx),%al
    a0a6:	88 45 ff             	mov    %al,-0x1(%di)
	return rv;
    a0a9:	0f b6 45 ff          	movzbw -0x1(%di),%ax
}
    a0ad:	c9                   	leave
    a0ae:	c3                   	ret

0000a0af <inw>:
static inline uint16_t inw(uint16_t  port) {
    a0af:	55                   	push   %bp
    a0b0:	89 e5                	mov    %sp,%bp
    a0b2:	83 ec 14             	sub    $0x14,%sp
    a0b5:	8b 45 08             	mov    0x8(%di),%ax
    a0b8:	66 89 45 ec          	mov    %eax,-0x14(%di)
	__asm__ __volatile__("in %1, %0" : "=a" (rv) : "dN" (port));
    a0bc:	0f b7 45 ec          	movzww -0x14(%di),%ax
    a0c0:	89 c2                	mov    %ax,%dx
    a0c2:	66 ed                	in     (%dx),%eax
    a0c4:	66 89 45 fe          	mov    %eax,-0x2(%di)
	return rv;
    a0c8:	0f b7 45 fe          	movzww -0x2(%di),%ax
}
    a0cc:	c9                   	leave
    a0cd:	c3                   	ret

0000a0ce <outb>:
static inline void outb(uint16_t port, uint8_t data) {
    a0ce:	55                   	push   %bp
    a0cf:	89 e5                	mov    %sp,%bp
    a0d1:	83 ec 08             	sub    $0x8,%sp
    a0d4:	8b 55 08             	mov    0x8(%di),%dx
    a0d7:	8b 45 0c             	mov    0xc(%di),%ax
    a0da:	66 89 55 fc          	mov    %edx,-0x4(%di)
    a0de:	88 45 f8             	mov    %al,-0x8(%di)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
    a0e1:	0f b7 55 fc          	movzww -0x4(%di),%dx
    a0e5:	0f b6 45 f8          	movzbw -0x8(%di),%ax
    a0e9:	ee                   	out    %al,(%dx)
}
    a0ea:	90                   	nop
    a0eb:	c9                   	leave
    a0ec:	c3                   	ret

0000a0ed <outw>:
static inline void outw(uint16_t port, uint16_t data) {
    a0ed:	55                   	push   %bp
    a0ee:	89 e5                	mov    %sp,%bp
    a0f0:	83 ec 08             	sub    $0x8,%sp
    a0f3:	8b 55 08             	mov    0x8(%di),%dx
    a0f6:	8b 45 0c             	mov    0xc(%di),%ax
    a0f9:	66 89 55 fc          	mov    %edx,-0x4(%di)
    a0fd:	66 89 45 f8          	mov    %eax,-0x8(%di)
	__asm__ __volatile__("out %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
    a101:	0f b7 55 fc          	movzww -0x4(%di),%dx
    a105:	0f b7 45 f8          	movzww -0x8(%di),%ax
    a109:	66 ef                	out    %eax,(%dx)
}
    a10b:	90                   	nop
    a10c:	c9                   	leave
    a10d:	c3                   	ret

0000a10e <disk_cmd>:
#include "comm/cpu_instr.h"
#include "comm/config.h"
#include "mem.h"
#include "tool.h"

void disk_cmd(uint32_t sector,uint32_t count,uint8_t cmd){
    a10e:	55                   	push   %bp
    a10f:	89 e5                	mov    %sp,%bp
    a111:	83 ec 04             	sub    $0x4,%sp
    a114:	8b 45 10             	mov    0x10(%di),%ax
    a117:	88 45 fc             	mov    %al,-0x4(%di)
    outb(0x1F6, (uint8_t) 0xE0);
    a11a:	68 e0 00             	push   $0xe0
    a11d:	00 00                	add    %al,(%bx,%si)
    a11f:	68 f6 01             	push   $0x1f6
    a122:	00 00                	add    %al,(%bx,%si)
    a124:	e8 a5 ff             	call   a0cc <inw+0x1d>
    a127:	ff                   	(bad)
    a128:	ff 83 c4 08          	incw   0x8c4(%bp,%di)

    outb(0x1F2, (uint8_t) (count >> 8));
    a12c:	8b 45 0c             	mov    0xc(%di),%ax
    a12f:	c1 e8 08             	shr    $0x8,%ax
    a132:	0f b6 c0             	movzbw %al,%ax
    a135:	50                   	push   %ax
    a136:	68 f2 01             	push   $0x1f2
    a139:	00 00                	add    %al,(%bx,%si)
    a13b:	e8 8e ff             	call   a0cc <inw+0x1d>
    a13e:	ff                   	(bad)
    a13f:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(0x1F3, (uint8_t) (sector >> 24));		// LBA参数的24~31位
    a143:	8b 45 08             	mov    0x8(%di),%ax
    a146:	c1 e8 18             	shr    $0x18,%ax
    a149:	0f b6 c0             	movzbw %al,%ax
    a14c:	50                   	push   %ax
    a14d:	68 f3 01             	push   $0x1f3
    a150:	00 00                	add    %al,(%bx,%si)
    a152:	e8 77 ff             	call   a0cc <inw+0x1d>
    a155:	ff                   	(bad)
    a156:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(0x1F4, (uint8_t) (0));					// LBA参数的32~39位
    a15a:	6a 00                	push   $0x0
    a15c:	68 f4 01             	push   $0x1f4
    a15f:	00 00                	add    %al,(%bx,%si)
    a161:	e8 68 ff             	call   a0cc <inw+0x1d>
    a164:	ff                   	(bad)
    a165:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(0x1F5, (uint8_t) (0));					// LBA参数的40~47位
    a169:	6a 00                	push   $0x0
    a16b:	68 f5 01             	push   $0x1f5
    a16e:	00 00                	add    %al,(%bx,%si)
    a170:	e8 59 ff             	call   a0cc <inw+0x1d>
    a173:	ff                   	(bad)
    a174:	ff 83 c4 08          	incw   0x8c4(%bp,%di)

    outb(0x1F2, (uint8_t) count);
    a178:	8b 45 0c             	mov    0xc(%di),%ax
    a17b:	0f b6 c0             	movzbw %al,%ax
    a17e:	50                   	push   %ax
    a17f:	68 f2 01             	push   $0x1f2
    a182:	00 00                	add    %al,(%bx,%si)
    a184:	e8 45 ff             	call   a0cc <inw+0x1d>
    a187:	ff                   	(bad)
    a188:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(0x1F3, (uint8_t) sector);			// LBA参数的0~7位
    a18c:	8b 45 08             	mov    0x8(%di),%ax
    a18f:	0f b6 c0             	movzbw %al,%ax
    a192:	50                   	push   %ax
    a193:	68 f3 01             	push   $0x1f3
    a196:	00 00                	add    %al,(%bx,%si)
    a198:	e8 31 ff             	call   a0cc <inw+0x1d>
    a19b:	ff                   	(bad)
    a19c:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(0x1F4, (uint8_t) (sector >> 8));		// LBA参数的8~15位
    a1a0:	8b 45 08             	mov    0x8(%di),%ax
    a1a3:	c1 e8 08             	shr    $0x8,%ax
    a1a6:	0f b6 c0             	movzbw %al,%ax
    a1a9:	50                   	push   %ax
    a1aa:	68 f4 01             	push   $0x1f4
    a1ad:	00 00                	add    %al,(%bx,%si)
    a1af:	e8 1a ff             	call   a0cc <inw+0x1d>
    a1b2:	ff                   	(bad)
    a1b3:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(0x1F5, (uint8_t) (sector >> 16));		// LBA参数的16~23位
    a1b7:	8b 45 08             	mov    0x8(%di),%ax
    a1ba:	c1 e8 10             	shr    $0x10,%ax
    a1bd:	0f b6 c0             	movzbw %al,%ax
    a1c0:	50                   	push   %ax
    a1c1:	68 f5 01             	push   $0x1f5
    a1c4:	00 00                	add    %al,(%bx,%si)
    a1c6:	e8 03 ff             	call   a0cc <inw+0x1d>
    a1c9:	ff                   	(bad)
    a1ca:	ff 83 c4 08          	incw   0x8c4(%bp,%di)

    outb(0x1F7, cmd);
    a1ce:	0f b6 45 fc          	movzbw -0x4(%di),%ax
    a1d2:	50                   	push   %ax
    a1d3:	68 f7 01             	push   $0x1f7
    a1d6:	00 00                	add    %al,(%bx,%si)
    a1d8:	e8 f1 fe             	call   a0cc <inw+0x1d>
    a1db:	ff                   	(bad)
    a1dc:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
}
    a1e0:	90                   	nop
    a1e1:	c9                   	leave
    a1e2:	c3                   	ret

0000a1e3 <disk_read>:

// 读取磁盘
void disk_read(uint32_t sector, uint32_t count, void *buff) {
    a1e3:	55                   	push   %bp
    a1e4:	89 e5                	mov    %sp,%bp
    a1e6:	53                   	push   %bx
    a1e7:	83 ec 10             	sub    $0x10,%sp
    disk_cmd(sector,count,DISK_CMD_READ);
    a1ea:	6a 24                	push   $0x24
    a1ec:	ff 75 0c             	push   0xc(%di)
    a1ef:	ff 75 08             	push   0x8(%di)
    a1f2:	e8 17 ff             	call   a10c <outw+0x1f>
    a1f5:	ff                   	(bad)
    a1f6:	ff 83 c4 0c          	incw   0xcc4(%bp,%di)
    // 读取数据
    uint16_t *temp = buff;
    a1fa:	8b 45 10             	mov    0x10(%di),%ax
    a1fd:	89 45 f8             	mov    %ax,-0x8(%di)
    while (count-- > 0) {
    a200:	eb 41                	jmp    a243 <disk_read+0x60>
        // 读取时先检察再读取
        while (inb(0x1F7) & 0x80) {}
    a202:	90                   	nop
    a203:	68 f7 01             	push   $0x1f7
    a206:	00 00                	add    %al,(%bx,%si)
    a208:	e8 85 fe             	call   a090 <fifo_write+0x55>
    a20b:	ff                   	(bad)
    a20c:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
    a210:	84 c0                	test   %al,%al
    a212:	78 ef                	js     a203 <disk_read+0x20>
        // 读取并将数据写入到缓存中
        for (int i = 0; i < SECTOR_SIZE / 2; i++) {
    a214:	c7 45 f4 00 00       	movw   $0x0,-0xc(%di)
    a219:	00 00                	add    %al,(%bx,%si)
    a21b:	eb 1d                	jmp    a23a <disk_read+0x57>
            *temp++ = inw(0x1F0);
    a21d:	8b 5d f8             	mov    -0x8(%di),%bx
    a220:	8d 43 02             	lea    0x2(%bp,%di),%ax
    a223:	89 45 f8             	mov    %ax,-0x8(%di)
    a226:	68 f0 01             	push   $0x1f0
    a229:	00 00                	add    %al,(%bx,%si)
    a22b:	e8 7f fe             	call   a0ad <inb+0x1b>
    a22e:	ff                   	(bad)
    a22f:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
    a233:	66 89 03             	mov    %eax,(%bp,%di)
        for (int i = 0; i < SECTOR_SIZE / 2; i++) {
    a236:	83 45 f4 01          	addw   $0x1,-0xc(%di)
    a23a:	81 7d f4 ff 00       	cmpw   $0xff,-0xc(%di)
    a23f:	00 00                	add    %al,(%bx,%si)
    a241:	7e da                	jle    a21d <disk_read+0x3a>
    while (count-- > 0) {
    a243:	8b 45 0c             	mov    0xc(%di),%ax
    a246:	8d 50 ff             	lea    -0x1(%bx,%si),%dx
    a249:	89 55 0c             	mov    %dx,0xc(%di)
    a24c:	85 c0                	test   %ax,%ax
    a24e:	75 b2                	jne    a202 <disk_read+0x1f>
        }
    }
}
    a250:	90                   	nop
    a251:	90                   	nop
    a252:	8b 5d fc             	mov    -0x4(%di),%bx
    a255:	c9                   	leave
    a256:	c3                   	ret

0000a257 <disk_write>:

// 写入磁盘
void disk_write(uint32_t sector, uint32_t count, void *buff) {
    a257:	55                   	push   %bp
    a258:	89 e5                	mov    %sp,%bp
    a25a:	83 ec 10             	sub    $0x10,%sp
    disk_cmd(sector,count,DISK_CMD_WRITE);
    a25d:	6a 34                	push   $0x34
    a25f:	ff 75 0c             	push   0xc(%di)
    a262:	ff 75 08             	push   0x8(%di)
    a265:	e8 a4 fe             	call   a10c <outw+0x1f>
    a268:	ff                   	(bad)
    a269:	ff 83 c4 0c          	incw   0xcc4(%bp,%di)
    // 写入数据
    uint16_t *temp = (uint16_t*) buff;
    a26d:	8b 45 10             	mov    0x10(%di),%ax
    a270:	89 45 fc             	mov    %ax,-0x4(%di)
    while (count-- > 0) {
    a273:	eb 45                	jmp    a2ba <disk_write+0x63>
        // 每次写入一个扇区的数据，然后等待数据的写入
        for (int i = 0; i < SECTOR_SIZE / 2; i++) {
    a275:	c7 45 f8 00 00       	movw   $0x0,-0x8(%di)
    a27a:	00 00                	add    %al,(%bx,%si)
    a27c:	eb 21                	jmp    a29f <disk_write+0x48>
            outw(0x1F0,*temp++);
    a27e:	8b 45 fc             	mov    -0x4(%di),%ax
    a281:	8d 50 02             	lea    0x2(%bx,%si),%dx
    a284:	89 55 fc             	mov    %dx,-0x4(%di)
    a287:	0f b7 00             	movzww (%bx,%si),%ax
    a28a:	0f b7 c0             	movzww %ax,%ax
    a28d:	50                   	push   %ax
    a28e:	68 f0 01             	push   $0x1f0
    a291:	00 00                	add    %al,(%bx,%si)
    a293:	e8 55 fe             	call   a0eb <outb+0x1d>
    a296:	ff                   	(bad)
    a297:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
        for (int i = 0; i < SECTOR_SIZE / 2; i++) {
    a29b:	83 45 f8 01          	addw   $0x1,-0x8(%di)
    a29f:	81 7d f8 ff 00       	cmpw   $0xff,-0x8(%di)
    a2a4:	00 00                	add    %al,(%bx,%si)
    a2a6:	7e d6                	jle    a27e <disk_write+0x27>
        }
        // 先写入再检察
        while (inb(0x1F7) & 0x80) {}
    a2a8:	90                   	nop
    a2a9:	68 f7 01             	push   $0x1f7
    a2ac:	00 00                	add    %al,(%bx,%si)
    a2ae:	e8 df fd             	call   a090 <fifo_write+0x55>
    a2b1:	ff                   	(bad)
    a2b2:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
    a2b6:	84 c0                	test   %al,%al
    a2b8:	78 ef                	js     a2a9 <disk_write+0x52>
    while (count-- > 0) {
    a2ba:	8b 45 0c             	mov    0xc(%di),%ax
    a2bd:	8d 50 ff             	lea    -0x1(%bx,%si),%dx
    a2c0:	89 55 0c             	mov    %dx,0xc(%di)
    a2c3:	85 c0                	test   %ax,%ax
    a2c5:	75 ae                	jne    a275 <disk_write+0x1e>
    }
}
    a2c7:	90                   	nop
    a2c8:	90                   	nop
    a2c9:	c9                   	leave
    a2ca:	c3                   	ret

0000a2cb <init_file>:

void init_file(){
    a2cb:	55                   	push   %bp
    a2cc:	89 e5                	mov    %sp,%bp

}
    a2ce:	90                   	nop
    a2cf:	5d                   	pop    %bp
    a2d0:	c3                   	ret

0000a2d1 <file_item2file>:

file_t *file_item2file(file_item_t *item,int index) {
    a2d1:	55                   	push   %bp
    a2d2:	89 e5                	mov    %sp,%bp
    a2d4:	83 ec 18             	sub    $0x18,%sp
    file_t *file= mem_alloc(sizeof(file_t));
    a2d7:	83 ec 0c             	sub    $0xc,%sp
    a2da:	68 1c 02             	push   $0x21c
    a2dd:	00 00                	add    %al,(%bx,%si)
    a2df:	e8 00 2b             	call   cde2 <mem_total+0x53>
    a2e2:	00 00                	add    %al,(%bx,%si)
    a2e4:	83 c4 10             	add    $0x10,%sp
    a2e7:	89 45 f4             	mov    %ax,-0xc(%di)
    mem_copy(file->name, item->name, 11);
    a2ea:	8b 55 08             	mov    0x8(%di),%dx
    a2ed:	8b 45 f4             	mov    -0xc(%di),%ax
    a2f0:	83 ec 04             	sub    $0x4,%sp
    a2f3:	6a 0b                	push   $0xb
    a2f5:	52                   	push   %dx
    a2f6:	50                   	push   %ax
    a2f7:	e8 68 35             	call   d862 <mem_eq+0x60>
    a2fa:	00 00                	add    %al,(%bx,%si)
    a2fc:	83 c4 10             	add    $0x10,%sp
    file->size= item->size;
    a2ff:	8b 45 08             	mov    0x8(%di),%ax
    a302:	8b 50 0c             	mov    0xc(%bx,%si),%dx
    a305:	8b 45 f4             	mov    -0xc(%di),%ax
    a308:	89 90 14 02          	mov    %dx,0x214(%bx,%si)
    a30c:	00 00                	add    %al,(%bx,%si)
    file->base_sel=item->selector;
    a30e:	8b 45 08             	mov    0x8(%di),%ax
    a311:	0f b6 50 0b          	movzbw 0xb(%bx,%si),%dx
    a315:	8b 45 f4             	mov    -0xc(%di),%ax
    a318:	88 50 0b             	mov    %dl,0xb(%bx,%si)
    file->curr_sel=FILE_LINK_EMPTY; // 默认执行空表示没有缓存
    a31b:	8b 45 f4             	mov    -0xc(%di),%ax
    a31e:	c6 40 0c 00          	movb   $0x0,0xc(%bx,%si)
    file->pos=0;
    a322:	8b 45 f4             	mov    -0xc(%di),%ax
    a325:	c7 80 10 02 00 00    	movw   $0x0,0x210(%bx,%si)
    a32b:	00 00                	add    %al,(%bx,%si)
    a32d:	00 00                	add    %al,(%bx,%si)
    file->item_index=index;
    a32f:	8b 45 f4             	mov    -0xc(%di),%ax
    a332:	8b 55 0c             	mov    0xc(%di),%dx
    a335:	89 90 18 02          	mov    %dx,0x218(%bx,%si)
    a339:	00 00                	add    %al,(%bx,%si)
    return file;
    a33b:	8b 45 f4             	mov    -0xc(%di),%ax
}
    a33e:	c9                   	leave
    a33f:	c3                   	ret

0000a340 <find_empty_sel>:

uint8_t find_empty_sel() {
    a340:	55                   	push   %bp
    a341:	89 e5                	mov    %sp,%bp
    a343:	83 ec 18             	sub    $0x18,%sp
    uint8_t *sel= mem_alloc(SECTOR_SIZE);
    a346:	83 ec 0c             	sub    $0xc,%sp
    a349:	68 00 02             	push   $0x200
    a34c:	00 00                	add    %al,(%bx,%si)
    a34e:	e8 91 2a             	call   cde2 <mem_total+0x53>
    a351:	00 00                	add    %al,(%bx,%si)
    a353:	83 c4 10             	add    $0x10,%sp
    a356:	89 45 ec             	mov    %ax,-0x14(%di)
    disk_read(FILE_LINK_SEL,1,sel);
    a359:	83 ec 04             	sub    $0x4,%sp
    a35c:	ff 75 ec             	push   -0x14(%di)
    a35f:	6a 01                	push   $0x1
    a361:	68 01 01             	push   $0x101
    a364:	00 00                	add    %al,(%bx,%si)
    a366:	e8 78 fe             	call   a1e1 <disk_cmd+0xd3>
    a369:	ff                   	(bad)
    a36a:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    uint8_t res=FILE_LINK_END; // 一般不会使用这个默认值
    a36e:	c6 45 f7 01          	movb   $0x1,-0x9(%di)
    for (int i = 2; i < 256; ++i) {// 0 1 都是无效的
    a372:	c7 45 f0 02 00       	movw   $0x2,-0x10(%di)
    a377:	00 00                	add    %al,(%bx,%si)
    a379:	eb 3b                	jmp    a3b6 <find_empty_sel+0x76>
        if(sel[i]==FILE_LINK_EMPTY){
    a37b:	8b 55 f0             	mov    -0x10(%di),%dx
    a37e:	8b 45 ec             	mov    -0x14(%di),%ax
    a381:	01 d0                	add    %dx,%ax
    a383:	0f b6 00             	movzbw (%bx,%si),%ax
    a386:	84 c0                	test   %al,%al
    a388:	75 28                	jne    a3b2 <find_empty_sel+0x72>
            res=i;
    a38a:	8b 45 f0             	mov    -0x10(%di),%ax
    a38d:	88 45 f7             	mov    %al,-0x9(%di)
            sel[i]=FILE_LINK_END;
    a390:	8b 55 f0             	mov    -0x10(%di),%dx
    a393:	8b 45 ec             	mov    -0x14(%di),%ax
    a396:	01 d0                	add    %dx,%ax
    a398:	c6 00 01             	movb   $0x1,(%bx,%si)
            disk_write(FILE_LINK_SEL,1,sel);
    a39b:	83 ec 04             	sub    $0x4,%sp
    a39e:	ff 75 ec             	push   -0x14(%di)
    a3a1:	6a 01                	push   $0x1
    a3a3:	68 01 01             	push   $0x101
    a3a6:	00 00                	add    %al,(%bx,%si)
    a3a8:	e8 aa fe             	call   a255 <disk_read+0x72>
    a3ab:	ff                   	(bad)
    a3ac:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
            break;
    a3b0:	eb 0d                	jmp    a3bf <find_empty_sel+0x7f>
    for (int i = 2; i < 256; ++i) {// 0 1 都是无效的
    a3b2:	83 45 f0 01          	addw   $0x1,-0x10(%di)
    a3b6:	81 7d f0 ff 00       	cmpw   $0xff,-0x10(%di)
    a3bb:	00 00                	add    %al,(%bx,%si)
    a3bd:	7e bc                	jle    a37b <find_empty_sel+0x3b>
        }
    }
    mem_free(sel,SECTOR_SIZE);
    a3bf:	83 ec 08             	sub    $0x8,%sp
    a3c2:	68 00 02             	push   $0x200
    a3c5:	00 00                	add    %al,(%bx,%si)
    a3c7:	ff 75 ec             	push   -0x14(%di)
    a3ca:	e8 12 2b             	call   cedf <mem_alloc+0xfb>
    a3cd:	00 00                	add    %al,(%bx,%si)
    a3cf:	83 c4 10             	add    $0x10,%sp
    return res;
    a3d2:	0f b6 45 f7          	movzbw -0x9(%di),%ax
}
    a3d6:	c9                   	leave
    a3d7:	c3                   	ret

0000a3d8 <file_open>:

file_t *file_open(char *name, bool_t create){
    a3d8:	55                   	push   %bp
    a3d9:	89 e5                	mov    %sp,%bp
    a3db:	83 ec 28             	sub    $0x28,%sp
    file_item_t *base_item= mem_alloc(SECTOR_SIZE);
    a3de:	83 ec 0c             	sub    $0xc,%sp
    a3e1:	68 00 02             	push   $0x200
    a3e4:	00 00                	add    %al,(%bx,%si)
    a3e6:	e8 f9 29             	call   cde2 <mem_total+0x53>
    a3e9:	00 00                	add    %al,(%bx,%si)
    a3eb:	83 c4 10             	add    $0x10,%sp
    a3ee:	89 45 e8             	mov    %ax,-0x18(%di)
    disk_read(FILE_HEADER_SEL, 1, base_item);
    a3f1:	83 ec 04             	sub    $0x4,%sp
    a3f4:	ff 75 e8             	push   -0x18(%di)
    a3f7:	6a 01                	push   $0x1
    a3f9:	68 00 01             	push   $0x100
    a3fc:	00 00                	add    %al,(%bx,%si)
    a3fe:	e8 e0 fd             	call   a1e1 <disk_cmd+0xd3>
    a401:	ff                   	(bad)
    a402:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    file_t *file=0;
    a406:	c7 45 f4 00 00       	movw   $0x0,-0xc(%di)
    a40b:	00 00                	add    %al,(%bx,%si)
    for (int i = 0; i < FILE_ITEM_COUNT; ++i) {
    a40d:	c7 45 f0 00 00       	movw   $0x0,-0x10(%di)
    a412:	00 00                	add    %al,(%bx,%si)
    a414:	eb 40                	jmp    a456 <file_open+0x7e>
        file_item_t *item=base_item+i;
    a416:	8b 45 f0             	mov    -0x10(%di),%ax
    a419:	c1 e0 04             	shl    $0x4,%ax
    a41c:	89 c2                	mov    %ax,%dx
    a41e:	8b 45 e8             	mov    -0x18(%di),%ax
    a421:	01 d0                	add    %dx,%ax
    a423:	89 45 e4             	mov    %ax,-0x1c(%di)
        if(mem_eq(item->name, name)){// 找到了
    a426:	8b 45 e4             	mov    -0x1c(%di),%ax
    a429:	83 ec 08             	sub    $0x8,%sp
    a42c:	ff 75 08             	push   0x8(%di)
    a42f:	50                   	push   %ax
    a430:	e8 cd 33             	call   d800 <mem_set+0x38>
    a433:	00 00                	add    %al,(%bx,%si)
    a435:	83 c4 10             	add    $0x10,%sp
    a438:	85 c0                	test   %ax,%ax
    a43a:	74 16                	je     a452 <file_open+0x7a>
            file= file_item2file(item, i);
    a43c:	83 ec 08             	sub    $0x8,%sp
    a43f:	ff 75 f0             	push   -0x10(%di)
    a442:	ff 75 e4             	push   -0x1c(%di)
    a445:	e8 87 fe             	call   a2cf <init_file+0x4>
    a448:	ff                   	(bad)
    a449:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    a44d:	89 45 f4             	mov    %ax,-0xc(%di)
            break;
    a450:	eb 0a                	jmp    a45c <file_open+0x84>
    for (int i = 0; i < FILE_ITEM_COUNT; ++i) {
    a452:	83 45 f0 01          	addw   $0x1,-0x10(%di)
    a456:	83 7d f0 1f          	cmpw   $0x1f,-0x10(%di)
    a45a:	7e ba                	jle    a416 <file_open+0x3e>
        }
    }

    if(!create||file){
    a45c:	83 7d 0c 00          	cmpw   $0x0,0xc(%di)
    a460:	74 06                	je     a468 <file_open+0x90>
    a462:	83 7d f4 00          	cmpw   $0x0,-0xc(%di)
    a466:	74 1b                	je     a483 <file_open+0xab>
        mem_free(base_item,SECTOR_SIZE);
    a468:	83 ec 08             	sub    $0x8,%sp
    a46b:	68 00 02             	push   $0x200
    a46e:	00 00                	add    %al,(%bx,%si)
    a470:	ff 75 e8             	push   -0x18(%di)
    a473:	e8 69 2a             	call   cedf <mem_alloc+0xfb>
    a476:	00 00                	add    %al,(%bx,%si)
    a478:	83 c4 10             	add    $0x10,%sp
        return file;
    a47b:	8b 45 f4             	mov    -0xc(%di),%ax
    a47e:	e9 a8 00             	jmp    a529 <file_open+0x151>
    a481:	00 00                	add    %al,(%bx,%si)
    }

    for (int i = 0; i < FILE_ITEM_COUNT; ++i) {
    a483:	c7 45 ec 00 00       	movw   $0x0,-0x14(%di)
    a488:	00 00                	add    %al,(%bx,%si)
    a48a:	eb 7f                	jmp    a50b <file_open+0x133>
        file_item_t *item=base_item+i;
    a48c:	8b 45 ec             	mov    -0x14(%di),%ax
    a48f:	c1 e0 04             	shl    $0x4,%ax
    a492:	89 c2                	mov    %ax,%dx
    a494:	8b 45 e8             	mov    -0x18(%di),%ax
    a497:	01 d0                	add    %dx,%ax
    a499:	89 45 e0             	mov    %ax,-0x20(%di)
        if(item->name[0]=='\0'){// 空表项，所有文件名称都不能为空
    a49c:	8b 45 e0             	mov    -0x20(%di),%ax
    a49f:	0f b6 00             	movzbw (%bx,%si),%ax
    a4a2:	84 c0                	test   %al,%al
    a4a4:	75 61                	jne    a507 <file_open+0x12f>
            mem_copy(item->name,name, str_len(name));
    a4a6:	83 ec 0c             	sub    $0xc,%sp
    a4a9:	ff 75 08             	push   0x8(%di)
    a4ac:	e8 7f 34             	call   d92e <str_pfx+0x3f>
    a4af:	00 00                	add    %al,(%bx,%si)
    a4b1:	83 c4 10             	add    $0x10,%sp
    a4b4:	8b 55 e0             	mov    -0x20(%di),%dx
    a4b7:	83 ec 04             	sub    $0x4,%sp
    a4ba:	50                   	push   %ax
    a4bb:	ff 75 08             	push   0x8(%di)
    a4be:	52                   	push   %dx
    a4bf:	e8 a0 33             	call   d862 <mem_eq+0x60>
    a4c2:	00 00                	add    %al,(%bx,%si)
    a4c4:	83 c4 10             	add    $0x10,%sp
            item->size=0;
    a4c7:	8b 45 e0             	mov    -0x20(%di),%ax
    a4ca:	c7 40 0c 00 00       	movw   $0x0,0xc(%bx,%si)
    a4cf:	00 00                	add    %al,(%bx,%si)
            item->selector=find_empty_sel();// 就算为空也分配一个有效扇区，防止后续写入再修改表头
    a4d1:	e8 6a fe             	call   a33e <file_item2file+0x6d>
    a4d4:	ff                   	(bad)
    a4d5:	ff 8b 55 e0          	decw   -0x1fab(%bp,%di)
    a4d9:	88 42 0b             	mov    %al,0xb(%bp,%si)
            disk_write(FILE_HEADER_SEL,1,base_item);
    a4dc:	83 ec 04             	sub    $0x4,%sp
    a4df:	ff 75 e8             	push   -0x18(%di)
    a4e2:	6a 01                	push   $0x1
    a4e4:	68 00 01             	push   $0x100
    a4e7:	00 00                	add    %al,(%bx,%si)
    a4e9:	e8 69 fd             	call   a255 <disk_read+0x72>
    a4ec:	ff                   	(bad)
    a4ed:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
            file= file_item2file(item, i);
    a4f1:	83 ec 08             	sub    $0x8,%sp
    a4f4:	ff 75 ec             	push   -0x14(%di)
    a4f7:	ff 75 e0             	push   -0x20(%di)
    a4fa:	e8 d2 fd             	call   a2cf <init_file+0x4>
    a4fd:	ff                   	(bad)
    a4fe:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    a502:	89 45 f4             	mov    %ax,-0xc(%di)
            break;
    a505:	eb 0e                	jmp    a515 <file_open+0x13d>
    for (int i = 0; i < FILE_ITEM_COUNT; ++i) {
    a507:	83 45 ec 01          	addw   $0x1,-0x14(%di)
    a50b:	83 7d ec 1f          	cmpw   $0x1f,-0x14(%di)
    a50f:	0f 8e 77 ff          	jle    a48a <file_open+0xb2>
    a513:	ff                   	(bad)
    a514:	ff 83 ec 08          	incw   0x8ec(%bp,%di)
        }
    }
    mem_free(base_item,SECTOR_SIZE);
    a518:	68 00 02             	push   $0x200
    a51b:	00 00                	add    %al,(%bx,%si)
    a51d:	ff 75 e8             	push   -0x18(%di)
    a520:	e8 bc 29             	call   cedf <mem_alloc+0xfb>
    a523:	00 00                	add    %al,(%bx,%si)
    a525:	83 c4 10             	add    $0x10,%sp
    return file;
    a528:	8b 45 f4             	mov    -0xc(%di),%ax
}
    a52b:	c9                   	leave
    a52c:	c3                   	ret

0000a52d <make_sure_buff>:

void make_sure_buff(file_t *file, const uint8_t *sel) {
    a52d:	55                   	push   %bp
    a52e:	89 e5                	mov    %sp,%bp
    a530:	83 ec 10             	sub    $0x10,%sp
    uint8_t count=file->pos/SECTOR_SIZE;
    a533:	8b 45 08             	mov    0x8(%di),%ax
    a536:	8b 80 10 02          	mov    0x210(%bx,%si),%ax
    a53a:	00 00                	add    %al,(%bx,%si)
    a53c:	c1 e8 09             	shr    $0x9,%ax
    a53f:	88 45 ff             	mov    %al,-0x1(%di)
    uint8_t curr_sel=file->base_sel;
    a542:	8b 45 08             	mov    0x8(%di),%ax
    a545:	0f b6 40 0b          	movzbw 0xb(%bx,%si),%ax
    a549:	88 45 fe             	mov    %al,-0x2(%di)
    while (count>0){
    a54c:	eb 19                	jmp    a567 <make_sure_buff+0x3a>
        curr_sel=sel[curr_sel];
    a54e:	0f b6 55 fe          	movzbw -0x2(%di),%dx
    a552:	8b 45 0c             	mov    0xc(%di),%ax
    a555:	01 d0                	add    %dx,%ax
    a557:	0f b6 00             	movzbw (%bx,%si),%ax
    a55a:	88 45 fe             	mov    %al,-0x2(%di)
        count--;
    a55d:	0f b6 45 ff          	movzbw -0x1(%di),%ax
    a561:	83 e8 01             	sub    $0x1,%ax
    a564:	88 45 ff             	mov    %al,-0x1(%di)
    while (count>0){
    a567:	80 7d ff 00          	cmpb   $0x0,-0x1(%di)
    a56b:	75 e1                	jne    a54e <make_sure_buff+0x21>
    }
    if(curr_sel != file->curr_sel){
    a56d:	8b 45 08             	mov    0x8(%di),%ax
    a570:	0f b6 40 0c          	movzbw 0xc(%bx,%si),%ax
    a574:	38 45 fe             	cmp    %al,-0x2(%di)
    a577:	74 25                	je     a59e <make_sure_buff+0x71>
        file->curr_sel=curr_sel;
    a579:	8b 45 08             	mov    0x8(%di),%ax
    a57c:	0f b6 55 fe          	movzbw -0x2(%di),%dx
    a580:	88 50 0c             	mov    %dl,0xc(%bx,%si)
        disk_read(FILE_BASE_SEL+(uint32_t)curr_sel,1,file->buff);
    a583:	8b 45 08             	mov    0x8(%di),%ax
    a586:	8d 50 0d             	lea    0xd(%bx,%si),%dx
    a589:	0f b6 45 fe          	movzbw -0x2(%di),%ax
    a58d:	05 00 01             	add    $0x100,%ax
    a590:	00 00                	add    %al,(%bx,%si)
    a592:	52                   	push   %dx
    a593:	6a 01                	push   $0x1
    a595:	50                   	push   %ax
    a596:	e8 48 fc             	call   a1e1 <disk_cmd+0xd3>
    a599:	ff                   	(bad)
    a59a:	ff 83 c4 0c          	incw   0xcc4(%bp,%di)
    }
}
    a59e:	90                   	nop
    a59f:	c9                   	leave
    a5a0:	c3                   	ret

0000a5a1 <file_read>:

uint32_t file_read(file_t *file, uint32_t size, uint8_t *buff){
    a5a1:	55                   	push   %bp
    a5a2:	89 e5                	mov    %sp,%bp
    a5a4:	83 ec 18             	sub    $0x18,%sp
    if(file->pos+size>file->size){
    a5a7:	8b 45 08             	mov    0x8(%di),%ax
    a5aa:	8b 90 10 02          	mov    0x210(%bx,%si),%dx
    a5ae:	00 00                	add    %al,(%bx,%si)
    a5b0:	8b 45 0c             	mov    0xc(%di),%ax
    a5b3:	01 c2                	add    %ax,%dx
    a5b5:	8b 45 08             	mov    0x8(%di),%ax
    a5b8:	8b 80 14 02          	mov    0x214(%bx,%si),%ax
    a5bc:	00 00                	add    %al,(%bx,%si)
    a5be:	39 d0                	cmp    %dx,%ax
    a5c0:	73 17                	jae    a5d9 <file_read+0x38>
        size=file->size-file->pos;
    a5c2:	8b 45 08             	mov    0x8(%di),%ax
    a5c5:	8b 90 14 02          	mov    0x214(%bx,%si),%dx
    a5c9:	00 00                	add    %al,(%bx,%si)
    a5cb:	8b 45 08             	mov    0x8(%di),%ax
    a5ce:	8b 80 10 02          	mov    0x210(%bx,%si),%ax
    a5d2:	00 00                	add    %al,(%bx,%si)
    a5d4:	29 c2                	sub    %ax,%dx
    a5d6:	89 55 0c             	mov    %dx,0xc(%di)
    }
    uint32_t read_size=size;
    a5d9:	8b 45 0c             	mov    0xc(%di),%ax
    a5dc:	89 45 f4             	mov    %ax,-0xc(%di)

    uint8_t *sel= mem_alloc(SECTOR_SIZE);
    a5df:	83 ec 0c             	sub    $0xc,%sp
    a5e2:	68 00 02             	push   $0x200
    a5e5:	00 00                	add    %al,(%bx,%si)
    a5e7:	e8 f8 27             	call   cde2 <mem_total+0x53>
    a5ea:	00 00                	add    %al,(%bx,%si)
    a5ec:	83 c4 10             	add    $0x10,%sp
    a5ef:	89 45 f0             	mov    %ax,-0x10(%di)
    disk_read(FILE_LINK_SEL,1,sel);
    a5f2:	83 ec 04             	sub    $0x4,%sp
    a5f5:	ff 75 f0             	push   -0x10(%di)
    a5f8:	6a 01                	push   $0x1
    a5fa:	68 01 01             	push   $0x101
    a5fd:	00 00                	add    %al,(%bx,%si)
    a5ff:	e8 df fb             	call   a1e1 <disk_cmd+0xd3>
    a602:	ff                   	(bad)
    a603:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    while (size){
    a607:	e9 b2 00             	jmp    a6bc <file_read+0x11b>
    a60a:	00 00                	add    %al,(%bx,%si)
        make_sure_buff(file,sel);
    a60c:	83 ec 08             	sub    $0x8,%sp
    a60f:	ff 75 f0             	push   -0x10(%di)
    a612:	ff 75 08             	push   0x8(%di)
    a615:	e8 13 ff             	call   a52b <file_open+0x153>
    a618:	ff                   	(bad)
    a619:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
        uint32_t read = file->pos%SECTOR_SIZE;
    a61d:	8b 45 08             	mov    0x8(%di),%ax
    a620:	8b 80 10 02          	mov    0x210(%bx,%si),%ax
    a624:	00 00                	add    %al,(%bx,%si)
    a626:	25 ff 01             	and    $0x1ff,%ax
    a629:	00 00                	add    %al,(%bx,%si)
    a62b:	89 45 ec             	mov    %ax,-0x14(%di)
        uint32_t has=SECTOR_SIZE-read;
    a62e:	b8 00 02             	mov    $0x200,%ax
    a631:	00 00                	add    %al,(%bx,%si)
    a633:	2b 45 ec             	sub    -0x14(%di),%ax
    a636:	89 45 e8             	mov    %ax,-0x18(%di)
        if(has>=size){// 读取完毕了
    a639:	8b 45 e8             	mov    -0x18(%di),%ax
    a63c:	3b 45 0c             	cmp    0xc(%di),%ax
    a63f:	72 3d                	jb     a67e <file_read+0xdd>
            mem_copy(buff,file->buff+read,size);
    a641:	8b 45 08             	mov    0x8(%di),%ax
    a644:	8d 50 0d             	lea    0xd(%bx,%si),%dx
    a647:	8b 45 ec             	mov    -0x14(%di),%ax
    a64a:	01 d0                	add    %dx,%ax
    a64c:	83 ec 04             	sub    $0x4,%sp
    a64f:	ff 75 0c             	push   0xc(%di)
    a652:	50                   	push   %ax
    a653:	ff 75 10             	push   0x10(%di)
    a656:	e8 09 32             	call   d862 <mem_eq+0x60>
    a659:	00 00                	add    %al,(%bx,%si)
    a65b:	83 c4 10             	add    $0x10,%sp
            file->pos+=size;
    a65e:	8b 45 08             	mov    0x8(%di),%ax
    a661:	8b 90 10 02          	mov    0x210(%bx,%si),%dx
    a665:	00 00                	add    %al,(%bx,%si)
    a667:	8b 45 0c             	mov    0xc(%di),%ax
    a66a:	01 c2                	add    %ax,%dx
    a66c:	8b 45 08             	mov    0x8(%di),%ax
    a66f:	89 90 10 02          	mov    %dx,0x210(%bx,%si)
    a673:	00 00                	add    %al,(%bx,%si)
            size=0;
    a675:	c7 45 0c 00 00       	movw   $0x0,0xc(%di)
    a67a:	00 00                	add    %al,(%bx,%si)
    a67c:	eb 40                	jmp    a6be <file_read+0x11d>
        } else{// 还需要继续读取,且读完整个扇区
            mem_copy(buff,file->buff+read,has);
    a67e:	8b 45 08             	mov    0x8(%di),%ax
    a681:	8d 50 0d             	lea    0xd(%bx,%si),%dx
    a684:	8b 45 ec             	mov    -0x14(%di),%ax
    a687:	01 d0                	add    %dx,%ax
    a689:	83 ec 04             	sub    $0x4,%sp
    a68c:	ff 75 e8             	push   -0x18(%di)
    a68f:	50                   	push   %ax
    a690:	ff 75 10             	push   0x10(%di)
    a693:	e8 cc 31             	call   d862 <mem_eq+0x60>
    a696:	00 00                	add    %al,(%bx,%si)
    a698:	83 c4 10             	add    $0x10,%sp
            buff+=has;
    a69b:	8b 45 e8             	mov    -0x18(%di),%ax
    a69e:	01 45 10             	add    %ax,0x10(%di)
            file->pos+=has;
    a6a1:	8b 45 08             	mov    0x8(%di),%ax
    a6a4:	8b 90 10 02          	mov    0x210(%bx,%si),%dx
    a6a8:	00 00                	add    %al,(%bx,%si)
    a6aa:	8b 45 e8             	mov    -0x18(%di),%ax
    a6ad:	01 c2                	add    %ax,%dx
    a6af:	8b 45 08             	mov    0x8(%di),%ax
    a6b2:	89 90 10 02          	mov    %dx,0x210(%bx,%si)
    a6b6:	00 00                	add    %al,(%bx,%si)
            size-=has;
    a6b8:	8b 45 e8             	mov    -0x18(%di),%ax
    a6bb:	29 45 0c             	sub    %ax,0xc(%di)
    while (size){
    a6be:	83 7d 0c 00          	cmpw   $0x0,0xc(%di)
    a6c2:	0f 85 44 ff          	jne    a60a <file_read+0x69>
    a6c6:	ff                   	(bad)
    a6c7:	ff 83 ec 08          	incw   0x8ec(%bp,%di)
        }
    }
    mem_free(sel,SECTOR_SIZE);
    a6cb:	68 00 02             	push   $0x200
    a6ce:	00 00                	add    %al,(%bx,%si)
    a6d0:	ff 75 f0             	push   -0x10(%di)
    a6d3:	e8 09 28             	call   cedf <mem_alloc+0xfb>
    a6d6:	00 00                	add    %al,(%bx,%si)
    a6d8:	83 c4 10             	add    $0x10,%sp
    return read_size;
    a6db:	8b 45 f4             	mov    -0xc(%di),%ax
}
    a6de:	c9                   	leave
    a6df:	c3                   	ret

0000a6e0 <file_next_sel>:

uint8_t file_next_sel(uint8_t curr, uint8_t *sel, uint32_t size) {
    a6e0:	55                   	push   %bp
    a6e1:	89 e5                	mov    %sp,%bp
    a6e3:	53                   	push   %bx
    a6e4:	83 ec 24             	sub    $0x24,%sp
    a6e7:	8b 45 08             	mov    0x8(%di),%ax
    a6ea:	88 45 e4             	mov    %al,-0x1c(%di)
    if(size<=0){
    a6ed:	83 7d 10 00          	cmpw   $0x0,0x10(%di)
    a6f1:	75 0a                	jne    a6fd <file_next_sel+0x1d>
        return FILE_LINK_END;
    a6f3:	b8 01 00             	mov    $0x1,%ax
    a6f6:	00 00                	add    %al,(%bx,%si)
    a6f8:	e9 be 00             	jmp    a7b9 <file_next_sel+0xd9>
    a6fb:	00 00                	add    %al,(%bx,%si)
    }
    if(curr!=FILE_LINK_END){
    a6fd:	80 7d e4 01          	cmpb   $0x1,-0x1c(%di)
    a701:	74 43                	je     a746 <file_next_sel+0x66>
        sel[curr]= file_next_sel(sel[curr],sel,size>SECTOR_SIZE?size-SECTOR_SIZE:0);
    a703:	8b 45 10             	mov    0x10(%di),%ax
    a706:	ba 00 02             	mov    $0x200,%dx
    a709:	00 00                	add    %al,(%bx,%si)
    a70b:	39 d0                	cmp    %dx,%ax
    a70d:	0f 42 c2             	cmovb  %dx,%ax
    a710:	8d 90 00 fe          	lea    -0x200(%bx,%si),%dx
    a714:	ff                   	(bad)
    a715:	ff 0f                	decw   (%bx)
    a717:	b6 4d                	mov    $0x4d,%dh
    a719:	e4 8b                	in     $0x8b,%al
    a71b:	45                   	inc    %bp
    a71c:	0c 01                	or     $0x1,%al
    a71e:	c8 0f b6 00          	enter  $0xb60f,$0x0
    a722:	0f b6 c0             	movzbw %al,%ax
    a725:	0f b6 5d e4          	movzbw -0x1c(%di),%bx
    a729:	8b 4d 0c             	mov    0xc(%di),%cx
    a72c:	01 cb                	add    %cx,%bx
    a72e:	83 ec 04             	sub    $0x4,%sp
    a731:	52                   	push   %dx
    a732:	ff 75 0c             	push   0xc(%di)
    a735:	50                   	push   %ax
    a736:	e8 a5 ff             	call   a6de <file_read+0x13d>
    a739:	ff                   	(bad)
    a73a:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    a73e:	88 03                	mov    %al,(%bp,%di)
        return curr;
    a740:	0f b6 45 e4          	movzbw -0x1c(%di),%ax
    a744:	eb 75                	jmp    a7bb <file_next_sel+0xdb>
    }
    for (int i = 2; i < 256; ++i) {
    a746:	c7 45 f4 02 00       	movw   $0x2,-0xc(%di)
    a74b:	00 00                	add    %al,(%bx,%si)
    a74d:	eb 5e                	jmp    a7ad <file_next_sel+0xcd>
        if(sel[i]==FILE_LINK_EMPTY){
    a74f:	8b 55 f4             	mov    -0xc(%di),%dx
    a752:	8b 45 0c             	mov    0xc(%di),%ax
    a755:	01 d0                	add    %dx,%ax
    a757:	0f b6 00             	movzbw (%bx,%si),%ax
    a75a:	84 c0                	test   %al,%al
    a75c:	75 4b                	jne    a7a9 <file_next_sel+0xc9>
            sel[i]=FILE_LINK_END;
    a75e:	8b 55 f4             	mov    -0xc(%di),%dx
    a761:	8b 45 0c             	mov    0xc(%di),%ax
    a764:	01 d0                	add    %dx,%ax
    a766:	c6 00 01             	movb   $0x1,(%bx,%si)
            sel[i]= file_next_sel(sel[i],sel,size>SECTOR_SIZE?size-SECTOR_SIZE:0);
    a769:	8b 45 10             	mov    0x10(%di),%ax
    a76c:	ba 00 02             	mov    $0x200,%dx
    a76f:	00 00                	add    %al,(%bx,%si)
    a771:	39 d0                	cmp    %dx,%ax
    a773:	0f 42 c2             	cmovb  %dx,%ax
    a776:	8d 90 00 fe          	lea    -0x200(%bx,%si),%dx
    a77a:	ff                   	(bad)
    a77b:	ff 8b 4d f4          	decw   -0xbb3(%bp,%di)
    a77f:	8b 45 0c             	mov    0xc(%di),%ax
    a782:	01 c8                	add    %cx,%ax
    a784:	0f b6 00             	movzbw (%bx,%si),%ax
    a787:	0f b6 c0             	movzbw %al,%ax
    a78a:	8b 5d f4             	mov    -0xc(%di),%bx
    a78d:	8b 4d 0c             	mov    0xc(%di),%cx
    a790:	01 cb                	add    %cx,%bx
    a792:	83 ec 04             	sub    $0x4,%sp
    a795:	52                   	push   %dx
    a796:	ff 75 0c             	push   0xc(%di)
    a799:	50                   	push   %ax
    a79a:	e8 41 ff             	call   a6de <file_read+0x13d>
    a79d:	ff                   	(bad)
    a79e:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    a7a2:	88 03                	mov    %al,(%bp,%di)
            return i;
    a7a4:	8b 45 f4             	mov    -0xc(%di),%ax
    a7a7:	eb 12                	jmp    a7bb <file_next_sel+0xdb>
    for (int i = 2; i < 256; ++i) {
    a7a9:	83 45 f4 01          	addw   $0x1,-0xc(%di)
    a7ad:	81 7d f4 ff 00       	cmpw   $0xff,-0xc(%di)
    a7b2:	00 00                	add    %al,(%bx,%si)
    a7b4:	7e 99                	jle    a74f <file_next_sel+0x6f>
        }
    }
    return 0; // 有问题了
    a7b6:	b8 00 00             	mov    $0x0,%ax
    a7b9:	00 00                	add    %al,(%bx,%si)
}
    a7bb:	8b 5d fc             	mov    -0x4(%di),%bx
    a7be:	c9                   	leave
    a7bf:	c3                   	ret

0000a7c0 <extend_file>:

void extend_file(file_t *file, uint32_t size, uint8_t *sel) {
    a7c0:	55                   	push   %bp
    a7c1:	89 e5                	mov    %sp,%bp
    a7c3:	83 ec 18             	sub    $0x18,%sp
    file->size=size;
    a7c6:	8b 45 08             	mov    0x8(%di),%ax
    a7c9:	8b 55 0c             	mov    0xc(%di),%dx
    a7cc:	89 90 14 02          	mov    %dx,0x214(%bx,%si)
    a7d0:	00 00                	add    %al,(%bx,%si)
    file->base_sel=file_next_sel(file->base_sel,sel,size);
    a7d2:	8b 45 08             	mov    0x8(%di),%ax
    a7d5:	0f b6 40 0b          	movzbw 0xb(%bx,%si),%ax
    a7d9:	0f b6 c0             	movzbw %al,%ax
    a7dc:	83 ec 04             	sub    $0x4,%sp
    a7df:	ff 75 0c             	push   0xc(%di)
    a7e2:	ff 75 10             	push   0x10(%di)
    a7e5:	50                   	push   %ax
    a7e6:	e8 f5 fe             	call   a6de <file_read+0x13d>
    a7e9:	ff                   	(bad)
    a7ea:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    a7ee:	8b 55 08             	mov    0x8(%di),%dx
    a7f1:	88 42 0b             	mov    %al,0xb(%bp,%si)
    disk_write(FILE_LINK_SEL,1,sel); // 写入链接关系
    a7f4:	83 ec 04             	sub    $0x4,%sp
    a7f7:	ff 75 10             	push   0x10(%di)
    a7fa:	6a 01                	push   $0x1
    a7fc:	68 01 01             	push   $0x101
    a7ff:	00 00                	add    %al,(%bx,%si)
    a801:	e8 51 fa             	call   a255 <disk_read+0x72>
    a804:	ff                   	(bad)
    a805:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    // 写入文件修改
    file_item_t *base_item= mem_alloc(SECTOR_SIZE);
    a809:	83 ec 0c             	sub    $0xc,%sp
    a80c:	68 00 02             	push   $0x200
    a80f:	00 00                	add    %al,(%bx,%si)
    a811:	e8 ce 25             	call   cde2 <mem_total+0x53>
    a814:	00 00                	add    %al,(%bx,%si)
    a816:	83 c4 10             	add    $0x10,%sp
    a819:	89 45 f4             	mov    %ax,-0xc(%di)
    disk_read(FILE_HEADER_SEL, 1, base_item);
    a81c:	83 ec 04             	sub    $0x4,%sp
    a81f:	ff 75 f4             	push   -0xc(%di)
    a822:	6a 01                	push   $0x1
    a824:	68 00 01             	push   $0x100
    a827:	00 00                	add    %al,(%bx,%si)
    a829:	e8 b5 f9             	call   a1e1 <disk_cmd+0xd3>
    a82c:	ff                   	(bad)
    a82d:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    file_item_t *item=base_item+file->item_index;
    a831:	8b 45 08             	mov    0x8(%di),%ax
    a834:	8b 80 18 02          	mov    0x218(%bx,%si),%ax
    a838:	00 00                	add    %al,(%bx,%si)
    a83a:	c1 e0 04             	shl    $0x4,%ax
    a83d:	89 c2                	mov    %ax,%dx
    a83f:	8b 45 f4             	mov    -0xc(%di),%ax
    a842:	01 d0                	add    %dx,%ax
    a844:	89 45 f0             	mov    %ax,-0x10(%di)
    item->selector=file->base_sel;
    a847:	8b 45 08             	mov    0x8(%di),%ax
    a84a:	0f b6 50 0b          	movzbw 0xb(%bx,%si),%dx
    a84e:	8b 45 f0             	mov    -0x10(%di),%ax
    a851:	88 50 0b             	mov    %dl,0xb(%bx,%si)
    item->size=file->size;
    a854:	8b 45 08             	mov    0x8(%di),%ax
    a857:	8b 90 14 02          	mov    0x214(%bx,%si),%dx
    a85b:	00 00                	add    %al,(%bx,%si)
    a85d:	8b 45 f0             	mov    -0x10(%di),%ax
    a860:	89 50 0c             	mov    %dx,0xc(%bx,%si)
    disk_write(FILE_HEADER_SEL,1,base_item);
    a863:	83 ec 04             	sub    $0x4,%sp
    a866:	ff 75 f4             	push   -0xc(%di)
    a869:	6a 01                	push   $0x1
    a86b:	68 00 01             	push   $0x100
    a86e:	00 00                	add    %al,(%bx,%si)
    a870:	e8 e2 f9             	call   a255 <disk_read+0x72>
    a873:	ff                   	(bad)
    a874:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    mem_free(base_item,SECTOR_SIZE);
    a878:	83 ec 08             	sub    $0x8,%sp
    a87b:	68 00 02             	push   $0x200
    a87e:	00 00                	add    %al,(%bx,%si)
    a880:	ff 75 f4             	push   -0xc(%di)
    a883:	e8 59 26             	call   cedf <mem_alloc+0xfb>
    a886:	00 00                	add    %al,(%bx,%si)
    a888:	83 c4 10             	add    $0x10,%sp
}
    a88b:	90                   	nop
    a88c:	c9                   	leave
    a88d:	c3                   	ret

0000a88e <file_write>:

void file_write(file_t *file, uint32_t size, uint8_t *buff){
    a88e:	55                   	push   %bp
    a88f:	89 e5                	mov    %sp,%bp
    a891:	83 ec 18             	sub    $0x18,%sp
    uint8_t *sel= mem_alloc(SECTOR_SIZE);
    a894:	83 ec 0c             	sub    $0xc,%sp
    a897:	68 00 02             	push   $0x200
    a89a:	00 00                	add    %al,(%bx,%si)
    a89c:	e8 43 25             	call   cde2 <mem_total+0x53>
    a89f:	00 00                	add    %al,(%bx,%si)
    a8a1:	83 c4 10             	add    $0x10,%sp
    a8a4:	89 45 f4             	mov    %ax,-0xc(%di)
    disk_read(FILE_LINK_SEL,1,sel);
    a8a7:	83 ec 04             	sub    $0x4,%sp
    a8aa:	ff 75 f4             	push   -0xc(%di)
    a8ad:	6a 01                	push   $0x1
    a8af:	68 01 01             	push   $0x101
    a8b2:	00 00                	add    %al,(%bx,%si)
    a8b4:	e8 2a f9             	call   a1e1 <disk_cmd+0xd3>
    a8b7:	ff                   	(bad)
    a8b8:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    if(file->pos+size>file->size){
    a8bc:	8b 45 08             	mov    0x8(%di),%ax
    a8bf:	8b 90 10 02          	mov    0x210(%bx,%si),%dx
    a8c3:	00 00                	add    %al,(%bx,%si)
    a8c5:	8b 45 0c             	mov    0xc(%di),%ax
    a8c8:	01 c2                	add    %ax,%dx
    a8ca:	8b 45 08             	mov    0x8(%di),%ax
    a8cd:	8b 80 14 02          	mov    0x214(%bx,%si),%ax
    a8d1:	00 00                	add    %al,(%bx,%si)
    a8d3:	39 d0                	cmp    %dx,%ax
    a8d5:	0f 83 fb 00          	jae    a9d4 <file_write+0x146>
    a8d9:	00 00                	add    %al,(%bx,%si)
        extend_file(file,file->pos+size,sel);
    a8db:	8b 45 08             	mov    0x8(%di),%ax
    a8de:	8b 90 10 02          	mov    0x210(%bx,%si),%dx
    a8e2:	00 00                	add    %al,(%bx,%si)
    a8e4:	8b 45 0c             	mov    0xc(%di),%ax
    a8e7:	01 d0                	add    %dx,%ax
    a8e9:	83 ec 04             	sub    $0x4,%sp
    a8ec:	ff 75 f4             	push   -0xc(%di)
    a8ef:	50                   	push   %ax
    a8f0:	ff 75 08             	push   0x8(%di)
    a8f3:	e8 c8 fe             	call   a7be <file_next_sel+0xde>
    a8f6:	ff                   	(bad)
    a8f7:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    }

    while (size){
    a8fb:	e9 d6 00             	jmp    a9d4 <file_write+0x146>
    a8fe:	00 00                	add    %al,(%bx,%si)
        make_sure_buff(file,sel);
    a900:	83 ec 08             	sub    $0x8,%sp
    a903:	ff 75 f4             	push   -0xc(%di)
    a906:	ff 75 08             	push   0x8(%di)
    a909:	e8 1f fc             	call   a52b <file_open+0x153>
    a90c:	ff                   	(bad)
    a90d:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
        uint32_t write = file->pos%SECTOR_SIZE;
    a911:	8b 45 08             	mov    0x8(%di),%ax
    a914:	8b 80 10 02          	mov    0x210(%bx,%si),%ax
    a918:	00 00                	add    %al,(%bx,%si)
    a91a:	25 ff 01             	and    $0x1ff,%ax
    a91d:	00 00                	add    %al,(%bx,%si)
    a91f:	89 45 f0             	mov    %ax,-0x10(%di)
        uint32_t has=SECTOR_SIZE-write;
    a922:	b8 00 02             	mov    $0x200,%ax
    a925:	00 00                	add    %al,(%bx,%si)
    a927:	2b 45 f0             	sub    -0x10(%di),%ax
    a92a:	89 45 ec             	mov    %ax,-0x14(%di)
        if(has>=size){
    a92d:	8b 45 ec             	mov    -0x14(%di),%ax
    a930:	3b 45 0c             	cmp    0xc(%di),%ax
    a933:	72 3d                	jb     a972 <file_write+0xe4>
            mem_copy(file->buff+write,buff,size);
    a935:	8b 45 08             	mov    0x8(%di),%ax
    a938:	8d 50 0d             	lea    0xd(%bx,%si),%dx
    a93b:	8b 45 f0             	mov    -0x10(%di),%ax
    a93e:	01 d0                	add    %dx,%ax
    a940:	83 ec 04             	sub    $0x4,%sp
    a943:	ff 75 0c             	push   0xc(%di)
    a946:	ff 75 10             	push   0x10(%di)
    a949:	50                   	push   %ax
    a94a:	e8 15 2f             	call   d862 <mem_eq+0x60>
    a94d:	00 00                	add    %al,(%bx,%si)
    a94f:	83 c4 10             	add    $0x10,%sp
            file->pos+=size;
    a952:	8b 45 08             	mov    0x8(%di),%ax
    a955:	8b 90 10 02          	mov    0x210(%bx,%si),%dx
    a959:	00 00                	add    %al,(%bx,%si)
    a95b:	8b 45 0c             	mov    0xc(%di),%ax
    a95e:	01 c2                	add    %ax,%dx
    a960:	8b 45 08             	mov    0x8(%di),%ax
    a963:	89 90 10 02          	mov    %dx,0x210(%bx,%si)
    a967:	00 00                	add    %al,(%bx,%si)
            size=0;
    a969:	c7 45 0c 00 00       	movw   $0x0,0xc(%di)
    a96e:	00 00                	add    %al,(%bx,%si)
    a970:	eb 64                	jmp    a9d6 <file_write+0x148>
        } else{
            mem_copy(file->buff+write,buff,has);
    a972:	8b 45 08             	mov    0x8(%di),%ax
    a975:	8d 50 0d             	lea    0xd(%bx,%si),%dx
    a978:	8b 45 f0             	mov    -0x10(%di),%ax
    a97b:	01 d0                	add    %dx,%ax
    a97d:	83 ec 04             	sub    $0x4,%sp
    a980:	ff 75 ec             	push   -0x14(%di)
    a983:	ff 75 10             	push   0x10(%di)
    a986:	50                   	push   %ax
    a987:	e8 d8 2e             	call   d862 <mem_eq+0x60>
    a98a:	00 00                	add    %al,(%bx,%si)
    a98c:	83 c4 10             	add    $0x10,%sp
            disk_write(FILE_BASE_SEL+(uint32_t)file->curr_sel,1,file->buff);
    a98f:	8b 45 08             	mov    0x8(%di),%ax
    a992:	8d 50 0d             	lea    0xd(%bx,%si),%dx
    a995:	8b 45 08             	mov    0x8(%di),%ax
    a998:	0f b6 40 0c          	movzbw 0xc(%bx,%si),%ax
    a99c:	0f b6 c0             	movzbw %al,%ax
    a99f:	05 00 01             	add    $0x100,%ax
    a9a2:	00 00                	add    %al,(%bx,%si)
    a9a4:	83 ec 04             	sub    $0x4,%sp
    a9a7:	52                   	push   %dx
    a9a8:	6a 01                	push   $0x1
    a9aa:	50                   	push   %ax
    a9ab:	e8 a7 f8             	call   a255 <disk_read+0x72>
    a9ae:	ff                   	(bad)
    a9af:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
            buff+=has;
    a9b3:	8b 45 ec             	mov    -0x14(%di),%ax
    a9b6:	01 45 10             	add    %ax,0x10(%di)
            file->pos+=has;
    a9b9:	8b 45 08             	mov    0x8(%di),%ax
    a9bc:	8b 90 10 02          	mov    0x210(%bx,%si),%dx
    a9c0:	00 00                	add    %al,(%bx,%si)
    a9c2:	8b 45 ec             	mov    -0x14(%di),%ax
    a9c5:	01 c2                	add    %ax,%dx
    a9c7:	8b 45 08             	mov    0x8(%di),%ax
    a9ca:	89 90 10 02          	mov    %dx,0x210(%bx,%si)
    a9ce:	00 00                	add    %al,(%bx,%si)
            size-=has;
    a9d0:	8b 45 ec             	mov    -0x14(%di),%ax
    a9d3:	29 45 0c             	sub    %ax,0xc(%di)
    while (size){
    a9d6:	83 7d 0c 00          	cmpw   $0x0,0xc(%di)
    a9da:	0f 85 20 ff          	jne    a8fe <file_write+0x70>
    a9de:	ff                   	(bad)
    a9df:	ff 83 ec 08          	incw   0x8ec(%bp,%di)
        }
    }
    mem_free(sel,SECTOR_SIZE);
    a9e3:	68 00 02             	push   $0x200
    a9e6:	00 00                	add    %al,(%bx,%si)
    a9e8:	ff 75 f4             	push   -0xc(%di)
    a9eb:	e8 f1 24             	call   cedf <mem_alloc+0xfb>
    a9ee:	00 00                	add    %al,(%bx,%si)
    a9f0:	83 c4 10             	add    $0x10,%sp
}
    a9f3:	90                   	nop
    a9f4:	c9                   	leave
    a9f5:	c3                   	ret

0000a9f6 <file_flush>:

void file_flush(file_t *file){
    a9f6:	55                   	push   %bp
    a9f7:	89 e5                	mov    %sp,%bp
    if(file->curr_sel!=FILE_LINK_END&&file->curr_sel!=FILE_LINK_EMPTY){
    a9f9:	8b 45 08             	mov    0x8(%di),%ax
    a9fc:	0f b6 40 0c          	movzbw 0xc(%bx,%si),%ax
    aa00:	3c 01                	cmp    $0x1,%al
    aa02:	74 2c                	je     aa30 <file_flush+0x3a>
    aa04:	8b 45 08             	mov    0x8(%di),%ax
    aa07:	0f b6 40 0c          	movzbw 0xc(%bx,%si),%ax
    aa0b:	84 c0                	test   %al,%al
    aa0d:	74 21                	je     aa30 <file_flush+0x3a>
        disk_write(FILE_BASE_SEL+(uint32_t)file->curr_sel,1,file->buff);
    aa0f:	8b 45 08             	mov    0x8(%di),%ax
    aa12:	8d 50 0d             	lea    0xd(%bx,%si),%dx
    aa15:	8b 45 08             	mov    0x8(%di),%ax
    aa18:	0f b6 40 0c          	movzbw 0xc(%bx,%si),%ax
    aa1c:	0f b6 c0             	movzbw %al,%ax
    aa1f:	05 00 01             	add    $0x100,%ax
    aa22:	00 00                	add    %al,(%bx,%si)
    aa24:	52                   	push   %dx
    aa25:	6a 01                	push   $0x1
    aa27:	50                   	push   %ax
    aa28:	e8 2a f8             	call   a255 <disk_read+0x72>
    aa2b:	ff                   	(bad)
    aa2c:	ff 83 c4 0c          	incw   0xcc4(%bp,%di)
    }
}
    aa30:	90                   	nop
    aa31:	c9                   	leave
    aa32:	c3                   	ret

0000aa33 <file_close>:

void file_close(file_t *file){
    aa33:	55                   	push   %bp
    aa34:	89 e5                	mov    %sp,%bp
    aa36:	83 ec 08             	sub    $0x8,%sp
    file_flush(file);
    aa39:	ff 75 08             	push   0x8(%di)
    aa3c:	e8 b5 ff             	call   a9f4 <file_write+0x166>
    aa3f:	ff                   	(bad)
    aa40:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
    mem_free(file, sizeof(file_t));
    aa44:	83 ec 08             	sub    $0x8,%sp
    aa47:	68 1c 02             	push   $0x21c
    aa4a:	00 00                	add    %al,(%bx,%si)
    aa4c:	ff 75 08             	push   0x8(%di)
    aa4f:	e8 8d 24             	call   cedf <mem_alloc+0xfb>
    aa52:	00 00                	add    %al,(%bx,%si)
    aa54:	83 c4 10             	add    $0x10,%sp
}
    aa57:	90                   	nop
    aa58:	c9                   	leave
    aa59:	c3                   	ret

0000aa5a <file_seek>:

bool_t file_seek(file_t *file,uint32_t pos){
    aa5a:	55                   	push   %bp
    aa5b:	89 e5                	mov    %sp,%bp
    if(pos>file->size){
    aa5d:	8b 45 08             	mov    0x8(%di),%ax
    aa60:	8b 80 14 02          	mov    0x214(%bx,%si),%ax
    aa64:	00 00                	add    %al,(%bx,%si)
    aa66:	3b 45 0c             	cmp    0xc(%di),%ax
    aa69:	73 07                	jae    aa72 <file_seek+0x18>
        return FALSE;
    aa6b:	b8 00 00             	mov    $0x0,%ax
    aa6e:	00 00                	add    %al,(%bx,%si)
    aa70:	eb 11                	jmp    aa83 <file_seek+0x29>
    }
    file->pos=pos;
    aa72:	8b 45 08             	mov    0x8(%di),%ax
    aa75:	8b 55 0c             	mov    0xc(%di),%dx
    aa78:	89 90 10 02          	mov    %dx,0x210(%bx,%si)
    aa7c:	00 00                	add    %al,(%bx,%si)
    return TRUE;
    aa7e:	b8 01 00             	mov    $0x1,%ax
    aa81:	00 00                	add    %al,(%bx,%si)
}
    aa83:	5d                   	pop    %bp
    aa84:	c3                   	ret

0000aa85 <free_file_link>:

void free_file_link(file_t *file) {
    aa85:	55                   	push   %bp
    aa86:	89 e5                	mov    %sp,%bp
    aa88:	83 ec 18             	sub    $0x18,%sp
    uint8_t *sel= mem_alloc(SECTOR_SIZE);
    aa8b:	83 ec 0c             	sub    $0xc,%sp
    aa8e:	68 00 02             	push   $0x200
    aa91:	00 00                	add    %al,(%bx,%si)
    aa93:	e8 4c 23             	call   cde2 <mem_total+0x53>
    aa96:	00 00                	add    %al,(%bx,%si)
    aa98:	83 c4 10             	add    $0x10,%sp
    aa9b:	89 45 f0             	mov    %ax,-0x10(%di)
    disk_read(FILE_LINK_SEL,1,sel);
    aa9e:	83 ec 04             	sub    $0x4,%sp
    aaa1:	ff 75 f0             	push   -0x10(%di)
    aaa4:	6a 01                	push   $0x1
    aaa6:	68 01 01             	push   $0x101
    aaa9:	00 00                	add    %al,(%bx,%si)
    aaab:	e8 33 f7             	call   a1e1 <disk_cmd+0xd3>
    aaae:	ff                   	(bad)
    aaaf:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    uint8_t curr= file->base_sel;
    aab3:	8b 45 08             	mov    0x8(%di),%ax
    aab6:	0f b6 40 0b          	movzbw 0xb(%bx,%si),%ax
    aaba:	88 45 f7             	mov    %al,-0x9(%di)
    while (curr!=FILE_LINK_END){
    aabd:	eb 22                	jmp    aae1 <free_file_link+0x5c>
        uint8_t next=sel[curr];// 全部释放
    aabf:	0f b6 55 f7          	movzbw -0x9(%di),%dx
    aac3:	8b 45 f0             	mov    -0x10(%di),%ax
    aac6:	01 d0                	add    %dx,%ax
    aac8:	0f b6 00             	movzbw (%bx,%si),%ax
    aacb:	88 45 ef             	mov    %al,-0x11(%di)
        sel[curr]=FILE_LINK_EMPTY;
    aace:	0f b6 55 f7          	movzbw -0x9(%di),%dx
    aad2:	8b 45 f0             	mov    -0x10(%di),%ax
    aad5:	01 d0                	add    %dx,%ax
    aad7:	c6 00 00             	movb   $0x0,(%bx,%si)
        curr=next;
    aada:	0f b6 45 ef          	movzbw -0x11(%di),%ax
    aade:	88 45 f7             	mov    %al,-0x9(%di)
    while (curr!=FILE_LINK_END){
    aae1:	80 7d f7 01          	cmpb   $0x1,-0x9(%di)
    aae5:	75 d8                	jne    aabf <free_file_link+0x3a>
    }
    disk_write(FILE_LINK_SEL,1,sel);
    aae7:	83 ec 04             	sub    $0x4,%sp
    aaea:	ff 75 f0             	push   -0x10(%di)
    aaed:	6a 01                	push   $0x1
    aaef:	68 01 01             	push   $0x101
    aaf2:	00 00                	add    %al,(%bx,%si)
    aaf4:	e8 5e f7             	call   a255 <disk_read+0x72>
    aaf7:	ff                   	(bad)
    aaf8:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    mem_free(sel,SECTOR_SIZE);
    aafc:	83 ec 08             	sub    $0x8,%sp
    aaff:	68 00 02             	push   $0x200
    ab02:	00 00                	add    %al,(%bx,%si)
    ab04:	ff 75 f0             	push   -0x10(%di)
    ab07:	e8 d5 23             	call   cedf <mem_alloc+0xfb>
    ab0a:	00 00                	add    %al,(%bx,%si)
    ab0c:	83 c4 10             	add    $0x10,%sp
}
    ab0f:	90                   	nop
    ab10:	c9                   	leave
    ab11:	c3                   	ret

0000ab12 <file_delete>:

// 主要标记文件头，与文件链接，同时也会释放文件
void file_delete(file_t *file){
    ab12:	55                   	push   %bp
    ab13:	89 e5                	mov    %sp,%bp
    ab15:	83 ec 18             	sub    $0x18,%sp
    // 写文件头
    file_item_t *base_item= mem_alloc(SECTOR_SIZE);
    ab18:	83 ec 0c             	sub    $0xc,%sp
    ab1b:	68 00 02             	push   $0x200
    ab1e:	00 00                	add    %al,(%bx,%si)
    ab20:	e8 bf 22             	call   cde2 <mem_total+0x53>
    ab23:	00 00                	add    %al,(%bx,%si)
    ab25:	83 c4 10             	add    $0x10,%sp
    ab28:	89 45 f4             	mov    %ax,-0xc(%di)
    disk_read(FILE_HEADER_SEL, 1, base_item);
    ab2b:	83 ec 04             	sub    $0x4,%sp
    ab2e:	ff 75 f4             	push   -0xc(%di)
    ab31:	6a 01                	push   $0x1
    ab33:	68 00 01             	push   $0x100
    ab36:	00 00                	add    %al,(%bx,%si)
    ab38:	e8 a6 f6             	call   a1e1 <disk_cmd+0xd3>
    ab3b:	ff                   	(bad)
    ab3c:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    file_item_t *item=base_item+file->item_index;
    ab40:	8b 45 08             	mov    0x8(%di),%ax
    ab43:	8b 80 18 02          	mov    0x218(%bx,%si),%ax
    ab47:	00 00                	add    %al,(%bx,%si)
    ab49:	c1 e0 04             	shl    $0x4,%ax
    ab4c:	89 c2                	mov    %ax,%dx
    ab4e:	8b 45 f4             	mov    -0xc(%di),%ax
    ab51:	01 d0                	add    %dx,%ax
    ab53:	89 45 f0             	mov    %ax,-0x10(%di)
    item->name[0]='\0';
    ab56:	8b 45 f0             	mov    -0x10(%di),%ax
    ab59:	c6 00 00             	movb   $0x0,(%bx,%si)
    disk_write(FILE_HEADER_SEL,1,base_item);
    ab5c:	83 ec 04             	sub    $0x4,%sp
    ab5f:	ff 75 f4             	push   -0xc(%di)
    ab62:	6a 01                	push   $0x1
    ab64:	68 00 01             	push   $0x100
    ab67:	00 00                	add    %al,(%bx,%si)
    ab69:	e8 e9 f6             	call   a255 <disk_read+0x72>
    ab6c:	ff                   	(bad)
    ab6d:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    mem_free(base_item,SECTOR_SIZE);
    ab71:	83 ec 08             	sub    $0x8,%sp
    ab74:	68 00 02             	push   $0x200
    ab77:	00 00                	add    %al,(%bx,%si)
    ab79:	ff 75 f4             	push   -0xc(%di)
    ab7c:	e8 60 23             	call   cedf <mem_alloc+0xfb>
    ab7f:	00 00                	add    %al,(%bx,%si)
    ab81:	83 c4 10             	add    $0x10,%sp
    // 清零链接内容
    free_file_link(file);
    ab84:	83 ec 0c             	sub    $0xc,%sp
    ab87:	ff 75 08             	push   0x8(%di)
    ab8a:	e8 f6 fe             	call   aa83 <file_seek+0x29>
    ab8d:	ff                   	(bad)
    ab8e:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    // 释放文件对象
    mem_free(file, sizeof(file_t));
    ab92:	83 ec 08             	sub    $0x8,%sp
    ab95:	68 1c 02             	push   $0x21c
    ab98:	00 00                	add    %al,(%bx,%si)
    ab9a:	ff 75 08             	push   0x8(%di)
    ab9d:	e8 3f 23             	call   cedf <mem_alloc+0xfb>
    aba0:	00 00                	add    %al,(%bx,%si)
    aba2:	83 c4 10             	add    $0x10,%sp
    aba5:	90                   	nop
    aba6:	c9                   	leave
    aba7:	c3                   	ret

0000aba8 <max>:
static inline int max(int val1,int val2) {
    aba8:	55                   	push   %bp
    aba9:	89 e5                	mov    %sp,%bp
    if(val1>val2){
    abab:	8b 45 08             	mov    0x8(%di),%ax
    abae:	3b 45 0c             	cmp    0xc(%di),%ax
    abb1:	7e 05                	jle    abb8 <max+0x10>
        return val1;
    abb3:	8b 45 08             	mov    0x8(%di),%ax
    abb6:	eb 03                	jmp    abbb <max+0x13>
    return val2;
    abb8:	8b 45 0c             	mov    0xc(%di),%ax
}
    abbb:	5d                   	pop    %bp
    abbc:	c3                   	ret

0000abbd <min>:

static inline int min(int val1,int val2) {
    abbd:	55                   	push   %bp
    abbe:	89 e5                	mov    %sp,%bp
    if(val1<val2){
    abc0:	8b 45 08             	mov    0x8(%di),%ax
    abc3:	3b 45 0c             	cmp    0xc(%di),%ax
    abc6:	7d 05                	jge    abcd <min+0x10>
        return val1;
    abc8:	8b 45 08             	mov    0x8(%di),%ax
    abcb:	eb 03                	jmp    abd0 <min+0x13>
    }
    return val2;
    abcd:	8b 45 0c             	mov    0xc(%di),%ax
}
    abd0:	5d                   	pop    %bp
    abd1:	c3                   	ret

0000abd2 <bg_init>:
frame_t *bg_frame;
frame_t *cursor_frame;
frame_t *window_frame;
//frame_t *img_frame;

void bg_init() {
    abd2:	55                   	push   %bp
    abd3:	89 e5                	mov    %sp,%bp
    abd5:	83 ec 18             	sub    $0x18,%sp
    uint16_t xsize=bg_frame->w;
    abd8:	a1 e0 ec             	mov    0xece0,%ax
    abdb:	00 00                	add    %al,(%bx,%si)
    abdd:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    abe1:	66 89 45 f6          	mov    %eax,-0xa(%di)
    uint16_t ysize=bg_frame->h;
    abe5:	a1 e0 ec             	mov    0xece0,%ax
    abe8:	00 00                	add    %al,(%bx,%si)
    abea:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    abee:	66 89 45 f4          	mov    %eax,-0xc(%di)
    uint8_t *vram =bg_frame->vram;
    abf2:	a1 e0 ec             	mov    0xece0,%ax
    abf5:	00 00                	add    %al,(%bx,%si)
    abf7:	8b 00                	mov    (%bx,%si),%ax
    abf9:	89 45 f0             	mov    %ax,-0x10(%di)

    fill_rect(vram, xsize, 0, 0, xsize, ysize - 28, COL_008484);
    abfc:	0f b7 45 f4          	movzww -0xc(%di),%ax
    ac00:	83 e8 1c             	sub    $0x1c,%ax
    ac03:	0f b7 c8             	movzww %ax,%cx
    ac06:	0f b7 55 f6          	movzww -0xa(%di),%dx
    ac0a:	0f b7 45 f6          	movzww -0xa(%di),%ax
    ac0e:	83 ec 04             	sub    $0x4,%sp
    ac11:	6a 0e                	push   $0xe
    ac13:	51                   	push   %cx
    ac14:	52                   	push   %dx
    ac15:	6a 00                	push   $0x0
    ac17:	6a 00                	push   $0x0
    ac19:	50                   	push   %ax
    ac1a:	ff 75 f0             	push   -0x10(%di)
    ac1d:	e8 32 14             	call   c052 <fill_alpha+0x34>
    ac20:	00 00                	add    %al,(%bx,%si)
    ac22:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, xsize, 0, ysize - 28, xsize, 1, COL_C6C6C6);
    ac25:	0f b7 4d f6          	movzww -0xa(%di),%cx
    ac29:	0f b7 45 f4          	movzww -0xc(%di),%ax
    ac2d:	83 e8 1c             	sub    $0x1c,%ax
    ac30:	0f b7 d0             	movzww %ax,%dx
    ac33:	0f b7 45 f6          	movzww -0xa(%di),%ax
    ac37:	83 ec 04             	sub    $0x4,%sp
    ac3a:	6a 08                	push   $0x8
    ac3c:	6a 01                	push   $0x1
    ac3e:	51                   	push   %cx
    ac3f:	52                   	push   %dx
    ac40:	6a 00                	push   $0x0
    ac42:	50                   	push   %ax
    ac43:	ff 75 f0             	push   -0x10(%di)
    ac46:	e8 09 14             	call   c052 <fill_alpha+0x34>
    ac49:	00 00                	add    %al,(%bx,%si)
    ac4b:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, xsize, 0, ysize - 27, xsize, 1, COL_FFFFFF);
    ac4e:	0f b7 4d f6          	movzww -0xa(%di),%cx
    ac52:	0f b7 45 f4          	movzww -0xc(%di),%ax
    ac56:	83 e8 1b             	sub    $0x1b,%ax
    ac59:	0f b7 d0             	movzww %ax,%dx
    ac5c:	0f b7 45 f6          	movzww -0xa(%di),%ax
    ac60:	83 ec 04             	sub    $0x4,%sp
    ac63:	6a 07                	push   $0x7
    ac65:	6a 01                	push   $0x1
    ac67:	51                   	push   %cx
    ac68:	52                   	push   %dx
    ac69:	6a 00                	push   $0x0
    ac6b:	50                   	push   %ax
    ac6c:	ff 75 f0             	push   -0x10(%di)
    ac6f:	e8 e0 13             	call   c052 <fill_alpha+0x34>
    ac72:	00 00                	add    %al,(%bx,%si)
    ac74:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, xsize, 0, ysize - 26, xsize, 26, COL_C6C6C6);
    ac77:	0f b7 4d f6          	movzww -0xa(%di),%cx
    ac7b:	0f b7 45 f4          	movzww -0xc(%di),%ax
    ac7f:	83 e8 1a             	sub    $0x1a,%ax
    ac82:	0f b7 d0             	movzww %ax,%dx
    ac85:	0f b7 45 f6          	movzww -0xa(%di),%ax
    ac89:	83 ec 04             	sub    $0x4,%sp
    ac8c:	6a 08                	push   $0x8
    ac8e:	6a 1a                	push   $0x1a
    ac90:	51                   	push   %cx
    ac91:	52                   	push   %dx
    ac92:	6a 00                	push   $0x0
    ac94:	50                   	push   %ax
    ac95:	ff 75 f0             	push   -0x10(%di)
    ac98:	e8 b7 13             	call   c052 <fill_alpha+0x34>
    ac9b:	00 00                	add    %al,(%bx,%si)
    ac9d:	83 c4 20             	add    $0x20,%sp

    fill_rect(vram, xsize, 3, ysize - 24, 57, 1, COL_FFFFFF);
    aca0:	0f b7 45 f4          	movzww -0xc(%di),%ax
    aca4:	83 e8 18             	sub    $0x18,%ax
    aca7:	0f b7 d0             	movzww %ax,%dx
    acaa:	0f b7 45 f6          	movzww -0xa(%di),%ax
    acae:	83 ec 04             	sub    $0x4,%sp
    acb1:	6a 07                	push   $0x7
    acb3:	6a 01                	push   $0x1
    acb5:	6a 39                	push   $0x39
    acb7:	52                   	push   %dx
    acb8:	6a 03                	push   $0x3
    acba:	50                   	push   %ax
    acbb:	ff 75 f0             	push   -0x10(%di)
    acbe:	e8 91 13             	call   c052 <fill_alpha+0x34>
    acc1:	00 00                	add    %al,(%bx,%si)
    acc3:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, xsize, 2, ysize - 24, 1, 21, COL_FFFFFF);
    acc6:	0f b7 45 f4          	movzww -0xc(%di),%ax
    acca:	83 e8 18             	sub    $0x18,%ax
    accd:	0f b7 d0             	movzww %ax,%dx
    acd0:	0f b7 45 f6          	movzww -0xa(%di),%ax
    acd4:	83 ec 04             	sub    $0x4,%sp
    acd7:	6a 07                	push   $0x7
    acd9:	6a 15                	push   $0x15
    acdb:	6a 01                	push   $0x1
    acdd:	52                   	push   %dx
    acde:	6a 02                	push   $0x2
    ace0:	50                   	push   %ax
    ace1:	ff 75 f0             	push   -0x10(%di)
    ace4:	e8 6b 13             	call   c052 <fill_alpha+0x34>
    ace7:	00 00                	add    %al,(%bx,%si)
    ace9:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, xsize, 3, ysize - 4, 57, 1, COL_848484);
    acec:	0f b7 45 f4          	movzww -0xc(%di),%ax
    acf0:	83 e8 04             	sub    $0x4,%ax
    acf3:	0f b7 d0             	movzww %ax,%dx
    acf6:	0f b7 45 f6          	movzww -0xa(%di),%ax
    acfa:	83 ec 04             	sub    $0x4,%sp
    acfd:	6a 0f                	push   $0xf
    acff:	6a 01                	push   $0x1
    ad01:	6a 39                	push   $0x39
    ad03:	52                   	push   %dx
    ad04:	6a 03                	push   $0x3
    ad06:	50                   	push   %ax
    ad07:	ff 75 f0             	push   -0x10(%di)
    ad0a:	e8 45 13             	call   c052 <fill_alpha+0x34>
    ad0d:	00 00                	add    %al,(%bx,%si)
    ad0f:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, xsize, 59, ysize - 23, 1, 19, COL_848484);
    ad12:	0f b7 45 f4          	movzww -0xc(%di),%ax
    ad16:	83 e8 17             	sub    $0x17,%ax
    ad19:	0f b7 d0             	movzww %ax,%dx
    ad1c:	0f b7 45 f6          	movzww -0xa(%di),%ax
    ad20:	83 ec 04             	sub    $0x4,%sp
    ad23:	6a 0f                	push   $0xf
    ad25:	6a 13                	push   $0x13
    ad27:	6a 01                	push   $0x1
    ad29:	52                   	push   %dx
    ad2a:	6a 3b                	push   $0x3b
    ad2c:	50                   	push   %ax
    ad2d:	ff 75 f0             	push   -0x10(%di)
    ad30:	e8 1f 13             	call   c052 <fill_alpha+0x34>
    ad33:	00 00                	add    %al,(%bx,%si)
    ad35:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, xsize, 2, ysize - 3, 58, 1, COL_000000);
    ad38:	0f b7 45 f4          	movzww -0xc(%di),%ax
    ad3c:	83 e8 03             	sub    $0x3,%ax
    ad3f:	0f b7 d0             	movzww %ax,%dx
    ad42:	0f b7 45 f6          	movzww -0xa(%di),%ax
    ad46:	83 ec 04             	sub    $0x4,%sp
    ad49:	6a 00                	push   $0x0
    ad4b:	6a 01                	push   $0x1
    ad4d:	6a 3a                	push   $0x3a
    ad4f:	52                   	push   %dx
    ad50:	6a 02                	push   $0x2
    ad52:	50                   	push   %ax
    ad53:	ff 75 f0             	push   -0x10(%di)
    ad56:	e8 f9 12             	call   c052 <fill_alpha+0x34>
    ad59:	00 00                	add    %al,(%bx,%si)
    ad5b:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, xsize, 60, ysize - 24, 1, 22, COL_000000);
    ad5e:	0f b7 45 f4          	movzww -0xc(%di),%ax
    ad62:	83 e8 18             	sub    $0x18,%ax
    ad65:	0f b7 d0             	movzww %ax,%dx
    ad68:	0f b7 45 f6          	movzww -0xa(%di),%ax
    ad6c:	83 ec 04             	sub    $0x4,%sp
    ad6f:	6a 00                	push   $0x0
    ad71:	6a 16                	push   $0x16
    ad73:	6a 01                	push   $0x1
    ad75:	52                   	push   %dx
    ad76:	6a 3c                	push   $0x3c
    ad78:	50                   	push   %ax
    ad79:	ff 75 f0             	push   -0x10(%di)
    ad7c:	e8 d3 12             	call   c052 <fill_alpha+0x34>
    ad7f:	00 00                	add    %al,(%bx,%si)
    ad81:	83 c4 20             	add    $0x20,%sp

    fill_rect(vram, xsize, xsize - 47, ysize - 24, 44, 1, COL_848484);
    ad84:	0f b7 45 f4          	movzww -0xc(%di),%ax
    ad88:	83 e8 18             	sub    $0x18,%ax
    ad8b:	0f b7 c8             	movzww %ax,%cx
    ad8e:	0f b7 45 f6          	movzww -0xa(%di),%ax
    ad92:	83 e8 2f             	sub    $0x2f,%ax
    ad95:	0f b7 d0             	movzww %ax,%dx
    ad98:	0f b7 45 f6          	movzww -0xa(%di),%ax
    ad9c:	83 ec 04             	sub    $0x4,%sp
    ad9f:	6a 0f                	push   $0xf
    ada1:	6a 01                	push   $0x1
    ada3:	6a 2c                	push   $0x2c
    ada5:	51                   	push   %cx
    ada6:	52                   	push   %dx
    ada7:	50                   	push   %ax
    ada8:	ff 75 f0             	push   -0x10(%di)
    adab:	e8 a4 12             	call   c052 <fill_alpha+0x34>
    adae:	00 00                	add    %al,(%bx,%si)
    adb0:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, xsize, xsize - 47, ysize - 23, 1, 20, COL_848484);
    adb3:	0f b7 45 f4          	movzww -0xc(%di),%ax
    adb7:	83 e8 17             	sub    $0x17,%ax
    adba:	0f b7 c8             	movzww %ax,%cx
    adbd:	0f b7 45 f6          	movzww -0xa(%di),%ax
    adc1:	83 e8 2f             	sub    $0x2f,%ax
    adc4:	0f b7 d0             	movzww %ax,%dx
    adc7:	0f b7 45 f6          	movzww -0xa(%di),%ax
    adcb:	83 ec 04             	sub    $0x4,%sp
    adce:	6a 0f                	push   $0xf
    add0:	6a 14                	push   $0x14
    add2:	6a 01                	push   $0x1
    add4:	51                   	push   %cx
    add5:	52                   	push   %dx
    add6:	50                   	push   %ax
    add7:	ff 75 f0             	push   -0x10(%di)
    adda:	e8 75 12             	call   c052 <fill_alpha+0x34>
    addd:	00 00                	add    %al,(%bx,%si)
    addf:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, xsize, xsize - 47, ysize - 3, 44, 1, COL_FFFFFF);
    ade2:	0f b7 45 f4          	movzww -0xc(%di),%ax
    ade6:	83 e8 03             	sub    $0x3,%ax
    ade9:	0f b7 c8             	movzww %ax,%cx
    adec:	0f b7 45 f6          	movzww -0xa(%di),%ax
    adf0:	83 e8 2f             	sub    $0x2f,%ax
    adf3:	0f b7 d0             	movzww %ax,%dx
    adf6:	0f b7 45 f6          	movzww -0xa(%di),%ax
    adfa:	83 ec 04             	sub    $0x4,%sp
    adfd:	6a 07                	push   $0x7
    adff:	6a 01                	push   $0x1
    ae01:	6a 2c                	push   $0x2c
    ae03:	51                   	push   %cx
    ae04:	52                   	push   %dx
    ae05:	50                   	push   %ax
    ae06:	ff 75 f0             	push   -0x10(%di)
    ae09:	e8 46 12             	call   c052 <fill_alpha+0x34>
    ae0c:	00 00                	add    %al,(%bx,%si)
    ae0e:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, xsize, xsize - 3, ysize - 24, 1, 22, COL_FFFFFF);
    ae11:	0f b7 45 f4          	movzww -0xc(%di),%ax
    ae15:	83 e8 18             	sub    $0x18,%ax
    ae18:	0f b7 c8             	movzww %ax,%cx
    ae1b:	0f b7 45 f6          	movzww -0xa(%di),%ax
    ae1f:	83 e8 03             	sub    $0x3,%ax
    ae22:	0f b7 d0             	movzww %ax,%dx
    ae25:	0f b7 45 f6          	movzww -0xa(%di),%ax
    ae29:	83 ec 04             	sub    $0x4,%sp
    ae2c:	6a 07                	push   $0x7
    ae2e:	6a 16                	push   $0x16
    ae30:	6a 01                	push   $0x1
    ae32:	51                   	push   %cx
    ae33:	52                   	push   %dx
    ae34:	50                   	push   %ax
    ae35:	ff 75 f0             	push   -0x10(%di)
    ae38:	e8 17 12             	call   c052 <fill_alpha+0x34>
    ae3b:	00 00                	add    %al,(%bx,%si)
    ae3d:	83 c4 20             	add    $0x20,%sp

    draw_str(vram, xsize, 22, 22, "Hello World", COL_00FFFF);
    ae40:	0f b7 45 f6          	movzww -0xa(%di),%ax
    ae44:	83 ec 08             	sub    $0x8,%sp
    ae47:	6a 06                	push   $0x6
    ae49:	68 4d da             	push   $0xda4d
    ae4c:	00 00                	add    %al,(%bx,%si)
    ae4e:	6a 16                	push   $0x16
    ae50:	6a 16                	push   $0x16
    ae52:	50                   	push   %ax
    ae53:	ff 75 f0             	push   -0x10(%di)
    ae56:	e8 bd 14             	call   c316 <draw_char+0xb1>
    ae59:	00 00                	add    %al,(%bx,%si)
    ae5b:	83 c4 20             	add    $0x20,%sp
    draw_block(vram,xsize,ysize,SCREEN_W-32,0,32,32,img);
    ae5e:	8b 0d                	mov    (%di),%cx
    ae60:	90                   	nop
    ae61:	ed                   	in     (%dx),%ax
    ae62:	00 00                	add    %al,(%bx,%si)
    ae64:	0f b7 55 f4          	movzww -0xc(%di),%dx
    ae68:	0f b7 45 f6          	movzww -0xa(%di),%ax
    ae6c:	51                   	push   %cx
    ae6d:	6a 20                	push   $0x20
    ae6f:	6a 20                	push   $0x20
    ae71:	6a 00                	push   $0x0
    ae73:	68 20 01             	push   $0x120
    ae76:	00 00                	add    %al,(%bx,%si)
    ae78:	52                   	push   %dx
    ae79:	50                   	push   %ax
    ae7a:	ff 75 f0             	push   -0x10(%di)
    ae7d:	e8 de 0d             	call   bc5e <min+0x13>
    ae80:	00 00                	add    %al,(%bx,%si)
    ae82:	83 c4 20             	add    $0x20,%sp
}
    ae85:	90                   	nop
    ae86:	c9                   	leave
    ae87:	c3                   	ret

0000ae88 <cursor_init>:

void cursor_init() {
    ae88:	55                   	push   %bp
    ae89:	89 e5                	mov    %sp,%bp
    ae8b:	53                   	push   %bx
    ae8c:	83 ec 04             	sub    $0x4,%sp
//    cursor_frame->flag|=FRAME_TOP; // 鼠标设置为最高
    cursor_frame->flag|=FRAME_ALPHA;// 鼠标包含透明图层
    ae8f:	a1 e4 ec             	mov    0xece4,%ax
    ae92:	00 00                	add    %al,(%bx,%si)
    ae94:	0f b6 50 12          	movzbw 0x12(%bx,%si),%dx
    ae98:	a1 e4 ec             	mov    0xece4,%ax
    ae9b:	00 00                	add    %al,(%bx,%si)
    ae9d:	83 ca 08             	or     $0x8,%dx
    aea0:	88 50 12             	mov    %dl,0x12(%bx,%si)
    cursor_frame->order=0xffff; // 设置为最高
    aea3:	a1 e4 ec             	mov    0xece4,%ax
    aea6:	00 00                	add    %al,(%bx,%si)
    aea8:	66 c7 40 10 ff ff a1 	movl   $0xe4a1ffff,0x10(%bx,%si)
    aeaf:	e4 
    fill_alpha(cursor_frame->vram, cursor_frame->w, cursor_frame->h);
    aeb0:	ec                   	in     (%dx),%al
    aeb1:	00 00                	add    %al,(%bx,%si)
    aeb3:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    aeb7:	0f b7 c8             	movzww %ax,%cx
    aeba:	a1 e4 ec             	mov    0xece4,%ax
    aebd:	00 00                	add    %al,(%bx,%si)
    aebf:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    aec3:	0f b7 d0             	movzww %ax,%dx
    aec6:	a1 e4 ec             	mov    0xece4,%ax
    aec9:	00 00                	add    %al,(%bx,%si)
    aecb:	8b 00                	mov    (%bx,%si),%ax
    aecd:	83 ec 04             	sub    $0x4,%sp
    aed0:	51                   	push   %cx
    aed1:	52                   	push   %dx
    aed2:	50                   	push   %ax
    aed3:	e8 46 11             	call   c01c <draw_block_sub_alpha+0xee>
    aed6:	00 00                	add    %al,(%bx,%si)
    aed8:	83 c4 10             	add    $0x10,%sp
    draw_block(cursor_frame->vram, cursor_frame->w,cursor_frame->h, 0, 0, 16, 16, cursor);
    aedb:	8b 1d                	mov    (%di),%bx
    aedd:	88 ed                	mov    %ch,%ch
    aedf:	00 00                	add    %al,(%bx,%si)
    aee1:	a1 e4 ec             	mov    0xece4,%ax
    aee4:	00 00                	add    %al,(%bx,%si)
    aee6:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    aeea:	0f b7 c8             	movzww %ax,%cx
    aeed:	a1 e4 ec             	mov    0xece4,%ax
    aef0:	00 00                	add    %al,(%bx,%si)
    aef2:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    aef6:	0f b7 d0             	movzww %ax,%dx
    aef9:	a1 e4 ec             	mov    0xece4,%ax
    aefc:	00 00                	add    %al,(%bx,%si)
    aefe:	8b 00                	mov    (%bx,%si),%ax
    af00:	53                   	push   %bx
    af01:	6a 10                	push   $0x10
    af03:	6a 10                	push   $0x10
    af05:	6a 00                	push   $0x0
    af07:	6a 00                	push   $0x0
    af09:	51                   	push   %cx
    af0a:	52                   	push   %dx
    af0b:	50                   	push   %ax
    af0c:	e8 4f 0d             	call   bc5e <min+0x13>
    af0f:	00 00                	add    %al,(%bx,%si)
    af11:	83 c4 20             	add    $0x20,%sp
}
    af14:	90                   	nop
    af15:	8b 5d fc             	mov    -0x4(%di),%bx
    af18:	c9                   	leave
    af19:	c3                   	ret

0000af1a <draw_window>:

void draw_window(uint8_t *vram, uint16_t w, uint16_t h, char *title) {
    af1a:	55                   	push   %bp
    af1b:	89 e5                	mov    %sp,%bp
    af1d:	53                   	push   %bx
    af1e:	83 ec 14             	sub    $0x14,%sp
    af21:	8b 55 0c             	mov    0xc(%di),%dx
    af24:	8b 45 10             	mov    0x10(%di),%ax
    af27:	66 89 55 f4          	mov    %edx,-0xc(%di)
    af2b:	66 89 45 f0          	mov    %eax,-0x10(%di)
    fill_rect(vram, w, 0, 0, w, 1, COL_C6C6C6);
    af2f:	0f b7 55 f4          	movzww -0xc(%di),%dx
    af33:	0f b7 45 f4          	movzww -0xc(%di),%ax
    af37:	83 ec 04             	sub    $0x4,%sp
    af3a:	6a 08                	push   $0x8
    af3c:	6a 01                	push   $0x1
    af3e:	52                   	push   %dx
    af3f:	6a 00                	push   $0x0
    af41:	6a 00                	push   $0x0
    af43:	50                   	push   %ax
    af44:	ff 75 08             	push   0x8(%di)
    af47:	e8 08 11             	call   c052 <fill_alpha+0x34>
    af4a:	00 00                	add    %al,(%bx,%si)
    af4c:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, w, 1, 1, w - 2, 1, COL_FFFFFF);
    af4f:	0f b7 45 f4          	movzww -0xc(%di),%ax
    af53:	83 e8 02             	sub    $0x2,%ax
    af56:	0f b7 d0             	movzww %ax,%dx
    af59:	0f b7 45 f4          	movzww -0xc(%di),%ax
    af5d:	83 ec 04             	sub    $0x4,%sp
    af60:	6a 07                	push   $0x7
    af62:	6a 01                	push   $0x1
    af64:	52                   	push   %dx
    af65:	6a 01                	push   $0x1
    af67:	6a 01                	push   $0x1
    af69:	50                   	push   %ax
    af6a:	ff 75 08             	push   0x8(%di)
    af6d:	e8 e2 10             	call   c052 <fill_alpha+0x34>
    af70:	00 00                	add    %al,(%bx,%si)
    af72:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, w, 0, 0, 0, h, COL_C6C6C6);
    af75:	0f b7 55 f0          	movzww -0x10(%di),%dx
    af79:	0f b7 45 f4          	movzww -0xc(%di),%ax
    af7d:	83 ec 04             	sub    $0x4,%sp
    af80:	6a 08                	push   $0x8
    af82:	52                   	push   %dx
    af83:	6a 00                	push   $0x0
    af85:	6a 00                	push   $0x0
    af87:	6a 00                	push   $0x0
    af89:	50                   	push   %ax
    af8a:	ff 75 08             	push   0x8(%di)
    af8d:	e8 c2 10             	call   c052 <fill_alpha+0x34>
    af90:	00 00                	add    %al,(%bx,%si)
    af92:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, w, 1, 1, 1, h - 2, COL_FFFFFF);
    af95:	0f b7 45 f0          	movzww -0x10(%di),%ax
    af99:	83 e8 02             	sub    $0x2,%ax
    af9c:	0f b7 d0             	movzww %ax,%dx
    af9f:	0f b7 45 f4          	movzww -0xc(%di),%ax
    afa3:	83 ec 04             	sub    $0x4,%sp
    afa6:	6a 07                	push   $0x7
    afa8:	52                   	push   %dx
    afa9:	6a 01                	push   $0x1
    afab:	6a 01                	push   $0x1
    afad:	6a 01                	push   $0x1
    afaf:	50                   	push   %ax
    afb0:	ff 75 08             	push   0x8(%di)
    afb3:	e8 9c 10             	call   c052 <fill_alpha+0x34>
    afb6:	00 00                	add    %al,(%bx,%si)
    afb8:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, w, w - 2, 1, 1, h - 2, COL_848484);
    afbb:	0f b7 45 f0          	movzww -0x10(%di),%ax
    afbf:	83 e8 02             	sub    $0x2,%ax
    afc2:	0f b7 c8             	movzww %ax,%cx
    afc5:	0f b7 45 f4          	movzww -0xc(%di),%ax
    afc9:	83 e8 02             	sub    $0x2,%ax
    afcc:	0f b7 d0             	movzww %ax,%dx
    afcf:	0f b7 45 f4          	movzww -0xc(%di),%ax
    afd3:	83 ec 04             	sub    $0x4,%sp
    afd6:	6a 0f                	push   $0xf
    afd8:	51                   	push   %cx
    afd9:	6a 01                	push   $0x1
    afdb:	6a 01                	push   $0x1
    afdd:	52                   	push   %dx
    afde:	50                   	push   %ax
    afdf:	ff 75 08             	push   0x8(%di)
    afe2:	e8 6d 10             	call   c052 <fill_alpha+0x34>
    afe5:	00 00                	add    %al,(%bx,%si)
    afe7:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, w, w - 1, 0, 1, h, COL_000000);
    afea:	0f b7 4d f0          	movzww -0x10(%di),%cx
    afee:	0f b7 45 f4          	movzww -0xc(%di),%ax
    aff2:	83 e8 01             	sub    $0x1,%ax
    aff5:	0f b7 d0             	movzww %ax,%dx
    aff8:	0f b7 45 f4          	movzww -0xc(%di),%ax
    affc:	83 ec 04             	sub    $0x4,%sp
    afff:	6a 00                	push   $0x0
    b001:	51                   	push   %cx
    b002:	6a 01                	push   $0x1
    b004:	6a 00                	push   $0x0
    b006:	52                   	push   %dx
    b007:	50                   	push   %ax
    b008:	ff 75 08             	push   0x8(%di)
    b00b:	e8 44 10             	call   c052 <fill_alpha+0x34>
    b00e:	00 00                	add    %al,(%bx,%si)
    b010:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, w, 2, 2, w - 4, h - 4, COL_C6C6C6);
    b013:	0f b7 45 f0          	movzww -0x10(%di),%ax
    b017:	83 e8 04             	sub    $0x4,%ax
    b01a:	0f b7 c8             	movzww %ax,%cx
    b01d:	0f b7 45 f4          	movzww -0xc(%di),%ax
    b021:	83 e8 04             	sub    $0x4,%ax
    b024:	0f b7 d0             	movzww %ax,%dx
    b027:	0f b7 45 f4          	movzww -0xc(%di),%ax
    b02b:	83 ec 04             	sub    $0x4,%sp
    b02e:	6a 08                	push   $0x8
    b030:	51                   	push   %cx
    b031:	52                   	push   %dx
    b032:	6a 02                	push   $0x2
    b034:	6a 02                	push   $0x2
    b036:	50                   	push   %ax
    b037:	ff 75 08             	push   0x8(%di)
    b03a:	e8 15 10             	call   c052 <fill_alpha+0x34>
    b03d:	00 00                	add    %al,(%bx,%si)
    b03f:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, w, 3, 3, w - 6, 18, COL_000084);
    b042:	0f b7 45 f4          	movzww -0xc(%di),%ax
    b046:	83 e8 06             	sub    $0x6,%ax
    b049:	0f b7 d0             	movzww %ax,%dx
    b04c:	0f b7 45 f4          	movzww -0xc(%di),%ax
    b050:	83 ec 04             	sub    $0x4,%sp
    b053:	6a 0c                	push   $0xc
    b055:	6a 12                	push   $0x12
    b057:	52                   	push   %dx
    b058:	6a 03                	push   $0x3
    b05a:	6a 03                	push   $0x3
    b05c:	50                   	push   %ax
    b05d:	ff 75 08             	push   0x8(%di)
    b060:	e8 ef 0f             	call   c052 <fill_alpha+0x34>
    b063:	00 00                	add    %al,(%bx,%si)
    b065:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, w, 1, h - 2, w - 2, 1, COL_848484);
    b068:	0f b7 45 f4          	movzww -0xc(%di),%ax
    b06c:	83 e8 02             	sub    $0x2,%ax
    b06f:	0f b7 c8             	movzww %ax,%cx
    b072:	0f b7 45 f0          	movzww -0x10(%di),%ax
    b076:	83 e8 02             	sub    $0x2,%ax
    b079:	0f b7 d0             	movzww %ax,%dx
    b07c:	0f b7 45 f4          	movzww -0xc(%di),%ax
    b080:	83 ec 04             	sub    $0x4,%sp
    b083:	6a 0f                	push   $0xf
    b085:	6a 01                	push   $0x1
    b087:	51                   	push   %cx
    b088:	52                   	push   %dx
    b089:	6a 01                	push   $0x1
    b08b:	50                   	push   %ax
    b08c:	ff 75 08             	push   0x8(%di)
    b08f:	e8 c0 0f             	call   c052 <fill_alpha+0x34>
    b092:	00 00                	add    %al,(%bx,%si)
    b094:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, w, 0, h - 1, w, 1, COL_000000);
    b097:	0f b7 4d f4          	movzww -0xc(%di),%cx
    b09b:	0f b7 45 f0          	movzww -0x10(%di),%ax
    b09f:	83 e8 01             	sub    $0x1,%ax
    b0a2:	0f b7 d0             	movzww %ax,%dx
    b0a5:	0f b7 45 f4          	movzww -0xc(%di),%ax
    b0a9:	83 ec 04             	sub    $0x4,%sp
    b0ac:	6a 00                	push   $0x0
    b0ae:	6a 01                	push   $0x1
    b0b0:	51                   	push   %cx
    b0b1:	52                   	push   %dx
    b0b2:	6a 00                	push   $0x0
    b0b4:	50                   	push   %ax
    b0b5:	ff 75 08             	push   0x8(%di)
    b0b8:	e8 97 0f             	call   c052 <fill_alpha+0x34>
    b0bb:	00 00                	add    %al,(%bx,%si)
    b0bd:	83 c4 20             	add    $0x20,%sp

    draw_str(vram, w, 4, 4, title, COL_FFFFFF);
    b0c0:	0f b7 45 f4          	movzww -0xc(%di),%ax
    b0c4:	83 ec 08             	sub    $0x8,%sp
    b0c7:	6a 07                	push   $0x7
    b0c9:	ff 75 14             	push   0x14(%di)
    b0cc:	6a 04                	push   $0x4
    b0ce:	6a 04                	push   $0x4
    b0d0:	50                   	push   %ax
    b0d1:	ff 75 08             	push   0x8(%di)
    b0d4:	e8 3f 12             	call   c316 <draw_char+0xb1>
    b0d7:	00 00                	add    %al,(%bx,%si)
    b0d9:	83 c4 20             	add    $0x20,%sp
    draw_block(vram, w,h, w - 21, 5, 16, 14, close);
    b0dc:	8b 0d                	mov    (%di),%cx
    b0de:	8c ed                	mov    %gs,%bp
    b0e0:	00 00                	add    %al,(%bx,%si)
    b0e2:	0f b7 45 f4          	movzww -0xc(%di),%ax
    b0e6:	8d 58 eb             	lea    -0x15(%bx,%si),%bx
    b0e9:	0f b7 55 f0          	movzww -0x10(%di),%dx
    b0ed:	0f b7 45 f4          	movzww -0xc(%di),%ax
    b0f1:	51                   	push   %cx
    b0f2:	6a 0e                	push   $0xe
    b0f4:	6a 10                	push   $0x10
    b0f6:	6a 05                	push   $0x5
    b0f8:	53                   	push   %bx
    b0f9:	52                   	push   %dx
    b0fa:	50                   	push   %ax
    b0fb:	ff 75 08             	push   0x8(%di)
    b0fe:	e8 5d 0b             	call   bc5e <min+0x13>
    b101:	00 00                	add    %al,(%bx,%si)
    b103:	83 c4 20             	add    $0x20,%sp
}
    b106:	90                   	nop
    b107:	8b 5d fc             	mov    -0x4(%di),%bx
    b10a:	c9                   	leave
    b10b:	c3                   	ret

0000b10c <window_close>:

// draw_window 的关闭点击判断
bool_t window_close(frame_t *frame,int x,int y){
    b10c:	55                   	push   %bp
    b10d:	89 e5                	mov    %sp,%bp
    b10f:	83 ec 10             	sub    $0x10,%sp
    int left=frame->x+frame->w-21;
    b112:	8b 45 08             	mov    0x8(%di),%ax
    b115:	8b 50 04             	mov    0x4(%bx,%si),%dx
    b118:	8b 45 08             	mov    0x8(%di),%ax
    b11b:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    b11f:	0f b7 c0             	movzww %ax,%ax
    b122:	01 d0                	add    %dx,%ax
    b124:	83 e8 15             	sub    $0x15,%ax
    b127:	89 45 fc             	mov    %ax,-0x4(%di)
    int right=left+16;
    b12a:	8b 45 fc             	mov    -0x4(%di),%ax
    b12d:	83 c0 10             	add    $0x10,%ax
    b130:	89 45 f8             	mov    %ax,-0x8(%di)
    int top=frame->y+5;
    b133:	8b 45 08             	mov    0x8(%di),%ax
    b136:	8b 40 08             	mov    0x8(%bx,%si),%ax
    b139:	83 c0 05             	add    $0x5,%ax
    b13c:	89 45 f4             	mov    %ax,-0xc(%di)
    int bottom=top+14;
    b13f:	8b 45 f4             	mov    -0xc(%di),%ax
    b142:	83 c0 0e             	add    $0xe,%ax
    b145:	89 45 f0             	mov    %ax,-0x10(%di)
    return x>=left&&x<=right&&y>=top&&y<=bottom;
    b148:	8b 45 0c             	mov    0xc(%di),%ax
    b14b:	3b 45 fc             	cmp    -0x4(%di),%ax
    b14e:	7c 1f                	jl     b16f <window_close+0x63>
    b150:	8b 45 0c             	mov    0xc(%di),%ax
    b153:	3b 45 f8             	cmp    -0x8(%di),%ax
    b156:	7f 17                	jg     b16f <window_close+0x63>
    b158:	8b 45 10             	mov    0x10(%di),%ax
    b15b:	3b 45 f4             	cmp    -0xc(%di),%ax
    b15e:	7c 0f                	jl     b16f <window_close+0x63>
    b160:	8b 45 10             	mov    0x10(%di),%ax
    b163:	3b 45 f0             	cmp    -0x10(%di),%ax
    b166:	7f 07                	jg     b16f <window_close+0x63>
    b168:	b8 01 00             	mov    $0x1,%ax
    b16b:	00 00                	add    %al,(%bx,%si)
    b16d:	eb 05                	jmp    b174 <window_close+0x68>
    b16f:	b8 00 00             	mov    $0x0,%ax
    b172:	00 00                	add    %al,(%bx,%si)
}
    b174:	c9                   	leave
    b175:	c3                   	ret

0000b176 <window_init>:

void window_init() {
    b176:	55                   	push   %bp
    b177:	89 e5                	mov    %sp,%bp
    b179:	83 ec 08             	sub    $0x8,%sp
    draw_window(window_frame->vram,window_frame->w,window_frame->h,"WINDOW");
    b17c:	a1 e8 ec             	mov    0xece8,%ax
    b17f:	00 00                	add    %al,(%bx,%si)
    b181:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    b185:	0f b7 c8             	movzww %ax,%cx
    b188:	a1 e8 ec             	mov    0xece8,%ax
    b18b:	00 00                	add    %al,(%bx,%si)
    b18d:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    b191:	0f b7 d0             	movzww %ax,%dx
    b194:	a1 e8 ec             	mov    0xece8,%ax
    b197:	00 00                	add    %al,(%bx,%si)
    b199:	8b 00                	mov    (%bx,%si),%ax
    b19b:	68 59 da             	push   $0xda59
    b19e:	00 00                	add    %al,(%bx,%si)
    b1a0:	51                   	push   %cx
    b1a1:	52                   	push   %dx
    b1a2:	50                   	push   %ax
    b1a3:	e8 72 fd             	call   af18 <cursor_init+0x90>
    b1a6:	ff                   	(bad)
    b1a7:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
    b1ab:	90                   	nop
    b1ac:	c9                   	leave
    b1ad:	c3                   	ret

0000b1ae <draw_textbox>:

void draw_textbox(uint8_t *vram,uint16_t w,int minX, int minY, int maxX, int maxY, uint8_t col) {
    b1ae:	55                   	push   %bp
    b1af:	89 e5                	mov    %sp,%bp
    b1b1:	57                   	push   %di
    b1b2:	56                   	push   %si
    b1b3:	53                   	push   %bx
    b1b4:	83 ec 1c             	sub    $0x1c,%sp
    b1b7:	8b 55 0c             	mov    0xc(%di),%dx
    b1ba:	8b 45 20             	mov    0x20(%di),%ax
    b1bd:	66 89 55 e4          	mov    %edx,-0x1c(%di)
    b1c1:	88 45 e0             	mov    %al,-0x20(%di)
    fill_rect(vram, w, minX - 2, minY - 3, maxX - minX + 4, 1, COL_848484);
    b1c4:	8b 45 18             	mov    0x18(%di),%ax
    b1c7:	89 c2                	mov    %ax,%dx
    b1c9:	8b 45 10             	mov    0x10(%di),%ax
    b1cc:	89 c1                	mov    %ax,%cx
    b1ce:	89 d0                	mov    %dx,%ax
    b1d0:	29 c8                	sub    %cx,%ax
    b1d2:	83 c0 04             	add    $0x4,%ax
    b1d5:	0f b7 d8             	movzww %ax,%bx
    b1d8:	8b 45 14             	mov    0x14(%di),%ax
    b1db:	83 e8 03             	sub    $0x3,%ax
    b1de:	0f b7 c8             	movzww %ax,%cx
    b1e1:	8b 45 10             	mov    0x10(%di),%ax
    b1e4:	83 e8 02             	sub    $0x2,%ax
    b1e7:	0f b7 d0             	movzww %ax,%dx
    b1ea:	0f b7 45 e4          	movzww -0x1c(%di),%ax
    b1ee:	83 ec 04             	sub    $0x4,%sp
    b1f1:	6a 0f                	push   $0xf
    b1f3:	6a 01                	push   $0x1
    b1f5:	53                   	push   %bx
    b1f6:	51                   	push   %cx
    b1f7:	52                   	push   %dx
    b1f8:	50                   	push   %ax
    b1f9:	ff 75 08             	push   0x8(%di)
    b1fc:	e8 53 0e             	call   c052 <fill_alpha+0x34>
    b1ff:	00 00                	add    %al,(%bx,%si)
    b201:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, w, minX - 3, minY - 3, 1, maxY - minY + 5, COL_848484);
    b204:	8b 45 1c             	mov    0x1c(%di),%ax
    b207:	89 c2                	mov    %ax,%dx
    b209:	8b 45 14             	mov    0x14(%di),%ax
    b20c:	89 c1                	mov    %ax,%cx
    b20e:	89 d0                	mov    %dx,%ax
    b210:	29 c8                	sub    %cx,%ax
    b212:	83 c0 05             	add    $0x5,%ax
    b215:	0f b7 d8             	movzww %ax,%bx
    b218:	8b 45 14             	mov    0x14(%di),%ax
    b21b:	83 e8 03             	sub    $0x3,%ax
    b21e:	0f b7 c8             	movzww %ax,%cx
    b221:	8b 45 10             	mov    0x10(%di),%ax
    b224:	83 e8 03             	sub    $0x3,%ax
    b227:	0f b7 d0             	movzww %ax,%dx
    b22a:	0f b7 45 e4          	movzww -0x1c(%di),%ax
    b22e:	83 ec 04             	sub    $0x4,%sp
    b231:	6a 0f                	push   $0xf
    b233:	53                   	push   %bx
    b234:	6a 01                	push   $0x1
    b236:	51                   	push   %cx
    b237:	52                   	push   %dx
    b238:	50                   	push   %ax
    b239:	ff 75 08             	push   0x8(%di)
    b23c:	e8 13 0e             	call   c052 <fill_alpha+0x34>
    b23f:	00 00                	add    %al,(%bx,%si)
    b241:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, w, minX - 3, maxY + 2, maxX - minX + 5, 1, COL_FFFFFF);
    b244:	8b 45 18             	mov    0x18(%di),%ax
    b247:	89 c2                	mov    %ax,%dx
    b249:	8b 45 10             	mov    0x10(%di),%ax
    b24c:	89 c1                	mov    %ax,%cx
    b24e:	89 d0                	mov    %dx,%ax
    b250:	29 c8                	sub    %cx,%ax
    b252:	83 c0 05             	add    $0x5,%ax
    b255:	0f b7 d8             	movzww %ax,%bx
    b258:	8b 45 1c             	mov    0x1c(%di),%ax
    b25b:	83 c0 02             	add    $0x2,%ax
    b25e:	0f b7 c8             	movzww %ax,%cx
    b261:	8b 45 10             	mov    0x10(%di),%ax
    b264:	83 e8 03             	sub    $0x3,%ax
    b267:	0f b7 d0             	movzww %ax,%dx
    b26a:	0f b7 45 e4          	movzww -0x1c(%di),%ax
    b26e:	83 ec 04             	sub    $0x4,%sp
    b271:	6a 07                	push   $0x7
    b273:	6a 01                	push   $0x1
    b275:	53                   	push   %bx
    b276:	51                   	push   %cx
    b277:	52                   	push   %dx
    b278:	50                   	push   %ax
    b279:	ff 75 08             	push   0x8(%di)
    b27c:	e8 d3 0d             	call   c052 <fill_alpha+0x34>
    b27f:	00 00                	add    %al,(%bx,%si)
    b281:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, w, maxX + 2, minY - 3, 1, maxY - minY + 6, COL_FFFFFF);
    b284:	8b 45 1c             	mov    0x1c(%di),%ax
    b287:	89 c2                	mov    %ax,%dx
    b289:	8b 45 14             	mov    0x14(%di),%ax
    b28c:	89 c1                	mov    %ax,%cx
    b28e:	89 d0                	mov    %dx,%ax
    b290:	29 c8                	sub    %cx,%ax
    b292:	83 c0 06             	add    $0x6,%ax
    b295:	0f b7 d8             	movzww %ax,%bx
    b298:	8b 45 14             	mov    0x14(%di),%ax
    b29b:	83 e8 03             	sub    $0x3,%ax
    b29e:	0f b7 c8             	movzww %ax,%cx
    b2a1:	8b 45 18             	mov    0x18(%di),%ax
    b2a4:	83 c0 02             	add    $0x2,%ax
    b2a7:	0f b7 d0             	movzww %ax,%dx
    b2aa:	0f b7 45 e4          	movzww -0x1c(%di),%ax
    b2ae:	83 ec 04             	sub    $0x4,%sp
    b2b1:	6a 07                	push   $0x7
    b2b3:	53                   	push   %bx
    b2b4:	6a 01                	push   $0x1
    b2b6:	51                   	push   %cx
    b2b7:	52                   	push   %dx
    b2b8:	50                   	push   %ax
    b2b9:	ff 75 08             	push   0x8(%di)
    b2bc:	e8 93 0d             	call   c052 <fill_alpha+0x34>
    b2bf:	00 00                	add    %al,(%bx,%si)
    b2c1:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, w, minX - 1, minY - 2, maxX - minX + 2, 1, COL_000000);
    b2c4:	8b 45 18             	mov    0x18(%di),%ax
    b2c7:	89 c2                	mov    %ax,%dx
    b2c9:	8b 45 10             	mov    0x10(%di),%ax
    b2cc:	89 c1                	mov    %ax,%cx
    b2ce:	89 d0                	mov    %dx,%ax
    b2d0:	29 c8                	sub    %cx,%ax
    b2d2:	83 c0 02             	add    $0x2,%ax
    b2d5:	0f b7 d8             	movzww %ax,%bx
    b2d8:	8b 45 14             	mov    0x14(%di),%ax
    b2db:	83 e8 02             	sub    $0x2,%ax
    b2de:	0f b7 c8             	movzww %ax,%cx
    b2e1:	8b 45 10             	mov    0x10(%di),%ax
    b2e4:	83 e8 01             	sub    $0x1,%ax
    b2e7:	0f b7 d0             	movzww %ax,%dx
    b2ea:	0f b7 45 e4          	movzww -0x1c(%di),%ax
    b2ee:	83 ec 04             	sub    $0x4,%sp
    b2f1:	6a 00                	push   $0x0
    b2f3:	6a 01                	push   $0x1
    b2f5:	53                   	push   %bx
    b2f6:	51                   	push   %cx
    b2f7:	52                   	push   %dx
    b2f8:	50                   	push   %ax
    b2f9:	ff 75 08             	push   0x8(%di)
    b2fc:	e8 53 0d             	call   c052 <fill_alpha+0x34>
    b2ff:	00 00                	add    %al,(%bx,%si)
    b301:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, w, minX - 2, minY - 2, 1, maxY - minY + 3, COL_000000);
    b304:	8b 45 1c             	mov    0x1c(%di),%ax
    b307:	89 c2                	mov    %ax,%dx
    b309:	8b 45 14             	mov    0x14(%di),%ax
    b30c:	89 c1                	mov    %ax,%cx
    b30e:	89 d0                	mov    %dx,%ax
    b310:	29 c8                	sub    %cx,%ax
    b312:	83 c0 03             	add    $0x3,%ax
    b315:	0f b7 d8             	movzww %ax,%bx
    b318:	8b 45 14             	mov    0x14(%di),%ax
    b31b:	83 e8 02             	sub    $0x2,%ax
    b31e:	0f b7 c8             	movzww %ax,%cx
    b321:	8b 45 10             	mov    0x10(%di),%ax
    b324:	83 e8 02             	sub    $0x2,%ax
    b327:	0f b7 d0             	movzww %ax,%dx
    b32a:	0f b7 45 e4          	movzww -0x1c(%di),%ax
    b32e:	83 ec 04             	sub    $0x4,%sp
    b331:	6a 00                	push   $0x0
    b333:	53                   	push   %bx
    b334:	6a 01                	push   $0x1
    b336:	51                   	push   %cx
    b337:	52                   	push   %dx
    b338:	50                   	push   %ax
    b339:	ff 75 08             	push   0x8(%di)
    b33c:	e8 13 0d             	call   c052 <fill_alpha+0x34>
    b33f:	00 00                	add    %al,(%bx,%si)
    b341:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, w, minX - 2, maxY + 1, maxX - minX + 3, 1, COL_C6C6C6);
    b344:	8b 45 18             	mov    0x18(%di),%ax
    b347:	89 c2                	mov    %ax,%dx
    b349:	8b 45 10             	mov    0x10(%di),%ax
    b34c:	89 c1                	mov    %ax,%cx
    b34e:	89 d0                	mov    %dx,%ax
    b350:	29 c8                	sub    %cx,%ax
    b352:	83 c0 03             	add    $0x3,%ax
    b355:	0f b7 d8             	movzww %ax,%bx
    b358:	8b 45 1c             	mov    0x1c(%di),%ax
    b35b:	83 c0 01             	add    $0x1,%ax
    b35e:	0f b7 c8             	movzww %ax,%cx
    b361:	8b 45 10             	mov    0x10(%di),%ax
    b364:	83 e8 02             	sub    $0x2,%ax
    b367:	0f b7 d0             	movzww %ax,%dx
    b36a:	0f b7 45 e4          	movzww -0x1c(%di),%ax
    b36e:	83 ec 04             	sub    $0x4,%sp
    b371:	6a 08                	push   $0x8
    b373:	6a 01                	push   $0x1
    b375:	53                   	push   %bx
    b376:	51                   	push   %cx
    b377:	52                   	push   %dx
    b378:	50                   	push   %ax
    b379:	ff 75 08             	push   0x8(%di)
    b37c:	e8 d3 0c             	call   c052 <fill_alpha+0x34>
    b37f:	00 00                	add    %al,(%bx,%si)
    b381:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, w, maxX + 1, minY - 2, 1, maxY - minY + 4, COL_C6C6C6);
    b384:	8b 45 1c             	mov    0x1c(%di),%ax
    b387:	89 c2                	mov    %ax,%dx
    b389:	8b 45 14             	mov    0x14(%di),%ax
    b38c:	89 c1                	mov    %ax,%cx
    b38e:	89 d0                	mov    %dx,%ax
    b390:	29 c8                	sub    %cx,%ax
    b392:	83 c0 04             	add    $0x4,%ax
    b395:	0f b7 d8             	movzww %ax,%bx
    b398:	8b 45 14             	mov    0x14(%di),%ax
    b39b:	83 e8 02             	sub    $0x2,%ax
    b39e:	0f b7 c8             	movzww %ax,%cx
    b3a1:	8b 45 18             	mov    0x18(%di),%ax
    b3a4:	83 c0 01             	add    $0x1,%ax
    b3a7:	0f b7 d0             	movzww %ax,%dx
    b3aa:	0f b7 45 e4          	movzww -0x1c(%di),%ax
    b3ae:	83 ec 04             	sub    $0x4,%sp
    b3b1:	6a 08                	push   $0x8
    b3b3:	53                   	push   %bx
    b3b4:	6a 01                	push   $0x1
    b3b6:	51                   	push   %cx
    b3b7:	52                   	push   %dx
    b3b8:	50                   	push   %ax
    b3b9:	ff 75 08             	push   0x8(%di)
    b3bc:	e8 93 0c             	call   c052 <fill_alpha+0x34>
    b3bf:	00 00                	add    %al,(%bx,%si)
    b3c1:	83 c4 20             	add    $0x20,%sp
    fill_rect(vram, w, minX - 1, minY - 1, maxX - minX + 2, maxY - minY + 2, col);
    b3c4:	0f b6 7d e0          	movzbw -0x20(%di),%di
    b3c8:	8b 45 1c             	mov    0x1c(%di),%ax
    b3cb:	89 c2                	mov    %ax,%dx
    b3cd:	8b 45 14             	mov    0x14(%di),%ax
    b3d0:	89 c1                	mov    %ax,%cx
    b3d2:	89 d0                	mov    %dx,%ax
    b3d4:	29 c8                	sub    %cx,%ax
    b3d6:	83 c0 02             	add    $0x2,%ax
    b3d9:	0f b7 f0             	movzww %ax,%si
    b3dc:	8b 45 18             	mov    0x18(%di),%ax
    b3df:	89 c2                	mov    %ax,%dx
    b3e1:	8b 45 10             	mov    0x10(%di),%ax
    b3e4:	89 c1                	mov    %ax,%cx
    b3e6:	89 d0                	mov    %dx,%ax
    b3e8:	29 c8                	sub    %cx,%ax
    b3ea:	83 c0 02             	add    $0x2,%ax
    b3ed:	0f b7 d8             	movzww %ax,%bx
    b3f0:	8b 45 14             	mov    0x14(%di),%ax
    b3f3:	83 e8 01             	sub    $0x1,%ax
    b3f6:	0f b7 c8             	movzww %ax,%cx
    b3f9:	8b 45 10             	mov    0x10(%di),%ax
    b3fc:	83 e8 01             	sub    $0x1,%ax
    b3ff:	0f b7 d0             	movzww %ax,%dx
    b402:	0f b7 45 e4          	movzww -0x1c(%di),%ax
    b406:	83 ec 04             	sub    $0x4,%sp
    b409:	57                   	push   %di
    b40a:	56                   	push   %si
    b40b:	53                   	push   %bx
    b40c:	51                   	push   %cx
    b40d:	52                   	push   %dx
    b40e:	50                   	push   %ax
    b40f:	ff 75 08             	push   0x8(%di)
    b412:	e8 3d 0c             	call   c052 <fill_alpha+0x34>
    b415:	00 00                	add    %al,(%bx,%si)
    b417:	83 c4 20             	add    $0x20,%sp
    // TODO
//    draw_line(vram,w,minX,minY,maxX,maxY,COL_0000FF);
}
    b41a:	90                   	nop
    b41b:	8d 65 f4             	lea    -0xc(%di),%sp
    b41e:	5b                   	pop    %bx
    b41f:	5e                   	pop    %si
    b420:	5f                   	pop    %di
    b421:	5d                   	pop    %bp
    b422:	c3                   	ret

0000b423 <init_frame>:

void init_frame(){
    b423:	55                   	push   %bp
    b424:	89 e5                	mov    %sp,%bp
    b426:	83 ec 18             	sub    $0x18,%sp
    // 加载外部资源
    file_t *file= file_open("cursor.sp",FALSE);
    b429:	83 ec 08             	sub    $0x8,%sp
    b42c:	6a 00                	push   $0x0
    b42e:	68 60 da             	push   $0xda60
    b431:	00 00                	add    %al,(%bx,%si)
    b433:	e8 a0 ef             	call   a3d6 <find_empty_sel+0x96>
    b436:	ff                   	(bad)
    b437:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    b43b:	89 45 f0             	mov    %ax,-0x10(%di)
    cursor= mem_alloc(256);
    b43e:	83 ec 0c             	sub    $0xc,%sp
    b441:	68 00 01             	push   $0x100
    b444:	00 00                	add    %al,(%bx,%si)
    b446:	e8 99 19             	call   cde2 <mem_total+0x53>
    b449:	00 00                	add    %al,(%bx,%si)
    b44b:	83 c4 10             	add    $0x10,%sp
    b44e:	a3 88 ed             	mov    %ax,0xed88
    b451:	00 00                	add    %al,(%bx,%si)
    file_read(file,256,cursor);
    b453:	a1 88 ed             	mov    0xed88,%ax
    b456:	00 00                	add    %al,(%bx,%si)
    b458:	83 ec 04             	sub    $0x4,%sp
    b45b:	50                   	push   %ax
    b45c:	68 00 01             	push   $0x100
    b45f:	00 00                	add    %al,(%bx,%si)
    b461:	ff 75 f0             	push   -0x10(%di)
    b464:	e8 38 f1             	call   a59f <make_sure_buff+0x72>
    b467:	ff                   	(bad)
    b468:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    file_close(file);
    b46c:	83 ec 0c             	sub    $0xc,%sp
    b46f:	ff 75 f0             	push   -0x10(%di)
    b472:	e8 bc f5             	call   aa31 <file_flush+0x3b>
    b475:	ff                   	(bad)
    b476:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    file= file_open("close.sp",FALSE);
    b47a:	83 ec 08             	sub    $0x8,%sp
    b47d:	6a 00                	push   $0x0
    b47f:	68 6a da             	push   $0xda6a
    b482:	00 00                	add    %al,(%bx,%si)
    b484:	e8 4f ef             	call   a3d6 <find_empty_sel+0x96>
    b487:	ff                   	(bad)
    b488:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    b48c:	89 45 f0             	mov    %ax,-0x10(%di)
    close= mem_alloc(224);
    b48f:	83 ec 0c             	sub    $0xc,%sp
    b492:	68 e0 00             	push   $0xe0
    b495:	00 00                	add    %al,(%bx,%si)
    b497:	e8 48 19             	call   cde2 <mem_total+0x53>
    b49a:	00 00                	add    %al,(%bx,%si)
    b49c:	83 c4 10             	add    $0x10,%sp
    b49f:	a3 8c ed             	mov    %ax,0xed8c
    b4a2:	00 00                	add    %al,(%bx,%si)
    file_read(file,224,close);
    b4a4:	a1 8c ed             	mov    0xed8c,%ax
    b4a7:	00 00                	add    %al,(%bx,%si)
    b4a9:	83 ec 04             	sub    $0x4,%sp
    b4ac:	50                   	push   %ax
    b4ad:	68 e0 00             	push   $0xe0
    b4b0:	00 00                	add    %al,(%bx,%si)
    b4b2:	ff 75 f0             	push   -0x10(%di)
    b4b5:	e8 e7 f0             	call   a59f <make_sure_buff+0x72>
    b4b8:	ff                   	(bad)
    b4b9:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    file_close(file);
    b4bd:	83 ec 0c             	sub    $0xc,%sp
    b4c0:	ff 75 f0             	push   -0x10(%di)
    b4c3:	e8 6b f5             	call   aa31 <file_flush+0x3b>
    b4c6:	ff                   	(bad)
    b4c7:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    file= file_open("ctj.sp",FALSE);
    b4cb:	83 ec 08             	sub    $0x8,%sp
    b4ce:	6a 00                	push   $0x0
    b4d0:	68 73 da             	push   $0xda73
    b4d3:	00 00                	add    %al,(%bx,%si)
    b4d5:	e8 fe ee             	call   a3d6 <find_empty_sel+0x96>
    b4d8:	ff                   	(bad)
    b4d9:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    b4dd:	89 45 f0             	mov    %ax,-0x10(%di)
    img= mem_alloc(1024);
    b4e0:	83 ec 0c             	sub    $0xc,%sp
    b4e3:	68 00 04             	push   $0x400
    b4e6:	00 00                	add    %al,(%bx,%si)
    b4e8:	e8 f7 18             	call   cde2 <mem_total+0x53>
    b4eb:	00 00                	add    %al,(%bx,%si)
    b4ed:	83 c4 10             	add    $0x10,%sp
    b4f0:	a3 90 ed             	mov    %ax,0xed90
    b4f3:	00 00                	add    %al,(%bx,%si)
    file_read(file,1024,img);
    b4f5:	a1 90 ed             	mov    0xed90,%ax
    b4f8:	00 00                	add    %al,(%bx,%si)
    b4fa:	83 ec 04             	sub    $0x4,%sp
    b4fd:	50                   	push   %ax
    b4fe:	68 00 04             	push   $0x400
    b501:	00 00                	add    %al,(%bx,%si)
    b503:	ff 75 f0             	push   -0x10(%di)
    b506:	e8 96 f0             	call   a59f <make_sure_buff+0x72>
    b509:	ff                   	(bad)
    b50a:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    file_close(file);
    b50e:	83 ec 0c             	sub    $0xc,%sp
    b511:	ff 75 f0             	push   -0x10(%di)
    b514:	e8 1a f5             	call   aa31 <file_flush+0x3b>
    b517:	ff                   	(bad)
    b518:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    for (int i = 0; i < FRAME_COUNT; ++i) {
    b51c:	c7 45 f4 00 00       	movw   $0x0,-0xc(%di)
    b521:	00 00                	add    %al,(%bx,%si)
    b523:	eb 1b                	jmp    b540 <init_frame+0x11d>
        frames[i]= mem_alloc(sizeof(frame_t));
    b525:	83 ec 0c             	sub    $0xc,%sp
    b528:	6a 28                	push   $0x28
    b52a:	e8 b5 18             	call   cde2 <mem_total+0x53>
    b52d:	00 00                	add    %al,(%bx,%si)
    b52f:	83 c4 10             	add    $0x10,%sp
    b532:	8b 55 f4             	mov    -0xc(%di),%dx
    b535:	89 04                	mov    %ax,(%si)
    b537:	95                   	xchg   %ax,%bp
    b538:	00 ed                	add    %ch,%ch
    b53a:	00 00                	add    %al,(%bx,%si)
    for (int i = 0; i < FRAME_COUNT; ++i) {
    b53c:	83 45 f4 01          	addw   $0x1,-0xc(%di)
    b540:	83 7d f4 1f          	cmpw   $0x1f,-0xc(%di)
    b544:	7e df                	jle    b525 <init_frame+0x102>
    }
    merge_vram= mem_alloc(VRAM_SIZE);
    b546:	83 ec 0c             	sub    $0xc,%sp
    b549:	68 00 fa             	push   $0xfa00
    b54c:	00 00                	add    %al,(%bx,%si)
    b54e:	e8 91 18             	call   cde2 <mem_total+0x53>
    b551:	00 00                	add    %al,(%bx,%si)
    b553:	83 c4 10             	add    $0x10,%sp
    b556:	a3 84 ed             	mov    %ax,0xed84
    b559:	00 00                	add    %al,(%bx,%si)
    curr_order=0;
    b55b:	66 c7 05 80 ed 00 00 	movl   $0xed80,(%di)
    b562:	00 00                	add    %al,(%bx,%si)
    bg_frame= frame_alloc(0,0,SCREEN_W,SCREEN_H);
    b564:	68 c8 00             	push   $0xc8
    b567:	00 00                	add    %al,(%bx,%si)
    b569:	68 40 01             	push   $0x140
    b56c:	00 00                	add    %al,(%bx,%si)
    b56e:	6a 00                	push   $0x0
    b570:	6a 00                	push   $0x0
    b572:	e8 80 00             	call   b5f5 <frame_free+0x4c>
    b575:	00 00                	add    %al,(%bx,%si)
    b577:	83 c4 10             	add    $0x10,%sp
    b57a:	a3 e0 ec             	mov    %ax,0xece0
    b57d:	00 00                	add    %al,(%bx,%si)
    bg_init();
    b57f:	e8 4e f6             	call   abd0 <min+0x13>
    b582:	ff                   	(bad)
    b583:	ff 6a 10             	ljmp   *0x10(%bp,%si)
//    window_frame= frame_alloc(SCREEN_W/4,SCREEN_H/4,SCREEN_W/2,SCREEN_H/2);
//    window_init();
    cursor_frame= frame_alloc(SCREEN_W/2,SCREEN_H/2,16,16);
    b586:	6a 10                	push   $0x10
    b588:	6a 64                	push   $0x64
    b58a:	68 a0 00             	push   $0xa0
    b58d:	00 00                	add    %al,(%bx,%si)
    b58f:	e8 63 00             	call   b5f5 <frame_free+0x4c>
    b592:	00 00                	add    %al,(%bx,%si)
    b594:	83 c4 10             	add    $0x10,%sp
    b597:	a3 e4 ec             	mov    %ax,0xece4
    b59a:	00 00                	add    %al,(%bx,%si)
    cursor_init();
    b59c:	e8 e7 f8             	call   ae86 <bg_init+0x2b4>
    b59f:	ff                   	(bad)
    b5a0:	ff                   	(bad)
    // 边框 28 8 8 9
//    img_frame= frame_alloc(SCREEN_W/2,SCREEN_H/2,48,69);
//    draw_window(img_frame->vram,img_frame->w,img_frame->h,"ctj.png");
    //    draw_block(img_frame->vram,img_frame->w,8,28,32,32,img);
    frame_refresh();
    b5a1:	e8 24 03             	call   b8c8 <draw_frame+0xa7>
    b5a4:	00 00                	add    %al,(%bx,%si)
}
    b5a6:	90                   	nop
    b5a7:	c9                   	leave
    b5a8:	c3                   	ret

0000b5a9 <frame_free>:

void frame_free(frame_t *frame){
    b5a9:	55                   	push   %bp
    b5aa:	89 e5                	mov    %sp,%bp
    b5ac:	83 ec 08             	sub    $0x8,%sp
    frame->used=FALSE;
    b5af:	8b 45 08             	mov    0x8(%di),%ax
    b5b2:	c7 40 14 00 00       	movw   $0x0,0x14(%bx,%si)
    b5b7:	00 00                	add    %al,(%bx,%si)
    mem_free(frame->vram,(uint32_t)frame->w*(uint32_t)frame->h);
    b5b9:	8b 45 08             	mov    0x8(%di),%ax
    b5bc:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    b5c0:	0f b7 d0             	movzww %ax,%dx
    b5c3:	8b 45 08             	mov    0x8(%di),%ax
    b5c6:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    b5ca:	0f b7 c0             	movzww %ax,%ax
    b5cd:	0f af d0             	imul   %ax,%dx
    b5d0:	8b 45 08             	mov    0x8(%di),%ax
    b5d3:	8b 00                	mov    (%bx,%si),%ax
    b5d5:	83 ec 08             	sub    $0x8,%sp
    b5d8:	52                   	push   %dx
    b5d9:	50                   	push   %ax
    b5da:	e8 02 19             	call   cedf <mem_alloc+0xfb>
    b5dd:	00 00                	add    %al,(%bx,%si)
    b5df:	83 c4 10             	add    $0x10,%sp
    fifo_free(&frame->kdb_fifo);
    b5e2:	8b 45 08             	mov    0x8(%di),%ax
    b5e5:	83 c0 1c             	add    $0x1c,%ax
    b5e8:	83 ec 0c             	sub    $0xc,%sp
    b5eb:	50                   	push   %ax
    b5ec:	e8 91 e9             	call   9f80 <fifo_init+0x4c>
    b5ef:	ff                   	(bad)
    b5f0:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
    b5f4:	90                   	nop
    b5f5:	c9                   	leave
    b5f6:	c3                   	ret

0000b5f7 <frame_alloc>:

frame_t *frame_alloc(int x,int y,uint16_t w,uint16_t h){
    b5f7:	55                   	push   %bp
    b5f8:	89 e5                	mov    %sp,%bp
    b5fa:	83 ec 28             	sub    $0x28,%sp
    b5fd:	8b 55 10             	mov    0x10(%di),%dx
    b600:	8b 45 14             	mov    0x14(%di),%ax
    b603:	66 89 55 e4          	mov    %edx,-0x1c(%di)
    b607:	66 89 45 e0          	mov    %eax,-0x20(%di)
    frame_t *frame=0;// 寻找并分配窗体
    b60b:	c7 45 f4 00 00       	movw   $0x0,-0xc(%di)
    b610:	00 00                	add    %al,(%bx,%si)
    for (int i = 0; i < FRAME_COUNT; ++i) {
    b612:	c7 45 f0 00 00       	movw   $0x0,-0x10(%di)
    b617:	00 00                	add    %al,(%bx,%si)
    b619:	eb 2e                	jmp    b649 <frame_alloc+0x52>
        if(!frames[i]->used){
    b61b:	8b 45 f0             	mov    -0x10(%di),%ax
    b61e:	8b 04                	mov    (%si),%ax
    b620:	85 00                	test   %ax,(%bx,%si)
    b622:	ed                   	in     (%dx),%ax
    b623:	00 00                	add    %al,(%bx,%si)
    b625:	8b 40 14             	mov    0x14(%bx,%si),%ax
    b628:	85 c0                	test   %ax,%ax
    b62a:	75 19                	jne    b645 <frame_alloc+0x4e>
            frame=frames[i];
    b62c:	8b 45 f0             	mov    -0x10(%di),%ax
    b62f:	8b 04                	mov    (%si),%ax
    b631:	85 00                	test   %ax,(%bx,%si)
    b633:	ed                   	in     (%dx),%ax
    b634:	00 00                	add    %al,(%bx,%si)
    b636:	89 45 f4             	mov    %ax,-0xc(%di)
            frame->used=TRUE;
    b639:	8b 45 f4             	mov    -0xc(%di),%ax
    b63c:	c7 40 14 01 00       	movw   $0x1,0x14(%bx,%si)
    b641:	00 00                	add    %al,(%bx,%si)
            break;
    b643:	eb 0a                	jmp    b64f <frame_alloc+0x58>
    for (int i = 0; i < FRAME_COUNT; ++i) {
    b645:	83 45 f0 01          	addw   $0x1,-0x10(%di)
    b649:	83 7d f0 1f          	cmpw   $0x1f,-0x10(%di)
    b64d:	7e cc                	jle    b61b <frame_alloc+0x24>
        }
    }
    if(!frame){
    b64f:	83 7d f4 00          	cmpw   $0x0,-0xc(%di)
    b653:	75 07                	jne    b65c <frame_alloc+0x65>
        return 0;
    b655:	b8 00 00             	mov    $0x0,%ax
    b658:	00 00                	add    %al,(%bx,%si)
    b65a:	eb 7b                	jmp    b6d7 <frame_alloc+0xe0>
    }

    frame->vram= mem_alloc((uint32_t)w*(uint32_t)h);
    b65c:	0f b7 55 e4          	movzww -0x1c(%di),%dx
    b660:	0f b7 45 e0          	movzww -0x20(%di),%ax
    b664:	0f af c2             	imul   %dx,%ax
    b667:	83 ec 0c             	sub    $0xc,%sp
    b66a:	50                   	push   %ax
    b66b:	e8 74 17             	call   cde2 <mem_total+0x53>
    b66e:	00 00                	add    %al,(%bx,%si)
    b670:	83 c4 10             	add    $0x10,%sp
    b673:	8b 55 f4             	mov    -0xc(%di),%dx
    b676:	89 02                	mov    %ax,(%bp,%si)
    frame->x=x;
    b678:	8b 45 f4             	mov    -0xc(%di),%ax
    b67b:	8b 55 08             	mov    0x8(%di),%dx
    b67e:	89 50 04             	mov    %dx,0x4(%bx,%si)
    frame->y=y;
    b681:	8b 45 f4             	mov    -0xc(%di),%ax
    b684:	8b 55 0c             	mov    0xc(%di),%dx
    b687:	89 50 08             	mov    %dx,0x8(%bx,%si)
    frame->w=w;
    b68a:	8b 45 f4             	mov    -0xc(%di),%ax
    b68d:	0f b7 55 e4          	movzww -0x1c(%di),%dx
    b691:	66 89 50 0c          	mov    %edx,0xc(%bx,%si)
    frame->h=h;
    b695:	8b 45 f4             	mov    -0xc(%di),%ax
    b698:	0f b7 55 e0          	movzww -0x20(%di),%dx
    b69c:	66 89 50 0e          	mov    %edx,0xe(%bx,%si)
    frame->order=curr_order++;// 默认新创建的在上面
    b6a0:	0f b7 05             	movzww (%di),%ax
    b6a3:	80 ed 00             	sub    $0x0,%ch
    b6a6:	00 8d 50 01          	add    %cl,0x150(%di)
    b6aa:	66 89 15             	mov    %edx,(%di)
    b6ad:	80 ed 00             	sub    $0x0,%ch
    b6b0:	00 8b 55 f4          	add    %cl,-0xbab(%bp,%di)
    b6b4:	66 89 42 10          	mov    %eax,0x10(%bp,%si)
    fifo_init(&frame->kdb_fifo,128);
    b6b8:	8b 45 f4             	mov    -0xc(%di),%ax
    b6bb:	83 c0 1c             	add    $0x1c,%ax
    b6be:	83 ec 08             	sub    $0x8,%sp
    b6c1:	68 80 00             	push   $0x80
    b6c4:	00 00                	add    %al,(%bx,%si)
    b6c6:	50                   	push   %ax
    b6c7:	e8 68 e8             	call   9f32 <beep+0xa4>
    b6ca:	ff                   	(bad)
    b6cb:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    frame_sort();
    b6cf:	e8 2b 00             	call   b6fd <frame_top+0x24>
    b6d2:	00 00                	add    %al,(%bx,%si)
    return frame;
    b6d4:	8b 45 f4             	mov    -0xc(%di),%ax
}
    b6d7:	c9                   	leave
    b6d8:	c3                   	ret

0000b6d9 <frame_top>:

void frame_top(frame_t *frame){ // 最好使用这个 不要直接修改 curr_order
    b6d9:	55                   	push   %bp
    b6da:	89 e5                	mov    %sp,%bp
    b6dc:	83 ec 08             	sub    $0x8,%sp
    frame->order=curr_order++;
    b6df:	0f b7 05             	movzww (%di),%ax
    b6e2:	80 ed 00             	sub    $0x0,%ch
    b6e5:	00 8d 50 01          	add    %cl,0x150(%di)
    b6e9:	66 89 15             	mov    %edx,(%di)
    b6ec:	80 ed 00             	sub    $0x0,%ch
    b6ef:	00 8b 55 08          	add    %cl,0x855(%bp,%di)
    b6f3:	66 89 42 10          	mov    %eax,0x10(%bp,%si)
    frame_sort();
    b6f7:	e8 03 00             	call   b6fd <frame_top+0x24>
    b6fa:	00 00                	add    %al,(%bx,%si)
}
    b6fc:	90                   	nop
    b6fd:	c9                   	leave
    b6fe:	c3                   	ret

0000b6ff <frame_sort>:

void frame_sort(){// order小的在前面 数量较少直接排序 循环获取第 i+1 小的放在位置i
    b6ff:	55                   	push   %bp
    b700:	89 e5                	mov    %sp,%bp
    b702:	83 ec 10             	sub    $0x10,%sp
    for (int i = 0; i < FRAME_COUNT - 1; ++i) {
    b705:	c7 45 fc 00 00       	movw   $0x0,-0x4(%di)
    b70a:	00 00                	add    %al,(%bx,%si)
    b70c:	e9 8d 00             	jmp    b79c <frame_sort+0x9d>
    b70f:	00 00                	add    %al,(%bx,%si)
        if(!frames[i]->used){
    b711:	8b 45 fc             	mov    -0x4(%di),%ax
    b714:	8b 04                	mov    (%si),%ax
    b716:	85 00                	test   %ax,(%bx,%si)
    b718:	ed                   	in     (%dx),%ax
    b719:	00 00                	add    %al,(%bx,%si)
    b71b:	8b 40 14             	mov    0x14(%bx,%si),%ax
    b71e:	85 c0                	test   %ax,%ax
    b720:	74 77                	je     b799 <frame_sort+0x9a>
            continue;
        }
        for (int j = i+1; j < FRAME_COUNT; ++j) {
    b722:	8b 45 fc             	mov    -0x4(%di),%ax
    b725:	83 c0 01             	add    $0x1,%ax
    b728:	89 45 f8             	mov    %ax,-0x8(%di)
    b72b:	eb 64                	jmp    b791 <frame_sort+0x92>
            if(frames[j]->used&&frames[j]->order<frames[i]->order){
    b72d:	8b 45 f8             	mov    -0x8(%di),%ax
    b730:	8b 04                	mov    (%si),%ax
    b732:	85 00                	test   %ax,(%bx,%si)
    b734:	ed                   	in     (%dx),%ax
    b735:	00 00                	add    %al,(%bx,%si)
    b737:	8b 40 14             	mov    0x14(%bx,%si),%ax
    b73a:	85 c0                	test   %ax,%ax
    b73c:	74 4f                	je     b78d <frame_sort+0x8e>
    b73e:	8b 45 f8             	mov    -0x8(%di),%ax
    b741:	8b 04                	mov    (%si),%ax
    b743:	85 00                	test   %ax,(%bx,%si)
    b745:	ed                   	in     (%dx),%ax
    b746:	00 00                	add    %al,(%bx,%si)
    b748:	0f b7 50 10          	movzww 0x10(%bx,%si),%dx
    b74c:	8b 45 fc             	mov    -0x4(%di),%ax
    b74f:	8b 04                	mov    (%si),%ax
    b751:	85 00                	test   %ax,(%bx,%si)
    b753:	ed                   	in     (%dx),%ax
    b754:	00 00                	add    %al,(%bx,%si)
    b756:	0f b7 40 10          	movzww 0x10(%bx,%si),%ax
    b75a:	66 39 c2             	cmp    %eax,%edx
    b75d:	73 2e                	jae    b78d <frame_sort+0x8e>
                frame_t *frame=frames[i];
    b75f:	8b 45 fc             	mov    -0x4(%di),%ax
    b762:	8b 04                	mov    (%si),%ax
    b764:	85 00                	test   %ax,(%bx,%si)
    b766:	ed                   	in     (%dx),%ax
    b767:	00 00                	add    %al,(%bx,%si)
    b769:	89 45 f4             	mov    %ax,-0xc(%di)
                frames[i]=frames[j];
    b76c:	8b 45 f8             	mov    -0x8(%di),%ax
    b76f:	8b 14                	mov    (%si),%dx
    b771:	85 00                	test   %ax,(%bx,%si)
    b773:	ed                   	in     (%dx),%ax
    b774:	00 00                	add    %al,(%bx,%si)
    b776:	8b 45 fc             	mov    -0x4(%di),%ax
    b779:	89 14                	mov    %dx,(%si)
    b77b:	85 00                	test   %ax,(%bx,%si)
    b77d:	ed                   	in     (%dx),%ax
    b77e:	00 00                	add    %al,(%bx,%si)
                frames[j]=frame;
    b780:	8b 45 f8             	mov    -0x8(%di),%ax
    b783:	8b 55 f4             	mov    -0xc(%di),%dx
    b786:	89 14                	mov    %dx,(%si)
    b788:	85 00                	test   %ax,(%bx,%si)
    b78a:	ed                   	in     (%dx),%ax
    b78b:	00 00                	add    %al,(%bx,%si)
        for (int j = i+1; j < FRAME_COUNT; ++j) {
    b78d:	83 45 f8 01          	addw   $0x1,-0x8(%di)
    b791:	83 7d f8 1f          	cmpw   $0x1f,-0x8(%di)
    b795:	7e 96                	jle    b72d <frame_sort+0x2e>
    b797:	eb 01                	jmp    b79a <frame_sort+0x9b>
            continue;
    b799:	90                   	nop
    for (int i = 0; i < FRAME_COUNT - 1; ++i) {
    b79a:	83 45 fc 01          	addw   $0x1,-0x4(%di)
    b79e:	83 7d fc 1e          	cmpw   $0x1e,-0x4(%di)
    b7a2:	0f 8e 69 ff          	jle    b70f <frame_sort+0x10>
    b7a6:	ff                   	(bad)
    b7a7:	ff 90 90 c9          	call   *-0x3670(%bx,%si)
            }
        }
    }
}
    b7ab:	c3                   	ret

0000b7ac <frame_move>:

// 用于部分移动的情况
void frame_move(frame_t *frame,int x,int y){
    b7ac:	55                   	push   %bp
    b7ad:	89 e5                	mov    %sp,%bp
    b7af:	83 ec 18             	sub    $0x18,%sp
    int oldX=frame->x;
    b7b2:	8b 45 08             	mov    0x8(%di),%ax
    b7b5:	8b 40 04             	mov    0x4(%bx,%si),%ax
    b7b8:	89 45 f4             	mov    %ax,-0xc(%di)
    int oldY=frame->y;
    b7bb:	8b 45 08             	mov    0x8(%di),%ax
    b7be:	8b 40 08             	mov    0x8(%bx,%si),%ax
    b7c1:	89 45 f0             	mov    %ax,-0x10(%di)
    frame->x=x;
    b7c4:	8b 45 08             	mov    0x8(%di),%ax
    b7c7:	8b 55 0c             	mov    0xc(%di),%dx
    b7ca:	89 50 04             	mov    %dx,0x4(%bx,%si)
    frame->y=y;
    b7cd:	8b 45 08             	mov    0x8(%di),%ax
    b7d0:	8b 55 10             	mov    0x10(%di),%dx
    b7d3:	89 50 08             	mov    %dx,0x8(%bx,%si)
    // 新老位置都需要刷新
    frame_refresh_sub(oldX,oldY,frame->w,frame->h);
    b7d6:	8b 45 08             	mov    0x8(%di),%ax
    b7d9:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    b7dd:	0f b7 d0             	movzww %ax,%dx
    b7e0:	8b 45 08             	mov    0x8(%di),%ax
    b7e3:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    b7e7:	0f b7 c0             	movzww %ax,%ax
    b7ea:	52                   	push   %dx
    b7eb:	50                   	push   %ax
    b7ec:	ff 75 f0             	push   -0x10(%di)
    b7ef:	ff 75 f4             	push   -0xc(%di)
    b7f2:	e8 0b 02             	call   ba00 <draw_frame_sub+0xbb>
    b7f5:	00 00                	add    %al,(%bx,%si)
    b7f7:	83 c4 10             	add    $0x10,%sp
    frame_refresh_sub(x,y,frame->w,frame->h);
    b7fa:	8b 45 08             	mov    0x8(%di),%ax
    b7fd:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    b801:	0f b7 d0             	movzww %ax,%dx
    b804:	8b 45 08             	mov    0x8(%di),%ax
    b807:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    b80b:	0f b7 c0             	movzww %ax,%ax
    b80e:	52                   	push   %dx
    b80f:	50                   	push   %ax
    b810:	ff 75 10             	push   0x10(%di)
    b813:	ff 75 0c             	push   0xc(%di)
    b816:	e8 e7 01             	call   ba00 <draw_frame_sub+0xbb>
    b819:	00 00                	add    %al,(%bx,%si)
    b81b:	83 c4 10             	add    $0x10,%sp
}
    b81e:	90                   	nop
    b81f:	c9                   	leave
    b820:	c3                   	ret

0000b821 <draw_frame>:

void draw_frame(frame_t *frame) {
    b821:	55                   	push   %bp
    b822:	89 e5                	mov    %sp,%bp
    b824:	57                   	push   %di
    b825:	56                   	push   %si
    b826:	53                   	push   %bx
    b827:	83 ec 0c             	sub    $0xc,%sp
    if(frame->flag&FRAME_ALPHA){
    b82a:	8b 45 08             	mov    0x8(%di),%ax
    b82d:	0f b6 40 12          	movzbw 0x12(%bx,%si),%ax
    b831:	0f b6 c0             	movzbw %al,%ax
    b834:	83 e0 08             	and    $0x8,%ax
    b837:	85 c0                	test   %ax,%ax
    b839:	74 44                	je     b87f <draw_frame+0x5e>
        draw_block_alpha(merge_vram, SCREEN_W,SCREEN_H, frame->x, frame->y, frame->w, frame->h, frame->vram);
    b83b:	8b 45 08             	mov    0x8(%di),%ax
    b83e:	8b 38                	mov    (%bx,%si),%di
    b840:	8b 45 08             	mov    0x8(%di),%ax
    b843:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    b847:	0f b7 f0             	movzww %ax,%si
    b84a:	8b 45 08             	mov    0x8(%di),%ax
    b84d:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    b851:	0f b7 d8             	movzww %ax,%bx
    b854:	8b 45 08             	mov    0x8(%di),%ax
    b857:	8b 48 08             	mov    0x8(%bx,%si),%cx
    b85a:	8b 45 08             	mov    0x8(%di),%ax
    b85d:	8b 50 04             	mov    0x4(%bx,%si),%dx
    b860:	a1 84 ed             	mov    0xed84,%ax
    b863:	00 00                	add    %al,(%bx,%si)
    b865:	57                   	push   %di
    b866:	56                   	push   %si
    b867:	53                   	push   %bx
    b868:	51                   	push   %cx
    b869:	52                   	push   %dx
    b86a:	68 c8 00             	push   $0xc8
    b86d:	00 00                	add    %al,(%bx,%si)
    b86f:	68 40 01             	push   $0x140
    b872:	00 00                	add    %al,(%bx,%si)
    b874:	50                   	push   %ax
    b875:	e8 d3 04             	call   bd4b <draw_block+0xeb>
    b878:	00 00                	add    %al,(%bx,%si)
    b87a:	83 c4 20             	add    $0x20,%sp
    } else{
        draw_block(merge_vram, SCREEN_W,SCREEN_H, frame->x, frame->y, frame->w, frame->h, frame->vram);
    }
}
    b87d:	eb 42                	jmp    b8c1 <draw_frame+0xa0>
        draw_block(merge_vram, SCREEN_W,SCREEN_H, frame->x, frame->y, frame->w, frame->h, frame->vram);
    b87f:	8b 45 08             	mov    0x8(%di),%ax
    b882:	8b 38                	mov    (%bx,%si),%di
    b884:	8b 45 08             	mov    0x8(%di),%ax
    b887:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    b88b:	0f b7 f0             	movzww %ax,%si
    b88e:	8b 45 08             	mov    0x8(%di),%ax
    b891:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    b895:	0f b7 d8             	movzww %ax,%bx
    b898:	8b 45 08             	mov    0x8(%di),%ax
    b89b:	8b 48 08             	mov    0x8(%bx,%si),%cx
    b89e:	8b 45 08             	mov    0x8(%di),%ax
    b8a1:	8b 50 04             	mov    0x4(%bx,%si),%dx
    b8a4:	a1 84 ed             	mov    0xed84,%ax
    b8a7:	00 00                	add    %al,(%bx,%si)
    b8a9:	57                   	push   %di
    b8aa:	56                   	push   %si
    b8ab:	53                   	push   %bx
    b8ac:	51                   	push   %cx
    b8ad:	52                   	push   %dx
    b8ae:	68 c8 00             	push   $0xc8
    b8b1:	00 00                	add    %al,(%bx,%si)
    b8b3:	68 40 01             	push   $0x140
    b8b6:	00 00                	add    %al,(%bx,%si)
    b8b8:	50                   	push   %ax
    b8b9:	e8 a2 03             	call   bc5e <min+0x13>
    b8bc:	00 00                	add    %al,(%bx,%si)
    b8be:	83 c4 20             	add    $0x20,%sp
}
    b8c1:	90                   	nop
    b8c2:	8d 65 f4             	lea    -0xc(%di),%sp
    b8c5:	5b                   	pop    %bx
    b8c6:	5e                   	pop    %si
    b8c7:	5f                   	pop    %di
    b8c8:	5d                   	pop    %bp
    b8c9:	c3                   	ret

0000b8ca <frame_refresh>:

// 整体刷新
void frame_refresh(){// 已经确保排序了
    b8ca:	55                   	push   %bp
    b8cb:	89 e5                	mov    %sp,%bp
    b8cd:	83 ec 18             	sub    $0x18,%sp
    // 先绘制非置顶图像，再绘制置顶图像
    for (int i = 0; i < FRAME_COUNT; ++i) {
    b8d0:	c7 45 f4 00 00       	movw   $0x0,-0xc(%di)
    b8d5:	00 00                	add    %al,(%bx,%si)
    b8d7:	eb 43                	jmp    b91c <frame_refresh+0x52>
        if(frames[i]->used&&!(frames[i]->flag&FRAME_HIDE)){
    b8d9:	8b 45 f4             	mov    -0xc(%di),%ax
    b8dc:	8b 04                	mov    (%si),%ax
    b8de:	85 00                	test   %ax,(%bx,%si)
    b8e0:	ed                   	in     (%dx),%ax
    b8e1:	00 00                	add    %al,(%bx,%si)
    b8e3:	8b 40 14             	mov    0x14(%bx,%si),%ax
    b8e6:	85 c0                	test   %ax,%ax
    b8e8:	74 2e                	je     b918 <frame_refresh+0x4e>
    b8ea:	8b 45 f4             	mov    -0xc(%di),%ax
    b8ed:	8b 04                	mov    (%si),%ax
    b8ef:	85 00                	test   %ax,(%bx,%si)
    b8f1:	ed                   	in     (%dx),%ax
    b8f2:	00 00                	add    %al,(%bx,%si)
    b8f4:	0f b6 40 12          	movzbw 0x12(%bx,%si),%ax
    b8f8:	0f b6 c0             	movzbw %al,%ax
    b8fb:	83 e0 01             	and    $0x1,%ax
    b8fe:	85 c0                	test   %ax,%ax
    b900:	75 16                	jne    b918 <frame_refresh+0x4e>
            draw_frame(frames[i]);
    b902:	8b 45 f4             	mov    -0xc(%di),%ax
    b905:	8b 04                	mov    (%si),%ax
    b907:	85 00                	test   %ax,(%bx,%si)
    b909:	ed                   	in     (%dx),%ax
    b90a:	00 00                	add    %al,(%bx,%si)
    b90c:	83 ec 0c             	sub    $0xc,%sp
    b90f:	50                   	push   %ax
    b910:	e8 0c ff             	call   b81f <frame_move+0x73>
    b913:	ff                   	(bad)
    b914:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    for (int i = 0; i < FRAME_COUNT; ++i) {
    b918:	83 45 f4 01          	addw   $0x1,-0xc(%di)
    b91c:	83 7d f4 1f          	cmpw   $0x1f,-0xc(%di)
    b920:	7e b7                	jle    b8d9 <frame_refresh+0xf>
        }
    }
    uint8_t *vram=(uint8_t *)VRAM_ADDR;
    b922:	c7 45 f0 00 00       	movw   $0x0,-0x10(%di)
    b927:	0a 00                	or     (%bx,%si),%al
    mem_copy(vram, merge_vram, VRAM_SIZE);
    b929:	a1 84 ed             	mov    0xed84,%ax
    b92c:	00 00                	add    %al,(%bx,%si)
    b92e:	83 ec 04             	sub    $0x4,%sp
    b931:	68 00 fa             	push   $0xfa00
    b934:	00 00                	add    %al,(%bx,%si)
    b936:	50                   	push   %ax
    b937:	ff 75 f0             	push   -0x10(%di)
    b93a:	e8 25 1f             	call   d862 <mem_eq+0x60>
    b93d:	00 00                	add    %al,(%bx,%si)
    b93f:	83 c4 10             	add    $0x10,%sp
}
    b942:	90                   	nop
    b943:	c9                   	leave
    b944:	c3                   	ret

0000b945 <draw_frame_sub>:

void draw_frame_sub(int minX, int minY, int maxX, int maxY, frame_t *frame) {
    b945:	55                   	push   %bp
    b946:	89 e5                	mov    %sp,%bp
    b948:	57                   	push   %di
    b949:	56                   	push   %si
    b94a:	53                   	push   %bx
    b94b:	83 ec 0c             	sub    $0xc,%sp
    if(frame->flag&FRAME_ALPHA){
    b94e:	8b 45 18             	mov    0x18(%di),%ax
    b951:	0f b6 40 12          	movzbw 0x12(%bx,%si),%ax
    b955:	0f b6 c0             	movzbw %al,%ax
    b958:	83 e0 08             	and    $0x8,%ax
    b95b:	85 c0                	test   %ax,%ax
    b95d:	74 4e                	je     b9ad <draw_frame_sub+0x68>
        draw_block_sub_alpha(merge_vram, SCREEN_W, minX, minY, maxX, maxY, frame->x, frame->y,
                             frame->w, frame->h, frame->vram);
    b95f:	8b 45 18             	mov    0x18(%di),%ax
    b962:	8b 38                	mov    (%bx,%si),%di
    b964:	8b 45 18             	mov    0x18(%di),%ax
    b967:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
        draw_block_sub_alpha(merge_vram, SCREEN_W, minX, minY, maxX, maxY, frame->x, frame->y,
    b96b:	0f b7 f0             	movzww %ax,%si
                             frame->w, frame->h, frame->vram);
    b96e:	8b 45 18             	mov    0x18(%di),%ax
    b971:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
        draw_block_sub_alpha(merge_vram, SCREEN_W, minX, minY, maxX, maxY, frame->x, frame->y,
    b975:	0f b7 d8             	movzww %ax,%bx
    b978:	8b 45 18             	mov    0x18(%di),%ax
    b97b:	8b 48 08             	mov    0x8(%bx,%si),%cx
    b97e:	8b 45 18             	mov    0x18(%di),%ax
    b981:	8b 50 04             	mov    0x4(%bx,%si),%dx
    b984:	a1 84 ed             	mov    0xed84,%ax
    b987:	00 00                	add    %al,(%bx,%si)
    b989:	83 ec 04             	sub    $0x4,%sp
    b98c:	57                   	push   %di
    b98d:	56                   	push   %si
    b98e:	53                   	push   %bx
    b98f:	51                   	push   %cx
    b990:	52                   	push   %dx
    b991:	ff 75 14             	push   0x14(%di)
    b994:	ff 75 10             	push   0x10(%di)
    b997:	ff 75 0c             	push   0xc(%di)
    b99a:	ff 75 08             	push   0x8(%di)
    b99d:	68 40 01             	push   $0x140
    b9a0:	00 00                	add    %al,(%bx,%si)
    b9a2:	50                   	push   %ax
    b9a3:	e8 86 05             	call   bf2c <draw_block_sub+0xe2>
    b9a6:	00 00                	add    %al,(%bx,%si)
    b9a8:	83 c4 30             	add    $0x30,%sp
    } else{
        draw_block_sub(merge_vram, SCREEN_W, minX, minY, maxX, maxY, frame->x, frame->y,
                       frame->w, frame->h, frame->vram);
    }
}
    b9ab:	eb 4c                	jmp    b9f9 <draw_frame_sub+0xb4>
        draw_block_sub(merge_vram, SCREEN_W, minX, minY, maxX, maxY, frame->x, frame->y,
    b9ad:	8b 45 18             	mov    0x18(%di),%ax
    b9b0:	8b 38                	mov    (%bx,%si),%di
                       frame->w, frame->h, frame->vram);
    b9b2:	8b 45 18             	mov    0x18(%di),%ax
    b9b5:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
        draw_block_sub(merge_vram, SCREEN_W, minX, minY, maxX, maxY, frame->x, frame->y,
    b9b9:	0f b7 f0             	movzww %ax,%si
                       frame->w, frame->h, frame->vram);
    b9bc:	8b 45 18             	mov    0x18(%di),%ax
    b9bf:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
        draw_block_sub(merge_vram, SCREEN_W, minX, minY, maxX, maxY, frame->x, frame->y,
    b9c3:	0f b7 d8             	movzww %ax,%bx
    b9c6:	8b 45 18             	mov    0x18(%di),%ax
    b9c9:	8b 48 08             	mov    0x8(%bx,%si),%cx
    b9cc:	8b 45 18             	mov    0x18(%di),%ax
    b9cf:	8b 50 04             	mov    0x4(%bx,%si),%dx
    b9d2:	a1 84 ed             	mov    0xed84,%ax
    b9d5:	00 00                	add    %al,(%bx,%si)
    b9d7:	83 ec 04             	sub    $0x4,%sp
    b9da:	57                   	push   %di
    b9db:	56                   	push   %si
    b9dc:	53                   	push   %bx
    b9dd:	51                   	push   %cx
    b9de:	52                   	push   %dx
    b9df:	ff 75 14             	push   0x14(%di)
    b9e2:	ff 75 10             	push   0x10(%di)
    b9e5:	ff 75 0c             	push   0xc(%di)
    b9e8:	ff 75 08             	push   0x8(%di)
    b9eb:	68 40 01             	push   $0x140
    b9ee:	00 00                	add    %al,(%bx,%si)
    b9f0:	50                   	push   %ax
    b9f1:	e8 54 04             	call   be48 <draw_block_alpha+0xfb>
    b9f4:	00 00                	add    %al,(%bx,%si)
    b9f6:	83 c4 30             	add    $0x30,%sp
}
    b9f9:	90                   	nop
    b9fa:	8d 65 f4             	lea    -0xc(%di),%sp
    b9fd:	5b                   	pop    %bx
    b9fe:	5e                   	pop    %si
    b9ff:	5f                   	pop    %di
    ba00:	5d                   	pop    %bp
    ba01:	c3                   	ret

0000ba02 <frame_refresh_sub>:

// 只刷新部分没有移动
void frame_refresh_sub(int x,int y,uint16_t w,uint16_t h){// 已经确保排序了
    ba02:	55                   	push   %bp
    ba03:	89 e5                	mov    %sp,%bp
    ba05:	53                   	push   %bx
    ba06:	83 ec 34             	sub    $0x34,%sp
    ba09:	8b 55 10             	mov    0x10(%di),%dx
    ba0c:	8b 45 14             	mov    0x14(%di),%ax
    ba0f:	66 89 55 d4          	mov    %edx,-0x2c(%di)
    ba13:	66 89 45 d0          	mov    %eax,-0x30(%di)
    // 进一步缩小边界
    int minX= max(x,0);
    ba17:	6a 00                	push   $0x0
    ba19:	ff 75 08             	push   0x8(%di)
    ba1c:	e8 87 f1             	call   aba6 <file_delete+0x94>
    ba1f:	ff                   	(bad)
    ba20:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    ba24:	89 45 ec             	mov    %ax,-0x14(%di)
    int minY= max(y,0);
    ba27:	6a 00                	push   $0x0
    ba29:	ff 75 0c             	push   0xc(%di)
    ba2c:	e8 77 f1             	call   aba6 <file_delete+0x94>
    ba2f:	ff                   	(bad)
    ba30:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    ba34:	89 45 e8             	mov    %ax,-0x18(%di)
    int maxX= min(x+w,SCREEN_W);
    ba37:	0f b7 55 d4          	movzww -0x2c(%di),%dx
    ba3b:	8b 45 08             	mov    0x8(%di),%ax
    ba3e:	01 d0                	add    %dx,%ax
    ba40:	68 40 01             	push   $0x140
    ba43:	00 00                	add    %al,(%bx,%si)
    ba45:	50                   	push   %ax
    ba46:	e8 72 f1             	call   abbb <max+0x13>
    ba49:	ff                   	(bad)
    ba4a:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    ba4e:	89 45 e4             	mov    %ax,-0x1c(%di)
    int maxY= min(y+h,SCREEN_H);
    ba51:	0f b7 55 d0          	movzww -0x30(%di),%dx
    ba55:	8b 45 0c             	mov    0xc(%di),%ax
    ba58:	01 d0                	add    %dx,%ax
    ba5a:	68 c8 00             	push   $0xc8
    ba5d:	00 00                	add    %al,(%bx,%si)
    ba5f:	50                   	push   %ax
    ba60:	e8 58 f1             	call   abbb <max+0x13>
    ba63:	ff                   	(bad)
    ba64:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    ba68:	89 45 e0             	mov    %ax,-0x20(%di)
    if(minX>=maxX||minY>=maxY){
    ba6b:	8b 45 ec             	mov    -0x14(%di),%ax
    ba6e:	3b 45 e4             	cmp    -0x1c(%di),%ax
    ba71:	0f 8d d2 00          	jge    bb47 <frame_refresh_sub+0x145>
    ba75:	00 00                	add    %al,(%bx,%si)
    ba77:	8b 45 e8             	mov    -0x18(%di),%ax
    ba7a:	3b 45 e0             	cmp    -0x20(%di),%ax
    ba7d:	0f 8d c6 00          	jge    bb47 <frame_refresh_sub+0x145>
    ba81:	00 00                	add    %al,(%bx,%si)
        return;
    }
    // 先绘制非置顶图像，再绘制置顶图像 只更新大于对应图层的信息
    for (int i = 0; i < FRAME_COUNT; ++i) {
    ba83:	c7 45 f4 00 00       	movw   $0x0,-0xc(%di)
    ba88:	00 00                	add    %al,(%bx,%si)
    ba8a:	eb 4f                	jmp    badb <frame_refresh_sub+0xd9>
        if(frames[i]->used&&!(frames[i]->flag&FRAME_HIDE)){
    ba8c:	8b 45 f4             	mov    -0xc(%di),%ax
    ba8f:	8b 04                	mov    (%si),%ax
    ba91:	85 00                	test   %ax,(%bx,%si)
    ba93:	ed                   	in     (%dx),%ax
    ba94:	00 00                	add    %al,(%bx,%si)
    ba96:	8b 40 14             	mov    0x14(%bx,%si),%ax
    ba99:	85 c0                	test   %ax,%ax
    ba9b:	74 3a                	je     bad7 <frame_refresh_sub+0xd5>
    ba9d:	8b 45 f4             	mov    -0xc(%di),%ax
    baa0:	8b 04                	mov    (%si),%ax
    baa2:	85 00                	test   %ax,(%bx,%si)
    baa4:	ed                   	in     (%dx),%ax
    baa5:	00 00                	add    %al,(%bx,%si)
    baa7:	0f b6 40 12          	movzbw 0x12(%bx,%si),%ax
    baab:	0f b6 c0             	movzbw %al,%ax
    baae:	83 e0 01             	and    $0x1,%ax
    bab1:	85 c0                	test   %ax,%ax
    bab3:	75 22                	jne    bad7 <frame_refresh_sub+0xd5>
            draw_frame_sub(minX,minY,maxX,maxY,frames[i]);
    bab5:	8b 45 f4             	mov    -0xc(%di),%ax
    bab8:	8b 04                	mov    (%si),%ax
    baba:	85 00                	test   %ax,(%bx,%si)
    babc:	ed                   	in     (%dx),%ax
    babd:	00 00                	add    %al,(%bx,%si)
    babf:	83 ec 0c             	sub    $0xc,%sp
    bac2:	50                   	push   %ax
    bac3:	ff 75 e0             	push   -0x20(%di)
    bac6:	ff 75 e4             	push   -0x1c(%di)
    bac9:	ff 75 e8             	push   -0x18(%di)
    bacc:	ff 75 ec             	push   -0x14(%di)
    bacf:	e8 71 fe             	call   b943 <frame_refresh+0x79>
    bad2:	ff                   	(bad)
    bad3:	ff 83 c4 20          	incw   0x20c4(%bp,%di)
    for (int i = 0; i < FRAME_COUNT; ++i) {
    bad7:	83 45 f4 01          	addw   $0x1,-0xc(%di)
    badb:	83 7d f4 1f          	cmpw   $0x1f,-0xc(%di)
    badf:	7e ab                	jle    ba8c <frame_refresh_sub+0x8a>
        }
    }
    uint8_t *vram=(uint8_t *)VRAM_ADDR;
    bae1:	c7 45 dc 00 00       	movw   $0x0,-0x24(%di)
    bae6:	0a 00                	or     (%bx,%si),%al
    for (int ty = minY; ty < maxY; ++ty) {
    bae8:	8b 45 e8             	mov    -0x18(%di),%ax
    baeb:	89 45 f0             	mov    %ax,-0x10(%di)
    baee:	eb 4f                	jmp    bb3f <frame_refresh_sub+0x13d>
        mem_copy(vram+ty*SCREEN_W+minX,merge_vram+ty*SCREEN_W+minX,maxX-minX);
    baf0:	8b 45 e4             	mov    -0x1c(%di),%ax
    baf3:	2b 45 ec             	sub    -0x14(%di),%ax
    baf6:	89 c3                	mov    %ax,%bx
    baf8:	8b 0d                	mov    (%di),%cx
    bafa:	84 ed                	test   %ch,%ch
    bafc:	00 00                	add    %al,(%bx,%si)
    bafe:	8b 55 f0             	mov    -0x10(%di),%dx
    bb01:	89 d0                	mov    %dx,%ax
    bb03:	c1 e0 02             	shl    $0x2,%ax
    bb06:	01 d0                	add    %dx,%ax
    bb08:	c1 e0 06             	shl    $0x6,%ax
    bb0b:	89 c2                	mov    %ax,%dx
    bb0d:	8b 45 ec             	mov    -0x14(%di),%ax
    bb10:	01 d0                	add    %dx,%ax
    bb12:	01 c1                	add    %ax,%cx
    bb14:	8b 55 f0             	mov    -0x10(%di),%dx
    bb17:	89 d0                	mov    %dx,%ax
    bb19:	c1 e0 02             	shl    $0x2,%ax
    bb1c:	01 d0                	add    %dx,%ax
    bb1e:	c1 e0 06             	shl    $0x6,%ax
    bb21:	89 c2                	mov    %ax,%dx
    bb23:	8b 45 ec             	mov    -0x14(%di),%ax
    bb26:	01 c2                	add    %ax,%dx
    bb28:	8b 45 dc             	mov    -0x24(%di),%ax
    bb2b:	01 d0                	add    %dx,%ax
    bb2d:	83 ec 04             	sub    $0x4,%sp
    bb30:	53                   	push   %bx
    bb31:	51                   	push   %cx
    bb32:	50                   	push   %ax
    bb33:	e8 2c 1d             	call   d862 <mem_eq+0x60>
    bb36:	00 00                	add    %al,(%bx,%si)
    bb38:	83 c4 10             	add    $0x10,%sp
    for (int ty = minY; ty < maxY; ++ty) {
    bb3b:	83 45 f0 01          	addw   $0x1,-0x10(%di)
    bb3f:	8b 45 f0             	mov    -0x10(%di),%ax
    bb42:	3b 45 e0             	cmp    -0x20(%di),%ax
    bb45:	7c a9                	jl     baf0 <frame_refresh_sub+0xee>
    bb47:	eb 01                	jmp    bb4a <frame_refresh_sub+0x148>
        return;
    bb49:	90                   	nop
    }
}
    bb4a:	8b 5d fc             	mov    -0x4(%di),%bx
    bb4d:	c9                   	leave
    bb4e:	c3                   	ret

0000bb4f <click_frame>:

frame_t *click_frame(int x,int y){
    bb4f:	55                   	push   %bp
    bb50:	89 e5                	mov    %sp,%bp
    bb52:	83 ec 10             	sub    $0x10,%sp
    // 越高越优先
    for (int i = FRAME_COUNT-1; i >=0 ; --i) {
    bb55:	c7 45 fc 1f 00       	movw   $0x1f,-0x4(%di)
    bb5a:	00 00                	add    %al,(%bx,%si)
    bb5c:	eb 75                	jmp    bbd3 <click_frame+0x84>
        frame_t *frame=frames[i];
    bb5e:	8b 45 fc             	mov    -0x4(%di),%ax
    bb61:	8b 04                	mov    (%si),%ax
    bb63:	85 00                	test   %ax,(%bx,%si)
    bb65:	ed                   	in     (%dx),%ax
    bb66:	00 00                	add    %al,(%bx,%si)
    bb68:	89 45 f8             	mov    %ax,-0x8(%di)
        if(frame->used&&(frame->flag&FRAME_CLICK)){
    bb6b:	8b 45 f8             	mov    -0x8(%di),%ax
    bb6e:	8b 40 14             	mov    0x14(%bx,%si),%ax
    bb71:	85 c0                	test   %ax,%ax
    bb73:	74 5a                	je     bbcf <click_frame+0x80>
    bb75:	8b 45 f8             	mov    -0x8(%di),%ax
    bb78:	0f b6 40 12          	movzbw 0x12(%bx,%si),%ax
    bb7c:	0f b6 c0             	movzbw %al,%ax
    bb7f:	83 e0 04             	and    $0x4,%ax
    bb82:	85 c0                	test   %ax,%ax
    bb84:	74 49                	je     bbcf <click_frame+0x80>
            if(x>=frame->x&&y>=frame->y&&x<=frame->x+frame->w&&y<=frame->y+frame->h){
    bb86:	8b 45 f8             	mov    -0x8(%di),%ax
    bb89:	8b 40 04             	mov    0x4(%bx,%si),%ax
    bb8c:	39 45 08             	cmp    %ax,0x8(%di)
    bb8f:	7c 3e                	jl     bbcf <click_frame+0x80>
    bb91:	8b 45 f8             	mov    -0x8(%di),%ax
    bb94:	8b 40 08             	mov    0x8(%bx,%si),%ax
    bb97:	39 45 0c             	cmp    %ax,0xc(%di)
    bb9a:	7c 33                	jl     bbcf <click_frame+0x80>
    bb9c:	8b 45 f8             	mov    -0x8(%di),%ax
    bb9f:	8b 50 04             	mov    0x4(%bx,%si),%dx
    bba2:	8b 45 f8             	mov    -0x8(%di),%ax
    bba5:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    bba9:	0f b7 c0             	movzww %ax,%ax
    bbac:	01 d0                	add    %dx,%ax
    bbae:	39 45 08             	cmp    %ax,0x8(%di)
    bbb1:	7f 1c                	jg     bbcf <click_frame+0x80>
    bbb3:	8b 45 f8             	mov    -0x8(%di),%ax
    bbb6:	8b 50 08             	mov    0x8(%bx,%si),%dx
    bbb9:	8b 45 f8             	mov    -0x8(%di),%ax
    bbbc:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    bbc0:	0f b7 c0             	movzww %ax,%ax
    bbc3:	01 d0                	add    %dx,%ax
    bbc5:	39 45 0c             	cmp    %ax,0xc(%di)
    bbc8:	7f 05                	jg     bbcf <click_frame+0x80>
                return frame;
    bbca:	8b 45 f8             	mov    -0x8(%di),%ax
    bbcd:	eb 0f                	jmp    bbde <click_frame+0x8f>
    for (int i = FRAME_COUNT-1; i >=0 ; --i) {
    bbcf:	83 6d fc 01          	subw   $0x1,-0x4(%di)
    bbd3:	83 7d fc 00          	cmpw   $0x0,-0x4(%di)
    bbd7:	79 85                	jns    bb5e <click_frame+0xf>
            }
        }
    }
    return 0;
    bbd9:	b8 00 00             	mov    $0x0,%ax
    bbdc:	00 00                	add    %al,(%bx,%si)
    bbde:	c9                   	leave
    bbdf:	c3                   	ret

0000bbe0 <outb>:
static inline void outb(uint16_t port, uint8_t data) {
    bbe0:	55                   	push   %bp
    bbe1:	89 e5                	mov    %sp,%bp
    bbe3:	83 ec 08             	sub    $0x8,%sp
    bbe6:	8b 55 08             	mov    0x8(%di),%dx
    bbe9:	8b 45 0c             	mov    0xc(%di),%ax
    bbec:	66 89 55 fc          	mov    %edx,-0x4(%di)
    bbf0:	88 45 f8             	mov    %al,-0x8(%di)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
    bbf3:	0f b7 55 fc          	movzww -0x4(%di),%dx
    bbf7:	0f b6 45 f8          	movzbw -0x8(%di),%ax
    bbfb:	ee                   	out    %al,(%dx)
}
    bbfc:	90                   	nop
    bbfd:	c9                   	leave
    bbfe:	c3                   	ret

0000bbff <cli>:
static inline void cli() {
    bbff:	55                   	push   %bp
    bc00:	89 e5                	mov    %sp,%bp
	__asm__ __volatile__("cli");
    bc02:	fa                   	cli
}
    bc03:	90                   	nop
    bc04:	5d                   	pop    %bp
    bc05:	c3                   	ret

0000bc06 <read_eflags>:

static inline void write_tr (uint32_t tss_selector) {
    __asm__ __volatile__("ltr %%ax"::"a"(tss_selector));
}

static inline uint32_t read_eflags () {
    bc06:	55                   	push   %bp
    bc07:	89 e5                	mov    %sp,%bp
    bc09:	83 ec 10             	sub    $0x10,%sp
    uint32_t eflags;

    __asm__ __volatile__("pushfl\n\tpopl %%eax":"=a"(eflags));
    bc0c:	9c                   	pushf
    bc0d:	58                   	pop    %ax
    bc0e:	89 45 fc             	mov    %ax,-0x4(%di)
    return eflags;
    bc11:	8b 45 fc             	mov    -0x4(%di),%ax
}
    bc14:	c9                   	leave
    bc15:	c3                   	ret

0000bc16 <write_eflags>:

static inline void write_eflags (uint32_t eflags) {
    bc16:	55                   	push   %bp
    bc17:	89 e5                	mov    %sp,%bp
    __asm__ __volatile__("pushl %%eax\n\tpopfl"::"a"(eflags));
    bc19:	8b 45 08             	mov    0x8(%di),%ax
    bc1c:	50                   	push   %ax
    bc1d:	9d                   	popf
}
    bc1e:	90                   	nop
    bc1f:	5d                   	pop    %bp
    bc20:	c3                   	ret

0000bc21 <abs>:
static inline int abs(int val) {
    bc21:	55                   	push   %bp
    bc22:	89 e5                	mov    %sp,%bp
    if(val<0){
    bc24:	83 7d 08 00          	cmpw   $0x0,0x8(%di)
    bc28:	79 07                	jns    bc31 <abs+0x10>
        return -val;
    bc2a:	8b 45 08             	mov    0x8(%di),%ax
    bc2d:	f7 d8                	neg    %ax
    bc2f:	eb 03                	jmp    bc34 <abs+0x13>
    return val;
    bc31:	8b 45 08             	mov    0x8(%di),%ax
}
    bc34:	5d                   	pop    %bp
    bc35:	c3                   	ret

0000bc36 <max>:
static inline int max(int val1,int val2) {
    bc36:	55                   	push   %bp
    bc37:	89 e5                	mov    %sp,%bp
    if(val1>val2){
    bc39:	8b 45 08             	mov    0x8(%di),%ax
    bc3c:	3b 45 0c             	cmp    0xc(%di),%ax
    bc3f:	7e 05                	jle    bc46 <max+0x10>
        return val1;
    bc41:	8b 45 08             	mov    0x8(%di),%ax
    bc44:	eb 03                	jmp    bc49 <max+0x13>
    return val2;
    bc46:	8b 45 0c             	mov    0xc(%di),%ax
}
    bc49:	5d                   	pop    %bp
    bc4a:	c3                   	ret

0000bc4b <min>:
static inline int min(int val1,int val2) {
    bc4b:	55                   	push   %bp
    bc4c:	89 e5                	mov    %sp,%bp
    if(val1<val2){
    bc4e:	8b 45 08             	mov    0x8(%di),%ax
    bc51:	3b 45 0c             	cmp    0xc(%di),%ax
    bc54:	7d 05                	jge    bc5b <min+0x10>
        return val1;
    bc56:	8b 45 08             	mov    0x8(%di),%ax
    bc59:	eb 03                	jmp    bc5e <min+0x13>
    return val2;
    bc5b:	8b 45 0c             	mov    0xc(%di),%ax
}
    bc5e:	5d                   	pop    %bp
    bc5f:	c3                   	ret

0000bc60 <draw_block>:
// 备用
//static uint8_t fonts[]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c,0x22,0x41,0x55,0x55,0x41,0x41,0x55,0x49,0x22,0x1c,0x0,0x0,0x0,0x0,0x0,0x1c,0x3e,0x7f,0x6b,0x6b,0x7f,0x7f,0x6b,0x77,0x3e,0x1c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x36,0x7f,0x7f,0x7f,0x3e,0x1c,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x1c,0x3e,0x7f,0x3e,0x1c,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x1c,0x2a,0x7f,0x2a,0x8,0x1c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x1c,0x3e,0x7f,0x6b,0x8,0x1c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x18,0x3c,0x3c,0x18,0x0,0x0,0x0,0x0,0x0,0x0,0xff,0xff,0xff,0xff,0xff,0xff,0xe7,0xc3,0xc3,0xe7,0xff,0xff,0xff,0xff,0xff,0xff,0x0,0x0,0x0,0x0,0x0,0x3c,0x66,0x42,0x42,0x66,0x3c,0x0,0x0,0x0,0x0,0x0,0xff,0xff,0xff,0xff,0xff,0xc3,0x99,0xbd,0xbd,0x99,0xc3,0xff,0xff,0xff,0xff,0xff,0x0,0x8,0x1c,0x2a,0x49,0x8,0x8,0x1c,0x22,0x41,0x41,0x41,0x22,0x1c,0x0,0x0,0x0,0x1c,0x22,0x41,0x41,0x41,0x22,0x1c,0x8,0x8,0x7f,0x8,0x8,0x8,0x0,0x0,0x0,0x0,0x30,0x70,0xd0,0xd0,0x50,0x10,0x10,0x18,0x1e,0x1f,0xe,0x0,0x0,0x0,0x0,0x0,0xf8,0xf8,0x88,0x88,0x88,0x88,0x88,0x88,0xee,0xff,0x66,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x2a,0x1c,0x14,0x1c,0x2a,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x3,0x7,0xf,0x1f,0x3f,0x7f,0x3f,0x1f,0xf,0x7,0x3,0x1,0x0,0x0,0x0,0x40,0x60,0x70,0x78,0x7c,0x7e,0x7f,0x7e,0x7c,0x78,0x70,0x60,0x40,0x0,0x0,0x0,0x0,0x8,0x1c,0x2a,0x49,0x8,0x8,0x8,0x49,0x2a,0x1c,0x8,0x0,0x0,0x0,0x0,0x0,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x0,0x0,0x22,0x22,0x0,0x0,0x0,0x7c,0x52,0x51,0x51,0x51,0x51,0x52,0x5c,0x50,0x50,0x50,0x50,0x50,0x0,0x0,0x3e,0x41,0x2,0x4,0x1c,0x22,0x41,0x41,0x41,0x22,0x1c,0x10,0x20,0x41,0x3e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f,0x7f,0x7f,0x0,0x0,0x0,0x0,0x8,0x1c,0x2a,0x49,0x8,0x8,0x8,0x49,0x2a,0x1c,0x8,0x3e,0x0,0x0,0x0,0x8,0x1c,0x2a,0x49,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x0,0x0,0x0,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x49,0x2a,0x1c,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x10,0x20,0x7f,0x20,0x10,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x4,0x2,0x7f,0x2,0x4,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x7f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x14,0x22,0x7f,0x22,0x14,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x8,0x1c,0x1c,0x3e,0x3e,0x7f,0x7f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f,0x7f,0x3e,0x3e,0x1c,0x1c,0x8,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x0,0x0,0x8,0x8,0x0,0x0,0x14,0x14,0x14,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x22,0x22,0x22,0x7f,0x22,0x22,0x22,0x22,0x22,0x7f,0x22,0x22,0x22,0x0,0x0,0x8,0x5c,0x6a,0x49,0x49,0x9,0xa,0x1c,0x28,0x48,0x49,0x49,0x2b,0x1d,0x8,0x8,0x46,0x49,0x29,0x29,0x16,0x10,0x8,0x8,0x4,0x34,0x4a,0x4a,0x49,0x31,0x0,0x0,0x0,0xe,0x11,0x11,0x11,0x9,0x6,0xe2,0x45,0x49,0x51,0x21,0x62,0x9c,0x0,0x0,0x20,0x10,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x20,0x10,0x10,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x10,0x10,0x20,0x40,0x0,0x1,0x2,0x4,0x4,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x4,0x4,0x2,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x49,0x2a,0x1c,0x2a,0x49,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x8,0x8,0x7f,0x8,0x8,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x18,0x18,0x10,0x10,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x18,0x18,0x0,0x0,0x40,0x40,0x20,0x20,0x10,0x10,0x10,0x8,0x8,0x4,0x4,0x2,0x2,0x2,0x1,0x1,0x0,0x18,0x24,0x24,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x24,0x24,0x18,0x0,0x0,0x0,0x10,0x18,0x14,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x7c,0x0,0x0,0x0,0x18,0x24,0x42,0x42,0x40,0x20,0x10,0x8,0x4,0x4,0x2,0x2,0x7e,0x0,0x0,0x0,0x18,0x24,0x42,0x40,0x40,0x20,0x18,0x20,0x40,0x40,0x42,0x24,0x18,0x0,0x0,0x0,0x30,0x30,0x30,0x28,0x28,0x28,0x24,0x24,0x22,0x7e,0x20,0x20,0x78,0x0,0x0,0x0,0x3e,0x2,0x2,0x2,0x1a,0x26,0x40,0x40,0x40,0x40,0x42,0x24,0x18,0x0,0x0,0x0,0x18,0x24,0x42,0x2,0x1a,0x26,0x42,0x42,0x42,0x42,0x42,0x24,0x18,0x0,0x0,0x0,0x7e,0x42,0x42,0x20,0x20,0x10,0x10,0x10,0x8,0x8,0x8,0x8,0x1c,0x0,0x0,0x0,0x18,0x24,0x42,0x42,0x42,0x24,0x18,0x24,0x42,0x42,0x42,0x24,0x18,0x0,0x0,0x0,0x18,0x24,0x42,0x42,0x42,0x42,0x42,0x64,0x58,0x40,0x42,0x24,0x18,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x18,0x18,0x0,0x0,0x0,0x0,0x0,0x18,0x18,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x18,0x18,0x0,0x0,0x0,0x0,0x18,0x18,0x10,0x10,0x8,0x0,0x40,0x20,0x10,0x8,0x4,0x2,0x1,0x1,0x2,0x4,0x8,0x10,0x20,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f,0x0,0x0,0x7f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x2,0x4,0x8,0x10,0x20,0x40,0x40,0x20,0x10,0x8,0x4,0x2,0x1,0x0,0x0,0x1c,0x22,0x41,0x41,0x41,0x20,0x10,0x8,0x8,0x0,0x0,0x18,0x18,0x0,0x0,0x0,0x1c,0x22,0x41,0x59,0x55,0x55,0x55,0x55,0x55,0x39,0x1,0x62,0x1c,0x0,0x0,0x0,0x18,0x18,0x18,0x18,0x24,0x24,0x24,0x24,0x7e,0x42,0x42,0x42,0xe7,0x0,0x0,0x0,0xf,0x12,0x22,0x22,0x22,0x12,0x1e,0x22,0x42,0x42,0x42,0x22,0x1f,0x0,0x0,0x0,0x5c,0x62,0x42,0x41,0x1,0x1,0x1,0x1,0x1,0x41,0x42,0x22,0x1c,0x0,0x0,0x0,0x1f,0x22,0x22,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x22,0x22,0x1f,0x0,0x0,0x0,0x7f,0x42,0x42,0x2,0x2,0x22,0x3e,0x22,0x2,0x2,0x42,0x42,0x7f,0x0,0x0,0x0,0x7f,0x42,0x42,0x2,0x2,0x22,0x3e,0x22,0x22,0x2,0x2,0x2,0xf,0x0,0x0,0x0,0x5c,0x62,0x42,0x41,0x1,0x1,0x79,0x41,0x41,0x41,0x42,0x62,0x1c,0x0,0x0,0x0,0xe7,0x42,0x42,0x42,0x42,0x42,0x7e,0x42,0x42,0x42,0x42,0x42,0xe7,0x0,0x0,0x0,0x3e,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x3e,0x0,0x0,0x0,0xf8,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x21,0x12,0xc,0x0,0x0,0xe7,0x42,0x22,0x12,0xa,0xa,0x6,0xa,0xa,0x12,0x22,0x42,0xe7,0x0,0x0,0x0,0xf,0x2,0x2,0x2,0x2,0x2,0x2,0x2,0x2,0x2,0x42,0x42,0x7f,0x0,0x0,0x0,0xc3,0x42,0x66,0x66,0x66,0x5a,0x5a,0x5a,0x42,0x42,0x42,0x42,0xe7,0x0,0x0,0x0,0xe3,0x42,0x46,0x46,0x4a,0x4a,0x4a,0x52,0x52,0x52,0x62,0x62,0x47,0x0,0x0,0x0,0x1c,0x22,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x22,0x1c,0x0,0x0,0x0,0x1f,0x22,0x42,0x42,0x42,0x22,0x1e,0x2,0x2,0x2,0x2,0x2,0xf,0x0,0x0,0x0,0x1c,0x22,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x49,0x51,0x22,0x5c,0x0,0x0,0x0,0x3f,0x42,0x42,0x42,0x42,0x3e,0x22,0x42,0x42,0x42,0x42,0x42,0xe7,0x0,0x0,0x0,0x5c,0x62,0x41,0x41,0x1,0x2,0x1c,0x20,0x40,0x41,0x41,0x23,0x1d,0x0,0x0,0x0,0x7f,0x49,0x49,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x3e,0x0,0x0,0x0,0xe7,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x24,0x3c,0x0,0x0,0x0,0xe7,0x42,0x42,0x42,0x42,0x24,0x24,0x24,0x24,0x18,0x18,0x18,0x18,0x0,0x0,0x0,0xe7,0x42,0x42,0x42,0x5a,0x5a,0x5a,0x5a,0x24,0x24,0x24,0x24,0x24,0x0,0x0,0x0,0xe7,0x42,0x42,0x24,0x24,0x24,0x18,0x24,0x24,0x24,0x42,0x42,0xe7,0x0,0x0,0x0,0x77,0x22,0x22,0x22,0x14,0x14,0x14,0x8,0x8,0x8,0x8,0x8,0x3e,0x0,0x0,0x0,0x7f,0x21,0x21,0x10,0x10,0x8,0x8,0x4,0x4,0x2,0x42,0x41,0x7f,0x0,0x0,0x0,0x7c,0x4,0x4,0x4,0x4,0x4,0x4,0x4,0x4,0x4,0x4,0x4,0x4,0x7c,0x0,0x1,0x1,0x2,0x2,0x4,0x4,0x4,0x8,0x8,0x10,0x10,0x20,0x20,0x20,0x40,0x40,0x0,0x3e,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3e,0x0,0x0,0x8,0x14,0x22,0x41,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f,0x0,0x8,0x10,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe,0x10,0x20,0x3c,0x22,0x21,0x21,0x31,0x6e,0x0,0x0,0x3,0x2,0x2,0x2,0x2,0x1a,0x26,0x42,0x42,0x42,0x42,0x42,0x26,0x1a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x32,0x21,0x21,0x1,0x1,0x41,0x22,0x1c,0x0,0x0,0x30,0x20,0x20,0x20,0x20,0x2c,0x32,0x21,0x21,0x21,0x21,0x21,0x32,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c,0x22,0x41,0x41,0x3f,0x1,0x41,0x42,0x3c,0x0,0x0,0x70,0x8,0x8,0x8,0x8,0x3e,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x3e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6c,0x32,0x21,0x21,0x21,0x21,0x32,0x2c,0x20,0x20,0x1e,0x3,0x2,0x2,0x2,0x2,0x1a,0x26,0x42,0x42,0x42,0x42,0x42,0x42,0xc7,0x0,0x0,0x0,0x8,0x8,0x0,0x0,0xc,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x1c,0x0,0x0,0x0,0x20,0x20,0x0,0x0,0x30,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x10,0x10,0xc,0x3,0x2,0x2,0x2,0x2,0x72,0x22,0x12,0xa,0x6,0xa,0x12,0x22,0x67,0x0,0x0,0xc,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x1c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6f,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0xdb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1b,0x26,0x42,0x42,0x42,0x42,0x42,0x42,0xc7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c,0x22,0x41,0x41,0x41,0x41,0x41,0x22,0x1c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1b,0x26,0x42,0x42,0x42,0x42,0x42,0x26,0x1a,0x2,0x7,0x0,0x0,0x0,0x0,0x0,0x2c,0x32,0x21,0x21,0x21,0x21,0x21,0x32,0x2c,0x20,0x70,0x0,0x0,0x0,0x0,0x0,0x3b,0x46,0x42,0x2,0x2,0x2,0x2,0x2,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5e,0x61,0x41,0x3,0x1c,0x60,0x41,0x43,0x3d,0x0,0x0,0x0,0x0,0x8,0x8,0x8,0x3e,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x70,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x63,0x42,0x42,0x42,0x42,0x42,0x42,0x62,0xdc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe7,0x42,0x42,0x42,0x24,0x24,0x24,0x18,0x18,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe7,0x42,0x42,0x5a,0x5a,0x5a,0x24,0x24,0x24,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x63,0x22,0x14,0x14,0x8,0x14,0x14,0x22,0x63,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe7,0x42,0x42,0x24,0x24,0x24,0x18,0x18,0x8,0x8,0x6,0x0,0x0,0x0,0x0,0x0,0x7f,0x41,0x21,0x10,0x8,0x4,0x42,0x41,0x7f,0x0,0x0,0x0,0x60,0x10,0x8,0x8,0x8,0x8,0x6,0x8,0x8,0x8,0x8,0x10,0x60,0x0,0x0,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x0,0x6,0x8,0x10,0x10,0x10,0x10,0x60,0x10,0x10,0x10,0x10,0x8,0x6,0x0,0x0,0x0,0x4e,0x31,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x14,0x22,0x41,0x7f,0x41,0x7f,0x0,0x0,0x0,0x0,0x0,0x0,0x1c,0x22,0x41,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x41,0x22,0x1c,0x8,0x4,0x0,0x0,0x24,0x24,0x0,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x42,0x7c,0x0,0x0,0x30,0x10,0x8,0x0,0x0,0x1c,0x22,0x41,0x41,0x7f,0x1,0x41,0x22,0x1c,0x0,0x0,0x0,0x8,0x14,0x22,0x0,0x1e,0x20,0x20,0x3c,0x22,0x21,0x21,0x22,0x7c,0x0,0x0,0x0,0x0,0x24,0x24,0x0,0x1e,0x20,0x20,0x3c,0x22,0x21,0x21,0x22,0x7c,0x0,0x0,0x8,0x10,0x20,0x0,0x0,0x1e,0x20,0x20,0x3c,0x22,0x21,0x21,0x22,0x7c,0x0,0x0,0x0,0x18,0x24,0x18,0x0,0x1e,0x20,0x20,0x3c,0x22,0x21,0x21,0x22,0x7c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c,0x42,0x1,0x1,0x1,0x1,0x1,0x42,0x3c,0x10,0x8,0x0,0x8,0x14,0x22,0x0,0x1c,0x22,0x41,0x41,0x7f,0x1,0x41,0x22,0x1c,0x0,0x0,0x0,0x0,0x24,0x24,0x0,0x1c,0x22,0x41,0x41,0x7f,0x1,0x41,0x22,0x1c,0x0,0x0,0x8,0x10,0x20,0x0,0x0,0x1c,0x22,0x41,0x41,0x7f,0x1,0x41,0x22,0x1c,0x0,0x0,0x0,0x0,0x24,0x24,0x0,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x0,0x0,0x0,0x8,0x14,0x22,0x0,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x0,0x0,0x8,0x10,0x20,0x0,0x0,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x0,0x0,0x24,0x24,0x0,0x1c,0x22,0x41,0x41,0x41,0x41,0x7f,0x41,0x41,0x41,0x41,0x0,0x0,0x0,0x1c,0x22,0x1c,0x22,0x41,0x41,0x41,0x41,0x7f,0x41,0x41,0x41,0x41,0x0,0x0,0x30,0x10,0x8,0x7f,0x1,0x1,0x1,0x1,0x1f,0x1,0x1,0x1,0x1,0x7f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6,0x38,0x48,0x4e,0x79,0x9,0x9,0x49,0x36,0x0,0x0,0x30,0x8,0x4,0x14,0x14,0x14,0x7f,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x0,0x0,0x0,0x8,0x14,0x22,0x0,0x1c,0x22,0x41,0x41,0x41,0x41,0x41,0x22,0x1c,0x0,0x0,0x0,0x0,0x24,0x24,0x0,0x1c,0x22,0x41,0x41,0x41,0x41,0x41,0x22,0x1c,0x0,0x0,0x8,0x10,0x20,0x0,0x0,0x1c,0x22,0x41,0x41,0x41,0x41,0x41,0x22,0x1c,0x0,0x0,0x0,0x8,0x14,0x22,0x0,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x42,0x7c,0x0,0x0,0x8,0x10,0x20,0x0,0x0,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x42,0x7c,0x0,0x0,0x0,0x0,0x24,0x24,0x0,0x41,0x41,0x22,0x22,0x14,0x14,0x8,0x8,0x4,0x4,0x2,0x24,0x24,0x0,0x1c,0x22,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x22,0x1c,0x0,0x0,0x24,0x24,0x0,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x22,0x1c,0x0,0x0,0x0,0x14,0x14,0x14,0x3c,0x56,0x15,0x15,0x15,0x15,0x15,0x56,0x3c,0x14,0x14,0x14,0x0,0x30,0x48,0x4,0x4,0x4,0x3f,0x4,0x4,0x4,0x6,0x5,0x4d,0x32,0x0,0x0,0x0,0x41,0x41,0x22,0x14,0x8,0x7f,0x8,0x8,0x7f,0x8,0x8,0x8,0x8,0x0,0x0,0x0,0x7,0x9,0x11,0x11,0x11,0x29,0x27,0xf9,0x21,0x21,0x21,0x21,0x21,0x0,0x0,0x0,0x30,0x48,0x8,0x8,0x8,0x7f,0x8,0x8,0x8,0x8,0x8,0x9,0x6,0x0,0x0,0x30,0x10,0x8,0x0,0x0,0x1e,0x20,0x20,0x3c,0x22,0x21,0x21,0x22,0x7c,0x0,0x0,0x30,0x10,0x8,0x0,0x0,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x0,0x0,0x30,0x10,0x8,0x0,0x0,0x1c,0x22,0x41,0x41,0x41,0x41,0x41,0x22,0x1c,0x0,0x0,0x30,0x10,0x8,0x0,0x0,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x42,0x7c,0x0,0x0,0x0,0x48,0x54,0x24,0x0,0x1f,0x21,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x0,0x0,0x48,0x54,0x24,0x0,0x41,0x43,0x43,0x45,0x49,0x49,0x51,0x61,0x61,0x41,0x0,0x0,0x0,0x0,0x0,0x1e,0x20,0x20,0x3c,0x22,0x21,0x21,0x22,0x7c,0x0,0x7f,0x0,0x0,0x0,0x0,0x0,0x1c,0x22,0x41,0x41,0x41,0x41,0x41,0x22,0x1c,0x0,0x7f,0x0,0x0,0x0,0x8,0x8,0x0,0x0,0x8,0x8,0x4,0x22,0x41,0x41,0x41,0x22,0x1c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f,0x1,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f,0x40,0x40,0x40,0x0,0x0,0x0,0x8,0xc,0x8,0x8,0x8,0x0,0x7f,0x0,0x1e,0x20,0x1c,0x2,0x3e,0x0,0x0,0x0,0x8,0xc,0x8,0x8,0x8,0x0,0x7f,0x0,0x18,0x14,0x12,0x3e,0x10,0x0,0x0,0x0,0x8,0x8,0x0,0x0,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x48,0x24,0x12,0x9,0x9,0x12,0x24,0x48,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9,0x12,0x24,0x48,0x48,0x24,0x12,0x9,0x0,0x0,0x0,0x0,0x88,0x22,0x88,0x22,0x88,0x22,0x88,0x22,0x88,0x22,0x88,0x22,0x88,0x22,0x88,0x22,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xee,0xbb,0xee,0xbb,0xee,0xbb,0xee,0xbb,0xee,0xbb,0xee,0xbb,0xee,0xbb,0xee,0xbb,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0xf,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0xf,0x8,0xf,0x8,0x8,0x8,0x8,0x8,0x8,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x2f,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf,0x8,0xf,0x8,0x8,0x8,0x8,0x8,0x8,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x2f,0x20,0x2f,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f,0x20,0x2f,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x2f,0x20,0x3f,0x0,0x0,0x0,0x0,0x0,0x0,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x3f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0xf,0x8,0xf,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0xf8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0xf8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0xff,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0xf8,0x8,0xf8,0x8,0x8,0x8,0x8,0x8,0x8,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0xe8,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0xe8,0x8,0xf8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf8,0x8,0xe8,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0xef,0x0,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff,0x0,0xef,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0xe8,0x8,0xe8,0x28,0x28,0x28,0x28,0x28,0x28,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff,0x0,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0xef,0x0,0xef,0x28,0x28,0x28,0x28,0x28,0x28,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0xff,0x0,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff,0x0,0xff,0x8,0x8,0x8,0x8,0x8,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0xf8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0xf8,0x8,0xf8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf8,0x8,0xf8,0x8,0x8,0x8,0x8,0x8,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf8,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0xef,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0xff,0x8,0xff,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0xf,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
static uint8_t *fonts;

// 没有透明通道
void draw_block(uint8_t *vram, uint16_t vram_w,uint16_t vram_h, int x, int y, uint16_t w, uint16_t h, uint8_t *block){
    bc60:	55                   	push   %bp
    bc61:	89 e5                	mov    %sp,%bp
    bc63:	53                   	push   %bx
    bc64:	83 ec 34             	sub    $0x34,%sp
    bc67:	8b 5d 0c             	mov    0xc(%di),%bx
    bc6a:	8b 4d 10             	mov    0x10(%di),%cx
    bc6d:	8b 55 1c             	mov    0x1c(%di),%dx
    bc70:	8b 45 20             	mov    0x20(%di),%ax
    bc73:	66 89 5d d4          	mov    %ebx,-0x2c(%di)
    bc77:	66 89 4d d0          	mov    %ecx,-0x30(%di)
    bc7b:	66 89 55 cc          	mov    %edx,-0x34(%di)
    bc7f:	66 89 45 c8          	mov    %eax,-0x38(%di)
    int minX= max(x,0);
    bc83:	6a 00                	push   $0x0
    bc85:	ff 75 14             	push   0x14(%di)
    bc88:	e8 a9 ff             	call   bc34 <abs+0x13>
    bc8b:	ff                   	(bad)
    bc8c:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    bc90:	89 45 f0             	mov    %ax,-0x10(%di)
    int maxX = min(x+w,vram_w);
    bc93:	0f b7 45 d4          	movzww -0x2c(%di),%ax
    bc97:	0f b7 4d cc          	movzww -0x34(%di),%cx
    bc9b:	8b 55 14             	mov    0x14(%di),%dx
    bc9e:	01 ca                	add    %cx,%dx
    bca0:	50                   	push   %ax
    bca1:	52                   	push   %dx
    bca2:	e8 a4 ff             	call   bc49 <max+0x13>
    bca5:	ff                   	(bad)
    bca6:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    bcaa:	89 45 ec             	mov    %ax,-0x14(%di)
    int minY=max(y,0);
    bcad:	6a 00                	push   $0x0
    bcaf:	ff 75 18             	push   0x18(%di)
    bcb2:	e8 7f ff             	call   bc34 <abs+0x13>
    bcb5:	ff                   	(bad)
    bcb6:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    bcba:	89 45 e8             	mov    %ax,-0x18(%di)
    int maxY= min(y+h,vram_h);
    bcbd:	0f b7 45 d0          	movzww -0x30(%di),%ax
    bcc1:	0f b7 4d c8          	movzww -0x38(%di),%cx
    bcc5:	8b 55 18             	mov    0x18(%di),%dx
    bcc8:	01 ca                	add    %cx,%dx
    bcca:	50                   	push   %ax
    bccb:	52                   	push   %dx
    bccc:	e8 7a ff             	call   bc49 <max+0x13>
    bccf:	ff                   	(bad)
    bcd0:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    bcd4:	89 45 e4             	mov    %ax,-0x1c(%di)
    if(maxX<=minX||maxY<=minY){
    bcd7:	8b 45 ec             	mov    -0x14(%di),%ax
    bcda:	3b 45 f0             	cmp    -0x10(%di),%ax
    bcdd:	7e 68                	jle    bd47 <draw_block+0xe7>
    bcdf:	8b 45 e4             	mov    -0x1c(%di),%ax
    bce2:	3b 45 e8             	cmp    -0x18(%di),%ax
    bce5:	7e 60                	jle    bd47 <draw_block+0xe7>
        return;
    }
    for (int ty = minY; ty < maxY; ++ty) {
    bce7:	8b 45 e8             	mov    -0x18(%di),%ax
    bcea:	89 45 f4             	mov    %ax,-0xc(%di)
    bced:	eb 4e                	jmp    bd3d <draw_block+0xdd>
        mem_copy(vram+ty*vram_w+minX,block+(ty-y)*w+minX-x,maxX-minX);
    bcef:	8b 45 ec             	mov    -0x14(%di),%ax
    bcf2:	2b 45 f0             	sub    -0x10(%di),%ax
    bcf5:	89 c3                	mov    %ax,%bx
    bcf7:	8b 45 f4             	mov    -0xc(%di),%ax
    bcfa:	2b 45 18             	sub    0x18(%di),%ax
    bcfd:	89 c2                	mov    %ax,%dx
    bcff:	0f b7 45 cc          	movzww -0x34(%di),%ax
    bd03:	0f af c2             	imul   %dx,%ax
    bd06:	89 c2                	mov    %ax,%dx
    bd08:	8b 45 f0             	mov    -0x10(%di),%ax
    bd0b:	01 c2                	add    %ax,%dx
    bd0d:	8b 45 14             	mov    0x14(%di),%ax
    bd10:	29 c2                	sub    %ax,%dx
    bd12:	8b 45 24             	mov    0x24(%di),%ax
    bd15:	01 c2                	add    %ax,%dx
    bd17:	0f b7 45 d4          	movzww -0x2c(%di),%ax
    bd1b:	0f af 45 f4          	imul   -0xc(%di),%ax
    bd1f:	89 c1                	mov    %ax,%cx
    bd21:	8b 45 f0             	mov    -0x10(%di),%ax
    bd24:	01 c1                	add    %ax,%cx
    bd26:	8b 45 08             	mov    0x8(%di),%ax
    bd29:	01 c8                	add    %cx,%ax
    bd2b:	83 ec 04             	sub    $0x4,%sp
    bd2e:	53                   	push   %bx
    bd2f:	52                   	push   %dx
    bd30:	50                   	push   %ax
    bd31:	e8 2e 1b             	call   d862 <mem_eq+0x60>
    bd34:	00 00                	add    %al,(%bx,%si)
    bd36:	83 c4 10             	add    $0x10,%sp
    for (int ty = minY; ty < maxY; ++ty) {
    bd39:	83 45 f4 01          	addw   $0x1,-0xc(%di)
    bd3d:	8b 45 f4             	mov    -0xc(%di),%ax
    bd40:	3b 45 e4             	cmp    -0x1c(%di),%ax
    bd43:	7c aa                	jl     bcef <draw_block+0x8f>
    bd45:	eb 01                	jmp    bd48 <draw_block+0xe8>
        return;
    bd47:	90                   	nop
    }
}
    bd48:	8b 5d fc             	mov    -0x4(%di),%bx
    bd4b:	c9                   	leave
    bd4c:	c3                   	ret

0000bd4d <draw_block_alpha>:

// 有透明通道的，会慢一点
void draw_block_alpha(uint8_t *vram, uint16_t vram_w,uint16_t vram_h, int x, int y, uint16_t w, uint16_t h, const uint8_t *block){
    bd4d:	55                   	push   %bp
    bd4e:	89 e5                	mov    %sp,%bp
    bd50:	53                   	push   %bx
    bd51:	83 ec 30             	sub    $0x30,%sp
    bd54:	8b 5d 0c             	mov    0xc(%di),%bx
    bd57:	8b 4d 10             	mov    0x10(%di),%cx
    bd5a:	8b 55 1c             	mov    0x1c(%di),%dx
    bd5d:	8b 45 20             	mov    0x20(%di),%ax
    bd60:	66 89 5d d8          	mov    %ebx,-0x28(%di)
    bd64:	66 89 4d d4          	mov    %ecx,-0x2c(%di)
    bd68:	66 89 55 d0          	mov    %edx,-0x30(%di)
    bd6c:	66 89 45 cc          	mov    %eax,-0x34(%di)
    int minX= max(x,0);
    bd70:	6a 00                	push   $0x0
    bd72:	ff 75 14             	push   0x14(%di)
    bd75:	e8 bc fe             	call   bc34 <abs+0x13>
    bd78:	ff                   	(bad)
    bd79:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    bd7d:	89 45 f0             	mov    %ax,-0x10(%di)
    int maxX = min(x+w,vram_w);
    bd80:	0f b7 45 d8          	movzww -0x28(%di),%ax
    bd84:	0f b7 4d d0          	movzww -0x30(%di),%cx
    bd88:	8b 55 14             	mov    0x14(%di),%dx
    bd8b:	01 ca                	add    %cx,%dx
    bd8d:	50                   	push   %ax
    bd8e:	52                   	push   %dx
    bd8f:	e8 b7 fe             	call   bc49 <max+0x13>
    bd92:	ff                   	(bad)
    bd93:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    bd97:	89 45 ec             	mov    %ax,-0x14(%di)
    int minY=max(y,0);
    bd9a:	6a 00                	push   $0x0
    bd9c:	ff 75 18             	push   0x18(%di)
    bd9f:	e8 92 fe             	call   bc34 <abs+0x13>
    bda2:	ff                   	(bad)
    bda3:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    bda7:	89 45 e8             	mov    %ax,-0x18(%di)
    int maxY= min(y+h,vram_h);
    bdaa:	0f b7 45 d4          	movzww -0x2c(%di),%ax
    bdae:	0f b7 4d cc          	movzww -0x34(%di),%cx
    bdb2:	8b 55 18             	mov    0x18(%di),%dx
    bdb5:	01 ca                	add    %cx,%dx
    bdb7:	50                   	push   %ax
    bdb8:	52                   	push   %dx
    bdb9:	e8 8d fe             	call   bc49 <max+0x13>
    bdbc:	ff                   	(bad)
    bdbd:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    bdc1:	89 45 e4             	mov    %ax,-0x1c(%di)
    if(maxX<=minX||maxY<=minY){
    bdc4:	8b 45 ec             	mov    -0x14(%di),%ax
    bdc7:	3b 45 f0             	cmp    -0x10(%di),%ax
    bdca:	7e 78                	jle    be44 <draw_block_alpha+0xf7>
    bdcc:	8b 45 e4             	mov    -0x1c(%di),%ax
    bdcf:	3b 45 e8             	cmp    -0x18(%di),%ax
    bdd2:	7e 70                	jle    be44 <draw_block_alpha+0xf7>
        return;
    }
    for (int ty = minY; ty < maxY; ++ty) {
    bdd4:	8b 45 e8             	mov    -0x18(%di),%ax
    bdd7:	89 45 f8             	mov    %ax,-0x8(%di)
    bdda:	eb 5e                	jmp    be3a <draw_block_alpha+0xed>
        for (int tx = minX; tx < maxX; ++tx) {
    bddc:	8b 45 f0             	mov    -0x10(%di),%ax
    bddf:	89 45 f4             	mov    %ax,-0xc(%di)
    bde2:	eb 4a                	jmp    be2e <draw_block_alpha+0xe1>
            uint8_t col = block[(ty-y)*w+tx-x];
    bde4:	8b 45 f8             	mov    -0x8(%di),%ax
    bde7:	2b 45 18             	sub    0x18(%di),%ax
    bdea:	89 c2                	mov    %ax,%dx
    bdec:	0f b7 45 d0          	movzww -0x30(%di),%ax
    bdf0:	0f af d0             	imul   %ax,%dx
    bdf3:	8b 45 f4             	mov    -0xc(%di),%ax
    bdf6:	01 d0                	add    %dx,%ax
    bdf8:	2b 45 14             	sub    0x14(%di),%ax
    bdfb:	89 c2                	mov    %ax,%dx
    bdfd:	8b 45 24             	mov    0x24(%di),%ax
    be00:	01 d0                	add    %dx,%ax
    be02:	0f b6 00             	movzbw (%bx,%si),%ax
    be05:	88 45 e3             	mov    %al,-0x1d(%di)
            if(col!=COL_ALPHA){
    be08:	80 7d e3 ff          	cmpb   $0xff,-0x1d(%di)
    be0c:	74 1c                	je     be2a <draw_block_alpha+0xdd>
                vram[ty* vram_w + tx]=col;
    be0e:	0f b7 45 d8          	movzww -0x28(%di),%ax
    be12:	0f af 45 f8          	imul   -0x8(%di),%ax
    be16:	89 c2                	mov    %ax,%dx
    be18:	8b 45 f4             	mov    -0xc(%di),%ax
    be1b:	01 d0                	add    %dx,%ax
    be1d:	89 c2                	mov    %ax,%dx
    be1f:	8b 45 08             	mov    0x8(%di),%ax
    be22:	01 c2                	add    %ax,%dx
    be24:	0f b6 45 e3          	movzbw -0x1d(%di),%ax
    be28:	88 02                	mov    %al,(%bp,%si)
        for (int tx = minX; tx < maxX; ++tx) {
    be2a:	83 45 f4 01          	addw   $0x1,-0xc(%di)
    be2e:	8b 45 f4             	mov    -0xc(%di),%ax
    be31:	3b 45 ec             	cmp    -0x14(%di),%ax
    be34:	7c ae                	jl     bde4 <draw_block_alpha+0x97>
    for (int ty = minY; ty < maxY; ++ty) {
    be36:	83 45 f8 01          	addw   $0x1,-0x8(%di)
    be3a:	8b 45 f8             	mov    -0x8(%di),%ax
    be3d:	3b 45 e4             	cmp    -0x1c(%di),%ax
    be40:	7c 9a                	jl     bddc <draw_block_alpha+0x8f>
    be42:	eb 01                	jmp    be45 <draw_block_alpha+0xf8>
        return;
    be44:	90                   	nop
            }
        }
    }
}
    be45:	8b 5d fc             	mov    -0x4(%di),%bx
    be48:	c9                   	leave
    be49:	c3                   	ret

0000be4a <draw_block_sub>:

// 无透明通道版本
void draw_block_sub(uint8_t *vram, uint16_t vram_w, int minX, int minY, int maxX, int maxY,
                    int x, int y, uint16_t w, uint16_t h, uint8_t *block){
    be4a:	55                   	push   %bp
    be4b:	89 e5                	mov    %sp,%bp
    be4d:	53                   	push   %bx
    be4e:	83 ec 24             	sub    $0x24,%sp
    be51:	8b 4d 0c             	mov    0xc(%di),%cx
    be54:	8b 55 28             	mov    0x28(%di),%dx
    be57:	8b 45 2c             	mov    0x2c(%di),%ax
    be5a:	66 89 4d e4          	mov    %ecx,-0x1c(%di)
    be5e:	66 89 55 e0          	mov    %edx,-0x20(%di)
    be62:	66 89 45 dc          	mov    %eax,-0x24(%di)
    minX= max(minX,x);
    be66:	ff 75 20             	push   0x20(%di)
    be69:	ff 75 10             	push   0x10(%di)
    be6c:	e8 c5 fd             	call   bc34 <abs+0x13>
    be6f:	ff                   	(bad)
    be70:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    be74:	89 45 10             	mov    %ax,0x10(%di)
    maxX= min(maxX,x+w);
    be77:	0f b7 55 e0          	movzww -0x20(%di),%dx
    be7b:	8b 45 20             	mov    0x20(%di),%ax
    be7e:	01 d0                	add    %dx,%ax
    be80:	50                   	push   %ax
    be81:	ff 75 18             	push   0x18(%di)
    be84:	e8 c2 fd             	call   bc49 <max+0x13>
    be87:	ff                   	(bad)
    be88:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    be8c:	89 45 18             	mov    %ax,0x18(%di)
    minY= max(minY,y);
    be8f:	ff 75 24             	push   0x24(%di)
    be92:	ff 75 14             	push   0x14(%di)
    be95:	e8 9c fd             	call   bc34 <abs+0x13>
    be98:	ff                   	(bad)
    be99:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    be9d:	89 45 14             	mov    %ax,0x14(%di)
    maxY= min(maxY,y+h);
    bea0:	0f b7 55 dc          	movzww -0x24(%di),%dx
    bea4:	8b 45 24             	mov    0x24(%di),%ax
    bea7:	01 d0                	add    %dx,%ax
    bea9:	50                   	push   %ax
    beaa:	ff 75 1c             	push   0x1c(%di)
    bead:	e8 99 fd             	call   bc49 <max+0x13>
    beb0:	ff                   	(bad)
    beb1:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    beb5:	89 45 1c             	mov    %ax,0x1c(%di)
    if(maxX<=minX||maxY<=minY){
    beb8:	8b 45 18             	mov    0x18(%di),%ax
    bebb:	3b 45 10             	cmp    0x10(%di),%ax
    bebe:	7e 68                	jle    bf28 <draw_block_sub+0xde>
    bec0:	8b 45 1c             	mov    0x1c(%di),%ax
    bec3:	3b 45 14             	cmp    0x14(%di),%ax
    bec6:	7e 60                	jle    bf28 <draw_block_sub+0xde>
        return;
    }
    for (int ty = minY; ty < maxY; ++ty) {
    bec8:	8b 45 14             	mov    0x14(%di),%ax
    becb:	89 45 f4             	mov    %ax,-0xc(%di)
    bece:	eb 4e                	jmp    bf1e <draw_block_sub+0xd4>
        mem_copy(vram+ty*vram_w+minX,block+(ty-y)*w+minX-x,maxX-minX);
    bed0:	8b 45 18             	mov    0x18(%di),%ax
    bed3:	2b 45 10             	sub    0x10(%di),%ax
    bed6:	89 c3                	mov    %ax,%bx
    bed8:	8b 45 f4             	mov    -0xc(%di),%ax
    bedb:	2b 45 24             	sub    0x24(%di),%ax
    bede:	89 c2                	mov    %ax,%dx
    bee0:	0f b7 45 e0          	movzww -0x20(%di),%ax
    bee4:	0f af c2             	imul   %dx,%ax
    bee7:	89 c2                	mov    %ax,%dx
    bee9:	8b 45 10             	mov    0x10(%di),%ax
    beec:	01 c2                	add    %ax,%dx
    beee:	8b 45 20             	mov    0x20(%di),%ax
    bef1:	29 c2                	sub    %ax,%dx
    bef3:	8b 45 30             	mov    0x30(%di),%ax
    bef6:	01 c2                	add    %ax,%dx
    bef8:	0f b7 45 e4          	movzww -0x1c(%di),%ax
    befc:	0f af 45 f4          	imul   -0xc(%di),%ax
    bf00:	89 c1                	mov    %ax,%cx
    bf02:	8b 45 10             	mov    0x10(%di),%ax
    bf05:	01 c1                	add    %ax,%cx
    bf07:	8b 45 08             	mov    0x8(%di),%ax
    bf0a:	01 c8                	add    %cx,%ax
    bf0c:	83 ec 04             	sub    $0x4,%sp
    bf0f:	53                   	push   %bx
    bf10:	52                   	push   %dx
    bf11:	50                   	push   %ax
    bf12:	e8 4d 19             	call   d862 <mem_eq+0x60>
    bf15:	00 00                	add    %al,(%bx,%si)
    bf17:	83 c4 10             	add    $0x10,%sp
    for (int ty = minY; ty < maxY; ++ty) {
    bf1a:	83 45 f4 01          	addw   $0x1,-0xc(%di)
    bf1e:	8b 45 f4             	mov    -0xc(%di),%ax
    bf21:	3b 45 1c             	cmp    0x1c(%di),%ax
    bf24:	7c aa                	jl     bed0 <draw_block_sub+0x86>
    bf26:	eb 01                	jmp    bf29 <draw_block_sub+0xdf>
        return;
    bf28:	90                   	nop
    }
}
    bf29:	8b 5d fc             	mov    -0x4(%di),%bx
    bf2c:	c9                   	leave
    bf2d:	c3                   	ret

0000bf2e <draw_block_sub_alpha>:

// 有透明通道版本会慢一些
void draw_block_sub_alpha(uint8_t *vram, uint16_t vram_w, int minX, int minY, int maxX, int maxY,
                    int x, int y, uint16_t w, uint16_t h, const uint8_t *block){
    bf2e:	55                   	push   %bp
    bf2f:	89 e5                	mov    %sp,%bp
    bf31:	83 ec 1c             	sub    $0x1c,%sp
    bf34:	8b 4d 0c             	mov    0xc(%di),%cx
    bf37:	8b 55 28             	mov    0x28(%di),%dx
    bf3a:	8b 45 2c             	mov    0x2c(%di),%ax
    bf3d:	66 89 4d ec          	mov    %ecx,-0x14(%di)
    bf41:	66 89 55 e8          	mov    %edx,-0x18(%di)
    bf45:	66 89 45 e4          	mov    %eax,-0x1c(%di)
    minX= max(minX,x);
    bf49:	ff 75 20             	push   0x20(%di)
    bf4c:	ff 75 10             	push   0x10(%di)
    bf4f:	e8 e2 fc             	call   bc34 <abs+0x13>
    bf52:	ff                   	(bad)
    bf53:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    bf57:	89 45 10             	mov    %ax,0x10(%di)
    maxX= min(maxX,x+w);
    bf5a:	0f b7 55 e8          	movzww -0x18(%di),%dx
    bf5e:	8b 45 20             	mov    0x20(%di),%ax
    bf61:	01 d0                	add    %dx,%ax
    bf63:	50                   	push   %ax
    bf64:	ff 75 18             	push   0x18(%di)
    bf67:	e8 df fc             	call   bc49 <max+0x13>
    bf6a:	ff                   	(bad)
    bf6b:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    bf6f:	89 45 18             	mov    %ax,0x18(%di)
    minY= max(minY,y);
    bf72:	ff 75 24             	push   0x24(%di)
    bf75:	ff 75 14             	push   0x14(%di)
    bf78:	e8 b9 fc             	call   bc34 <abs+0x13>
    bf7b:	ff                   	(bad)
    bf7c:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    bf80:	89 45 14             	mov    %ax,0x14(%di)
    maxY= min(maxY,y+h);
    bf83:	0f b7 55 e4          	movzww -0x1c(%di),%dx
    bf87:	8b 45 24             	mov    0x24(%di),%ax
    bf8a:	01 d0                	add    %dx,%ax
    bf8c:	50                   	push   %ax
    bf8d:	ff 75 1c             	push   0x1c(%di)
    bf90:	e8 b6 fc             	call   bc49 <max+0x13>
    bf93:	ff                   	(bad)
    bf94:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    bf98:	89 45 1c             	mov    %ax,0x1c(%di)
    if(maxX<=minX||maxY<=minY){
    bf9b:	8b 45 18             	mov    0x18(%di),%ax
    bf9e:	3b 45 10             	cmp    0x10(%di),%ax
    bfa1:	7e 78                	jle    c01b <draw_block_sub_alpha+0xed>
    bfa3:	8b 45 1c             	mov    0x1c(%di),%ax
    bfa6:	3b 45 14             	cmp    0x14(%di),%ax
    bfa9:	7e 70                	jle    c01b <draw_block_sub_alpha+0xed>
        return;
    }
    for (int ty = minY; ty < maxY; ++ty) {
    bfab:	8b 45 14             	mov    0x14(%di),%ax
    bfae:	89 45 fc             	mov    %ax,-0x4(%di)
    bfb1:	eb 5e                	jmp    c011 <draw_block_sub_alpha+0xe3>
        for (int tx = minX; tx < maxX; ++tx) {
    bfb3:	8b 45 10             	mov    0x10(%di),%ax
    bfb6:	89 45 f8             	mov    %ax,-0x8(%di)
    bfb9:	eb 4a                	jmp    c005 <draw_block_sub_alpha+0xd7>
            uint8_t col = block[(ty-y)*w+tx-x];
    bfbb:	8b 45 fc             	mov    -0x4(%di),%ax
    bfbe:	2b 45 24             	sub    0x24(%di),%ax
    bfc1:	89 c2                	mov    %ax,%dx
    bfc3:	0f b7 45 e8          	movzww -0x18(%di),%ax
    bfc7:	0f af d0             	imul   %ax,%dx
    bfca:	8b 45 f8             	mov    -0x8(%di),%ax
    bfcd:	01 d0                	add    %dx,%ax
    bfcf:	2b 45 20             	sub    0x20(%di),%ax
    bfd2:	89 c2                	mov    %ax,%dx
    bfd4:	8b 45 30             	mov    0x30(%di),%ax
    bfd7:	01 d0                	add    %dx,%ax
    bfd9:	0f b6 00             	movzbw (%bx,%si),%ax
    bfdc:	88 45 f7             	mov    %al,-0x9(%di)
            if(col!=COL_ALPHA){
    bfdf:	80 7d f7 ff          	cmpb   $0xff,-0x9(%di)
    bfe3:	74 1c                	je     c001 <draw_block_sub_alpha+0xd3>
                vram[ty * vram_w + tx]=col;
    bfe5:	0f b7 45 ec          	movzww -0x14(%di),%ax
    bfe9:	0f af 45 fc          	imul   -0x4(%di),%ax
    bfed:	89 c2                	mov    %ax,%dx
    bfef:	8b 45 f8             	mov    -0x8(%di),%ax
    bff2:	01 d0                	add    %dx,%ax
    bff4:	89 c2                	mov    %ax,%dx
    bff6:	8b 45 08             	mov    0x8(%di),%ax
    bff9:	01 c2                	add    %ax,%dx
    bffb:	0f b6 45 f7          	movzbw -0x9(%di),%ax
    bfff:	88 02                	mov    %al,(%bp,%si)
        for (int tx = minX; tx < maxX; ++tx) {
    c001:	83 45 f8 01          	addw   $0x1,-0x8(%di)
    c005:	8b 45 f8             	mov    -0x8(%di),%ax
    c008:	3b 45 18             	cmp    0x18(%di),%ax
    c00b:	7c ae                	jl     bfbb <draw_block_sub_alpha+0x8d>
    for (int ty = minY; ty < maxY; ++ty) {
    c00d:	83 45 fc 01          	addw   $0x1,-0x4(%di)
    c011:	8b 45 fc             	mov    -0x4(%di),%ax
    c014:	3b 45 1c             	cmp    0x1c(%di),%ax
    c017:	7c 9a                	jl     bfb3 <draw_block_sub_alpha+0x85>
    c019:	eb 01                	jmp    c01c <draw_block_sub_alpha+0xee>
        return;
    c01b:	90                   	nop
            }
        }
    }
}
    c01c:	c9                   	leave
    c01d:	c3                   	ret

0000c01e <fill_alpha>:

void fill_alpha(uint8_t *vram, uint16_t w, uint16_t h){
    c01e:	55                   	push   %bp
    c01f:	89 e5                	mov    %sp,%bp
    c021:	83 ec 18             	sub    $0x18,%sp
    c024:	8b 55 0c             	mov    0xc(%di),%dx
    c027:	8b 45 10             	mov    0x10(%di),%ax
    c02a:	66 89 55 f4          	mov    %edx,-0xc(%di)
    c02e:	66 89 45 f0          	mov    %eax,-0x10(%di)
    mem_set(vram,COL_ALPHA,(uint32_t)w*(uint32_t)h);
    c032:	0f b7 55 f4          	movzww -0xc(%di),%dx
    c036:	0f b7 45 f0          	movzww -0x10(%di),%ax
    c03a:	0f af c2             	imul   %dx,%ax
    c03d:	83 ec 04             	sub    $0x4,%sp
    c040:	50                   	push   %ax
    c041:	68 ff 00             	push   $0xff
    c044:	00 00                	add    %al,(%bx,%si)
    c046:	ff 75 08             	push   0x8(%di)
    c049:	e8 7a 17             	call   d7c6 <fmt+0x140>
    c04c:	00 00                	add    %al,(%bx,%si)
    c04e:	83 c4 10             	add    $0x10,%sp
}
    c051:	90                   	nop
    c052:	c9                   	leave
    c053:	c3                   	ret

0000c054 <fill_rect>:

void fill_rect(uint8_t *vram, uint16_t vram_w, uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t col){
    c054:	55                   	push   %bp
    c055:	89 e5                	mov    %sp,%bp
    c057:	57                   	push   %di
    c058:	56                   	push   %si
    c059:	53                   	push   %bx
    c05a:	83 ec 3c             	sub    $0x3c,%sp
    c05d:	8b 7d 0c             	mov    0xc(%di),%di
    c060:	8b 75 10             	mov    0x10(%di),%si
    c063:	8b 5d 14             	mov    0x14(%di),%bx
    c066:	8b 4d 18             	mov    0x18(%di),%cx
    c069:	8b 55 1c             	mov    0x1c(%di),%dx
    c06c:	8b 45 20             	mov    0x20(%di),%ax
    c06f:	66 89 7d d4          	mov    %edi,-0x2c(%di)
    c073:	66 89 75 d0          	mov    %esi,-0x30(%di)
    c077:	66 89 5d cc          	mov    %ebx,-0x34(%di)
    c07b:	66 89 4d c8          	mov    %ecx,-0x38(%di)
    c07f:	66 89 55 c4          	mov    %edx,-0x3c(%di)
    c083:	88 45 c0             	mov    %al,-0x40(%di)
    for (int ty = 0; ty < h; ++ty) {
    c086:	c7 45 e4 00 00       	movw   $0x0,-0x1c(%di)
    c08b:	00 00                	add    %al,(%bx,%si)
    c08d:	eb 37                	jmp    c0c6 <fill_rect+0x72>
        mem_set(vram+(ty + y) * vram_w + x,col,w);
    c08f:	0f b7 55 c8          	movzww -0x38(%di),%dx
    c093:	0f b6 45 c0          	movzbw -0x40(%di),%ax
    c097:	0f b7 5d cc          	movzww -0x34(%di),%bx
    c09b:	8b 4d e4             	mov    -0x1c(%di),%cx
    c09e:	01 cb                	add    %cx,%bx
    c0a0:	0f b7 4d d4          	movzww -0x2c(%di),%cx
    c0a4:	0f af cb             	imul   %bx,%cx
    c0a7:	89 cb                	mov    %cx,%bx
    c0a9:	0f b7 4d d0          	movzww -0x30(%di),%cx
    c0ad:	01 cb                	add    %cx,%bx
    c0af:	8b 4d 08             	mov    0x8(%di),%cx
    c0b2:	01 d9                	add    %bx,%cx
    c0b4:	83 ec 04             	sub    $0x4,%sp
    c0b7:	52                   	push   %dx
    c0b8:	50                   	push   %ax
    c0b9:	51                   	push   %cx
    c0ba:	e8 09 17             	call   d7c6 <fmt+0x140>
    c0bd:	00 00                	add    %al,(%bx,%si)
    c0bf:	83 c4 10             	add    $0x10,%sp
    for (int ty = 0; ty < h; ++ty) {
    c0c2:	83 45 e4 01          	addw   $0x1,-0x1c(%di)
    c0c6:	0f b7 45 c4          	movzww -0x3c(%di),%ax
    c0ca:	39 45 e4             	cmp    %ax,-0x1c(%di)
    c0cd:	7c c0                	jl     c08f <fill_rect+0x3b>
    }
}
    c0cf:	90                   	nop
    c0d0:	90                   	nop
    c0d1:	8d 65 f4             	lea    -0xc(%di),%sp
    c0d4:	5b                   	pop    %bx
    c0d5:	5e                   	pop    %si
    c0d6:	5f                   	pop    %di
    c0d7:	5d                   	pop    %bp
    c0d8:	c3                   	ret

0000c0d9 <draw_point>:

void draw_point(uint8_t *vram, uint16_t vram_w, uint16_t x, uint16_t y,uint8_t col){
    c0d9:	55                   	push   %bp
    c0da:	89 e5                	mov    %sp,%bp
    c0dc:	53                   	push   %bx
    c0dd:	83 ec 10             	sub    $0x10,%sp
    c0e0:	8b 5d 0c             	mov    0xc(%di),%bx
    c0e3:	8b 4d 10             	mov    0x10(%di),%cx
    c0e6:	8b 55 14             	mov    0x14(%di),%dx
    c0e9:	8b 45 18             	mov    0x18(%di),%ax
    c0ec:	66 89 5d f8          	mov    %ebx,-0x8(%di)
    c0f0:	66 89 4d f4          	mov    %ecx,-0xc(%di)
    c0f4:	66 89 55 f0          	mov    %edx,-0x10(%di)
    c0f8:	88 45 ec             	mov    %al,-0x14(%di)
    vram[y*vram_w+x]=col;
    c0fb:	0f b7 55 f0          	movzww -0x10(%di),%dx
    c0ff:	0f b7 45 f8          	movzww -0x8(%di),%ax
    c103:	0f af d0             	imul   %ax,%dx
    c106:	0f b7 45 f4          	movzww -0xc(%di),%ax
    c10a:	01 d0                	add    %dx,%ax
    c10c:	89 c2                	mov    %ax,%dx
    c10e:	8b 45 08             	mov    0x8(%di),%ax
    c111:	01 c2                	add    %ax,%dx
    c113:	0f b6 45 ec          	movzbw -0x14(%di),%ax
    c117:	88 02                	mov    %al,(%bp,%si)
}
    c119:	90                   	nop
    c11a:	8b 5d fc             	mov    -0x4(%di),%bx
    c11d:	c9                   	leave
    c11e:	c3                   	ret

0000c11f <draw_line>:

// 注意绘制线要考虑负数
void draw_line(uint8_t *vram, uint16_t vram_w,uint16_t x0,uint16_t y0,uint16_t x1,uint16_t y1,uint8_t col){
    c11f:	55                   	push   %bp
    c120:	89 e5                	mov    %sp,%bp
    c122:	57                   	push   %di
    c123:	56                   	push   %si
    c124:	53                   	push   %bx
    c125:	83 ec 28             	sub    $0x28,%sp
    c128:	8b 7d 0c             	mov    0xc(%di),%di
    c12b:	8b 75 10             	mov    0x10(%di),%si
    c12e:	8b 5d 14             	mov    0x14(%di),%bx
    c131:	8b 4d 18             	mov    0x18(%di),%cx
    c134:	8b 55 1c             	mov    0x1c(%di),%dx
    c137:	8b 45 20             	mov    0x20(%di),%ax
    c13a:	66 89 7d e0          	mov    %edi,-0x20(%di)
    c13e:	66 89 75 dc          	mov    %esi,-0x24(%di)
    c142:	66 89 5d d8          	mov    %ebx,-0x28(%di)
    c146:	66 89 4d d4          	mov    %ecx,-0x2c(%di)
    c14a:	66 89 55 d0          	mov    %edx,-0x30(%di)
    c14e:	88 45 cc             	mov    %al,-0x34(%di)
    uint16_t stepX;
    uint16_t stepY;
    uint16_t count;
    if(abs(x0-x1)> abs(y0-y1)){// 谁大把谁当成1的标准 因为存在小数 这里 * 1024
    c151:	0f b7 55 dc          	movzww -0x24(%di),%dx
    c155:	0f b7 45 d4          	movzww -0x2c(%di),%ax
    c159:	29 c2                	sub    %ax,%dx
    c15b:	52                   	push   %dx
    c15c:	e8 c0 fa             	call   bc1f <write_eflags+0x9>
    c15f:	ff                   	(bad)
    c160:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
    c164:	89 c3                	mov    %ax,%bx
    c166:	0f b7 55 d8          	movzww -0x28(%di),%dx
    c16a:	0f b7 45 d0          	movzww -0x30(%di),%ax
    c16e:	29 c2                	sub    %ax,%dx
    c170:	52                   	push   %dx
    c171:	e8 ab fa             	call   bc1f <write_eflags+0x9>
    c174:	ff                   	(bad)
    c175:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
    c179:	39 c3                	cmp    %ax,%bx
    c17b:	7e 3f                	jle    c1bc <draw_line+0x9d>
        stepX=1024;
    c17d:	66 c7 45 f2 00 04 0f 	movl   $0xb70f0400,-0xe(%di)
    c184:	b7 
        stepY=((y1-y0)<<10)/(x1-x0);
    c185:	55                   	push   %bp
    c186:	d0 0f                	rorb   (%bx)
    c188:	b7 45                	mov    $0x45,%bh
    c18a:	d8 29                	fsubrs (%bx,%di)
    c18c:	c2 c1 e2             	ret    $0xe2c1
    c18f:	0a 0f                	or     (%bx),%cl
    c191:	b7 4d                	mov    $0x4d,%bh
    c193:	d4 0f                	aam    $0xf
    c195:	b7 45                	mov    $0x45,%bh
    c197:	dc 29                	fsubrl (%bx,%di)
    c199:	c1 89 d0 99 f7       	rorw   $0xf7,-0x6630(%bx,%di)
    c19e:	f9                   	stc
    c19f:	66 89 45 f0          	mov    %eax,-0x10(%di)
        count= abs(x1-x0);
    c1a3:	0f b7 55 d4          	movzww -0x2c(%di),%dx
    c1a7:	0f b7 45 dc          	movzww -0x24(%di),%ax
    c1ab:	29 c2                	sub    %ax,%dx
    c1ad:	52                   	push   %dx
    c1ae:	e8 6e fa             	call   bc1f <write_eflags+0x9>
    c1b1:	ff                   	(bad)
    c1b2:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
    c1b6:	66 89 45 ee          	mov    %eax,-0x12(%di)
    c1ba:	eb 3d                	jmp    c1f9 <draw_line+0xda>
    } else{
        stepY=1024;
    c1bc:	66 c7 45 f0 00 04 0f 	movl   $0xb70f0400,-0x10(%di)
    c1c3:	b7 
        stepX=((x1-x0)<<10)/(y1-y0);
    c1c4:	55                   	push   %bp
    c1c5:	d4 0f                	aam    $0xf
    c1c7:	b7 45                	mov    $0x45,%bh
    c1c9:	dc 29                	fsubrl (%bx,%di)
    c1cb:	c2 c1 e2             	ret    $0xe2c1
    c1ce:	0a 0f                	or     (%bx),%cl
    c1d0:	b7 4d                	mov    $0x4d,%bh
    c1d2:	d0 0f                	rorb   (%bx)
    c1d4:	b7 45                	mov    $0x45,%bh
    c1d6:	d8 29                	fsubrs (%bx,%di)
    c1d8:	c1 89 d0 99 f7       	rorw   $0xf7,-0x6630(%bx,%di)
    c1dd:	f9                   	stc
    c1de:	66 89 45 f2          	mov    %eax,-0xe(%di)
        count= abs(y1-y0);
    c1e2:	0f b7 55 d0          	movzww -0x30(%di),%dx
    c1e6:	0f b7 45 d8          	movzww -0x28(%di),%ax
    c1ea:	29 c2                	sub    %ax,%dx
    c1ec:	52                   	push   %dx
    c1ed:	e8 2f fa             	call   bc1f <write_eflags+0x9>
    c1f0:	ff                   	(bad)
    c1f1:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
    c1f5:	66 89 45 ee          	mov    %eax,-0x12(%di)
    }
    for (int i = 0; i < count; ++i) {
    c1f9:	c7 45 e8 00 00       	movw   $0x0,-0x18(%di)
    c1fe:	00 00                	add    %al,(%bx,%si)
    c200:	eb 50                	jmp    c252 <draw_line+0x133>
        uint16_t x=x0+(stepX*i>>10);
    c202:	0f b7 45 f2          	movzww -0xe(%di),%ax
    c206:	0f af 45 e8          	imul   -0x18(%di),%ax
    c20a:	c1 f8 0a             	sar    $0xa,%ax
    c20d:	89 c2                	mov    %ax,%dx
    c20f:	0f b7 45 dc          	movzww -0x24(%di),%ax
    c213:	01 d0                	add    %dx,%ax
    c215:	66 89 45 e6          	mov    %eax,-0x1a(%di)
        uint16_t y=y0+(stepY*i>>10);
    c219:	0f b7 45 f0          	movzww -0x10(%di),%ax
    c21d:	0f af 45 e8          	imul   -0x18(%di),%ax
    c221:	c1 f8 0a             	sar    $0xa,%ax
    c224:	89 c2                	mov    %ax,%dx
    c226:	0f b7 45 d8          	movzww -0x28(%di),%ax
    c22a:	01 d0                	add    %dx,%ax
    c22c:	66 89 45 e4          	mov    %eax,-0x1c(%di)
        vram[y*vram_w+x]=col;
    c230:	0f b7 55 e4          	movzww -0x1c(%di),%dx
    c234:	0f b7 45 e0          	movzww -0x20(%di),%ax
    c238:	0f af d0             	imul   %ax,%dx
    c23b:	0f b7 45 e6          	movzww -0x1a(%di),%ax
    c23f:	01 d0                	add    %dx,%ax
    c241:	89 c2                	mov    %ax,%dx
    c243:	8b 45 08             	mov    0x8(%di),%ax
    c246:	01 c2                	add    %ax,%dx
    c248:	0f b6 45 cc          	movzbw -0x34(%di),%ax
    c24c:	88 02                	mov    %al,(%bp,%si)
    for (int i = 0; i < count; ++i) {
    c24e:	83 45 e8 01          	addw   $0x1,-0x18(%di)
    c252:	0f b7 45 ee          	movzww -0x12(%di),%ax
    c256:	39 45 e8             	cmp    %ax,-0x18(%di)
    c259:	7c a7                	jl     c202 <draw_line+0xe3>
    }
}
    c25b:	90                   	nop
    c25c:	90                   	nop
    c25d:	8d 65 f4             	lea    -0xc(%di),%sp
    c260:	5b                   	pop    %bx
    c261:	5e                   	pop    %si
    c262:	5f                   	pop    %di
    c263:	5d                   	pop    %bp
    c264:	c3                   	ret

0000c265 <draw_char>:

void draw_char(uint8_t *vram, uint16_t vram_w, uint16_t x, uint16_t y, char c, uint8_t col){
    c265:	55                   	push   %bp
    c266:	89 e5                	mov    %sp,%bp
    c268:	56                   	push   %si
    c269:	53                   	push   %bx
    c26a:	83 ec 24             	sub    $0x24,%sp
    c26d:	8b 75 0c             	mov    0xc(%di),%si
    c270:	8b 5d 10             	mov    0x10(%di),%bx
    c273:	8b 4d 14             	mov    0x14(%di),%cx
    c276:	8b 55 18             	mov    0x18(%di),%dx
    c279:	8b 45 1c             	mov    0x1c(%di),%ax
    c27c:	66 89 75 e4          	mov    %esi,-0x1c(%di)
    c280:	66 89 5d e0          	mov    %ebx,-0x20(%di)
    c284:	66 89 4d dc          	mov    %ecx,-0x24(%di)
    c288:	88 55 d8             	mov    %dl,-0x28(%di)
    c28b:	88 45 d4             	mov    %al,-0x2c(%di)
    int index = c*16;
    c28e:	0f be 45 d8          	movsbw -0x28(%di),%ax
    c292:	c1 e0 04             	shl    $0x4,%ax
    c295:	89 45 f4             	mov    %ax,-0xc(%di)
    for (int ty = 0; ty < 16; ty++) {
    c298:	c7 45 f0 00 00       	movw   $0x0,-0x10(%di)
    c29d:	00 00                	add    %al,(%bx,%si)
    c29f:	eb 68                	jmp    c309 <draw_char+0xa4>
        uint8_t b=fonts[index];
    c2a1:	8b 15                	mov    (%di),%dx
    c2a3:	94                   	xchg   %ax,%sp
    c2a4:	ed                   	in     (%dx),%ax
    c2a5:	00 00                	add    %al,(%bx,%si)
    c2a7:	8b 45 f4             	mov    -0xc(%di),%ax
    c2aa:	01 d0                	add    %dx,%ax
    c2ac:	0f b6 00             	movzbw (%bx,%si),%ax
    c2af:	88 45 eb             	mov    %al,-0x15(%di)
        index++;
    c2b2:	83 45 f4 01          	addw   $0x1,-0xc(%di)
        for (int tx = 0; tx < 8; ++tx) {
    c2b6:	c7 45 ec 00 00       	movw   $0x0,-0x14(%di)
    c2bb:	00 00                	add    %al,(%bx,%si)
    c2bd:	eb 40                	jmp    c2ff <draw_char+0x9a>
            if(b&(1<<tx)){
    c2bf:	0f b6 55 eb          	movzbw -0x15(%di),%dx
    c2c3:	8b 45 ec             	mov    -0x14(%di),%ax
    c2c6:	89 c1                	mov    %ax,%cx
    c2c8:	d3 fa                	sar    %cl,%dx
    c2ca:	89 d0                	mov    %dx,%ax
    c2cc:	83 e0 01             	and    $0x1,%ax
    c2cf:	85 c0                	test   %ax,%ax
    c2d1:	74 28                	je     c2fb <draw_char+0x96>
                vram[(ty + y) * vram_w + tx + x]=col;
    c2d3:	0f b7 55 dc          	movzww -0x24(%di),%dx
    c2d7:	8b 45 f0             	mov    -0x10(%di),%ax
    c2da:	01 c2                	add    %ax,%dx
    c2dc:	0f b7 45 e4          	movzww -0x1c(%di),%ax
    c2e0:	0f af d0             	imul   %ax,%dx
    c2e3:	8b 45 ec             	mov    -0x14(%di),%ax
    c2e6:	01 c2                	add    %ax,%dx
    c2e8:	0f b7 45 e0          	movzww -0x20(%di),%ax
    c2ec:	01 d0                	add    %dx,%ax
    c2ee:	89 c2                	mov    %ax,%dx
    c2f0:	8b 45 08             	mov    0x8(%di),%ax
    c2f3:	01 c2                	add    %ax,%dx
    c2f5:	0f b6 45 d4          	movzbw -0x2c(%di),%ax
    c2f9:	88 02                	mov    %al,(%bp,%si)
        for (int tx = 0; tx < 8; ++tx) {
    c2fb:	83 45 ec 01          	addw   $0x1,-0x14(%di)
    c2ff:	83 7d ec 07          	cmpw   $0x7,-0x14(%di)
    c303:	7e ba                	jle    c2bf <draw_char+0x5a>
    for (int ty = 0; ty < 16; ty++) {
    c305:	83 45 f0 01          	addw   $0x1,-0x10(%di)
    c309:	83 7d f0 0f          	cmpw   $0xf,-0x10(%di)
    c30d:	7e 92                	jle    c2a1 <draw_char+0x3c>
            }
        }
    }
}
    c30f:	90                   	nop
    c310:	90                   	nop
    c311:	83 c4 24             	add    $0x24,%sp
    c314:	5b                   	pop    %bx
    c315:	5e                   	pop    %si
    c316:	5d                   	pop    %bp
    c317:	c3                   	ret

0000c318 <draw_str>:

void draw_str(uint8_t *vram, uint16_t vram_w, uint16_t x, uint16_t y, char *s, uint8_t col){
    c318:	55                   	push   %bp
    c319:	89 e5                	mov    %sp,%bp
    c31b:	56                   	push   %si
    c31c:	53                   	push   %bx
    c31d:	83 ec 10             	sub    $0x10,%sp
    c320:	8b 5d 0c             	mov    0xc(%di),%bx
    c323:	8b 4d 10             	mov    0x10(%di),%cx
    c326:	8b 55 14             	mov    0x14(%di),%dx
    c329:	8b 45 1c             	mov    0x1c(%di),%ax
    c32c:	66 89 5d f4          	mov    %ebx,-0xc(%di)
    c330:	66 89 4d f0          	mov    %ecx,-0x10(%di)
    c334:	66 89 55 ec          	mov    %edx,-0x14(%di)
    c338:	88 45 e8             	mov    %al,-0x18(%di)
    while (*s!=0x00){
    c33b:	eb 32                	jmp    c36f <draw_str+0x57>
        draw_char(vram, vram_w, x, y, *s, col);
    c33d:	0f b6 75 e8          	movzbw -0x18(%di),%si
    c341:	8b 45 18             	mov    0x18(%di),%ax
    c344:	0f b6 00             	movzbw (%bx,%si),%ax
    c347:	0f be d8             	movsbw %al,%bx
    c34a:	0f b7 4d ec          	movzww -0x14(%di),%cx
    c34e:	0f b7 55 f0          	movzww -0x10(%di),%dx
    c352:	0f b7 45 f4          	movzww -0xc(%di),%ax
    c356:	56                   	push   %si
    c357:	53                   	push   %bx
    c358:	51                   	push   %cx
    c359:	52                   	push   %dx
    c35a:	50                   	push   %ax
    c35b:	ff 75 08             	push   0x8(%di)
    c35e:	e8 02 ff             	call   c263 <draw_line+0x144>
    c361:	ff                   	(bad)
    c362:	ff 83 c4 18          	incw   0x18c4(%bp,%di)
        s++;
    c366:	83 45 18 01          	addw   $0x1,0x18(%di)
        x+=8;
    c36a:	66 83 45 f0 08       	addl   $0x8,-0x10(%di)
    while (*s!=0x00){
    c36f:	8b 45 18             	mov    0x18(%di),%ax
    c372:	0f b6 00             	movzbw (%bx,%si),%ax
    c375:	84 c0                	test   %al,%al
    c377:	75 c4                	jne    c33d <draw_str+0x25>
    }
}
    c379:	90                   	nop
    c37a:	90                   	nop
    c37b:	8d 65 f8             	lea    -0x8(%di),%sp
    c37e:	5b                   	pop    %bx
    c37f:	5e                   	pop    %si
    c380:	5d                   	pop    %bp
    c381:	c3                   	ret

0000c382 <set_palette>:

void set_palette(uint8_t index, const uint8_t *rgbs,uint8_t size){
    c382:	55                   	push   %bp
    c383:	89 e5                	mov    %sp,%bp
    c385:	83 ec 18             	sub    $0x18,%sp
    c388:	8b 55 08             	mov    0x8(%di),%dx
    c38b:	8b 45 10             	mov    0x10(%di),%ax
    c38e:	88 55 ec             	mov    %dl,-0x14(%di)
    c391:	88 45 e8             	mov    %al,-0x18(%di)
    uint32_t eflags = read_eflags();	/* 记录中断许可标志的值 */
    c394:	e8 6d f8             	call   bc04 <cli+0x5>
    c397:	ff                   	(bad)
    c398:	ff 89 45 f8          	decw   -0x7bb(%bx,%di)
    cli(); 					/* 将中断许可标志置为0,禁止中断 */
    c39c:	e8 5e f8             	call   bbfd <outb+0x1d>
    c39f:	ff                   	(bad)
    c3a0:	ff 0f                	decw   (%bx)
    // 0x03c8设置写入调色板，0x03c7设置读取调色板
    outb(0x03c8, index);  // 设置当前要设置的调色板 默认使用调色板0
    c3a2:	b6 45                	mov    $0x45,%dh
    c3a4:	ec                   	in     (%dx),%al
    c3a5:	50                   	push   %ax
    c3a6:	68 c8 03             	push   $0x3c8
    c3a9:	00 00                	add    %al,(%bx,%si)
    c3ab:	e8 30 f8             	call   bbde <click_frame+0x8f>
    c3ae:	ff                   	(bad)
    c3af:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    for (int i = 0; i < size; i++) {
    c3b3:	c7 45 fc 00 00       	movw   $0x0,-0x4(%di)
    c3b8:	00 00                	add    %al,(%bx,%si)
    c3ba:	eb 5c                	jmp    c418 <set_palette+0x96>
        // 依次写入rgb
        outb(0x03c9, rgbs[0] / 4);
    c3bc:	8b 45 0c             	mov    0xc(%di),%ax
    c3bf:	0f b6 00             	movzbw (%bx,%si),%ax
    c3c2:	c0 e8 02             	shr    $0x2,%al
    c3c5:	0f b6 c0             	movzbw %al,%ax
    c3c8:	50                   	push   %ax
    c3c9:	68 c9 03             	push   $0x3c9
    c3cc:	00 00                	add    %al,(%bx,%si)
    c3ce:	e8 0d f8             	call   bbde <click_frame+0x8f>
    c3d1:	ff                   	(bad)
    c3d2:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
        outb(0x03c9, rgbs[1] / 4);
    c3d6:	8b 45 0c             	mov    0xc(%di),%ax
    c3d9:	83 c0 01             	add    $0x1,%ax
    c3dc:	0f b6 00             	movzbw (%bx,%si),%ax
    c3df:	c0 e8 02             	shr    $0x2,%al
    c3e2:	0f b6 c0             	movzbw %al,%ax
    c3e5:	50                   	push   %ax
    c3e6:	68 c9 03             	push   $0x3c9
    c3e9:	00 00                	add    %al,(%bx,%si)
    c3eb:	e8 f0 f7             	call   bbde <click_frame+0x8f>
    c3ee:	ff                   	(bad)
    c3ef:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
        outb(0x03c9, rgbs[2] / 4);
    c3f3:	8b 45 0c             	mov    0xc(%di),%ax
    c3f6:	83 c0 02             	add    $0x2,%ax
    c3f9:	0f b6 00             	movzbw (%bx,%si),%ax
    c3fc:	c0 e8 02             	shr    $0x2,%al
    c3ff:	0f b6 c0             	movzbw %al,%ax
    c402:	50                   	push   %ax
    c403:	68 c9 03             	push   $0x3c9
    c406:	00 00                	add    %al,(%bx,%si)
    c408:	e8 d3 f7             	call   bbde <click_frame+0x8f>
    c40b:	ff                   	(bad)
    c40c:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
        rgbs += 3;
    c410:	83 45 0c 03          	addw   $0x3,0xc(%di)
    for (int i = 0; i < size; i++) {
    c414:	83 45 fc 01          	addw   $0x1,-0x4(%di)
    c418:	0f b6 45 e8          	movzbw -0x18(%di),%ax
    c41c:	39 45 fc             	cmp    %ax,-0x4(%di)
    c41f:	7c 9b                	jl     c3bc <set_palette+0x3a>
    }
    write_eflags(eflags);	/* 复原中断许可标志必须使用复原而不是直接打开，可能原来中断就是关闭的 */
    c421:	ff 75 f8             	push   -0x8(%di)
    c424:	e8 ed f7             	call   bc14 <read_eflags+0xe>
    c427:	ff                   	(bad)
    c428:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
}
    c42c:	90                   	nop
    c42d:	c9                   	leave
    c42e:	c3                   	ret

0000c42f <palette_init>:

void palette_init(){
    c42f:	55                   	push   %bp
    c430:	89 e5                	mov    %sp,%bp
            0x0,0x23,0x3f,
            0x23,0xb3,0x67,
            0x1c,0x87,0x53,
            0x6f,0x83,0x98,
    };
    set_palette(0,rgbs, sizeof(rgbs)/3);
    c432:	6a 5a                	push   $0x5a
    c434:	68 20 eb             	push   $0xeb20
    c437:	00 00                	add    %al,(%bx,%si)
    c439:	6a 00                	push   $0x0
    c43b:	e8 42 ff             	call   c380 <draw_str+0x68>
    c43e:	ff                   	(bad)
    c43f:	ff 83 c4 0c          	incw   0xcc4(%bp,%di)
}
    c443:	90                   	nop
    c444:	c9                   	leave
    c445:	c3                   	ret

0000c446 <init_graphic>:

void init_graphic(){
    c446:	55                   	push   %bp
    c447:	89 e5                	mov    %sp,%bp
    c449:	83 ec 18             	sub    $0x18,%sp
    // 加载外部资源
    file_t *file= file_open("fonts.sp",FALSE);
    c44c:	83 ec 08             	sub    $0x8,%sp
    c44f:	6a 00                	push   $0x0
    c451:	68 7a da             	push   $0xda7a
    c454:	00 00                	add    %al,(%bx,%si)
    c456:	e8 7d df             	call   a3d6 <find_empty_sel+0x96>
    c459:	ff                   	(bad)
    c45a:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    c45e:	89 45 f4             	mov    %ax,-0xc(%di)
    fonts= mem_alloc(4096);
    c461:	83 ec 0c             	sub    $0xc,%sp
    c464:	68 00 10             	push   $0x1000
    c467:	00 00                	add    %al,(%bx,%si)
    c469:	e8 76 09             	call   cde2 <mem_total+0x53>
    c46c:	00 00                	add    %al,(%bx,%si)
    c46e:	83 c4 10             	add    $0x10,%sp
    c471:	a3 94 ed             	mov    %ax,0xed94
    c474:	00 00                	add    %al,(%bx,%si)
    file_read(file,4096,fonts);
    c476:	a1 94 ed             	mov    0xed94,%ax
    c479:	00 00                	add    %al,(%bx,%si)
    c47b:	83 ec 04             	sub    $0x4,%sp
    c47e:	50                   	push   %ax
    c47f:	68 00 10             	push   $0x1000
    c482:	00 00                	add    %al,(%bx,%si)
    c484:	ff 75 f4             	push   -0xc(%di)
    c487:	e8 15 e1             	call   a59f <make_sure_buff+0x72>
    c48a:	ff                   	(bad)
    c48b:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    file_close(file);
    c48f:	83 ec 0c             	sub    $0xc,%sp
    c492:	ff 75 f4             	push   -0xc(%di)
    c495:	e8 99 e5             	call   aa31 <file_flush+0x3b>
    c498:	ff                   	(bad)
    c499:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    palette_init();
    c49d:	e8 8d ff             	call   c42d <set_palette+0xab>
    c4a0:	ff                   	(bad)
    c4a1:	ff 90 c9 c3          	call   *-0x3c37(%bx,%si)

0000c4a5 <inb>:
static inline uint8_t inb(uint16_t  port) {
    c4a5:	55                   	push   %bp
    c4a6:	89 e5                	mov    %sp,%bp
    c4a8:	83 ec 14             	sub    $0x14,%sp
    c4ab:	8b 45 08             	mov    0x8(%di),%ax
    c4ae:	66 89 45 ec          	mov    %eax,-0x14(%di)
	__asm__ __volatile__("inb %[p], %[v]" : [v]"=a" (rv) : [p]"d"(port));
    c4b2:	0f b7 45 ec          	movzww -0x14(%di),%ax
    c4b6:	89 c2                	mov    %ax,%dx
    c4b8:	ec                   	in     (%dx),%al
    c4b9:	88 45 ff             	mov    %al,-0x1(%di)
	return rv;
    c4bc:	0f b6 45 ff          	movzbw -0x1(%di),%ax
}
    c4c0:	c9                   	leave
    c4c1:	c3                   	ret

0000c4c2 <outb>:
static inline void outb(uint16_t port, uint8_t data) {
    c4c2:	55                   	push   %bp
    c4c3:	89 e5                	mov    %sp,%bp
    c4c5:	83 ec 08             	sub    $0x8,%sp
    c4c8:	8b 55 08             	mov    0x8(%di),%dx
    c4cb:	8b 45 0c             	mov    0xc(%di),%ax
    c4ce:	66 89 55 fc          	mov    %edx,-0x4(%di)
    c4d2:	88 45 f8             	mov    %al,-0x8(%di)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
    c4d5:	0f b7 55 fc          	movzww -0x4(%di),%dx
    c4d9:	0f b6 45 f8          	movzbw -0x8(%di),%ax
    c4dd:	ee                   	out    %al,(%dx)
}
    c4de:	90                   	nop
    c4df:	c9                   	leave
    c4e0:	c3                   	ret

0000c4e1 <init_pic>:

fifo_t kdb_fifo;
fifo_t mouse_fifo;

/* PIC初始化 */
void init_pic(){
    c4e1:	55                   	push   %bp
    c4e2:	89 e5                	mov    %sp,%bp
    // 设置pic0
    outb(PIC0_ICW1, 0x11  ); /* 边缘触发模式（edge trigger mode） */
    c4e4:	6a 11                	push   $0x11
    c4e6:	6a 20                	push   $0x20
    c4e8:	e8 d5 ff             	call   c4c0 <inb+0x1b>
    c4eb:	ff                   	(bad)
    c4ec:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(PIC0_ICW2, 0x20  ); /* IRQ 0~7由INT 20~27接收 其他中断已被占用*/
    c4f0:	6a 20                	push   $0x20
    c4f2:	6a 21                	push   $0x21
    c4f4:	e8 c9 ff             	call   c4c0 <inb+0x1b>
    c4f7:	ff                   	(bad)
    c4f8:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(PIC0_ICW3, 1 << 2); /* PIC1由IRQ2相连 */
    c4fc:	6a 04                	push   $0x4
    c4fe:	6a 21                	push   $0x21
    c500:	e8 bd ff             	call   c4c0 <inb+0x1b>
    c503:	ff                   	(bad)
    c504:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(PIC0_ICW4, 0x01  ); /* 无缓冲区模式 */
    c508:	6a 01                	push   $0x1
    c50a:	6a 21                	push   $0x21
    c50c:	e8 b1 ff             	call   c4c0 <inb+0x1b>
    c50f:	ff                   	(bad)
    c510:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    // 设置pic1
    outb(PIC1_ICW1, 0x11  ); /* 边缘触发模式（edge trigger mode） */
    c514:	6a 11                	push   $0x11
    c516:	68 a0 00             	push   $0xa0
    c519:	00 00                	add    %al,(%bx,%si)
    c51b:	e8 a2 ff             	call   c4c0 <inb+0x1b>
    c51e:	ff                   	(bad)
    c51f:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(PIC1_ICW2, 0x28  ); /* IRQ 8~15由INT 28~2f接收 */
    c523:	6a 28                	push   $0x28
    c525:	68 a1 00             	push   $0xa1
    c528:	00 00                	add    %al,(%bx,%si)
    c52a:	e8 93 ff             	call   c4c0 <inb+0x1b>
    c52d:	ff                   	(bad)
    c52e:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(PIC1_ICW3, 2     ); /* PIC1由IRQ2连接 */
    c532:	6a 02                	push   $0x2
    c534:	68 a1 00             	push   $0xa1
    c537:	00 00                	add    %al,(%bx,%si)
    c539:	e8 84 ff             	call   c4c0 <inb+0x1b>
    c53c:	ff                   	(bad)
    c53d:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(PIC1_ICW4, 0x01  ); /* 无缓冲区模式 */
    c541:	6a 01                	push   $0x1
    c543:	68 a1 00             	push   $0xa1
    c546:	00 00                	add    %al,(%bx,%si)
    c548:	e8 75 ff             	call   c4c0 <inb+0x1b>
    c54b:	ff                   	(bad)
    c54c:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    // 设置屏蔽那些中断,放开部分中断
    outb(PIC0_IMR, 0xf8); /* PIT和PIC1和键盘设置为许可(11111000) */
    c550:	68 f8 00             	push   $0xf8
    c553:	00 00                	add    %al,(%bx,%si)
    c555:	6a 21                	push   $0x21
    c557:	e8 66 ff             	call   c4c0 <inb+0x1b>
    c55a:	ff                   	(bad)
    c55b:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(PIC1_IMR, 0xef); /* 开放鼠标中断(11101111) */
    c55f:	68 ef 00             	push   $0xef
    c562:	00 00                	add    %al,(%bx,%si)
    c564:	68 a1 00             	push   $0xa1
    c567:	00 00                	add    %al,(%bx,%si)
    c569:	e8 54 ff             	call   c4c0 <inb+0x1b>
    c56c:	ff                   	(bad)
    c56d:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
}
    c571:	90                   	nop
    c572:	c9                   	leave
    c573:	c3                   	ret

0000c574 <handler_kbd>:

/* 来自PS/2键盘的中断 中断号21 */
void handler_kbd(uint32_t *esp){
    c574:	55                   	push   %bp
    c575:	89 e5                	mov    %sp,%bp
    c577:	83 ec 18             	sub    $0x18,%sp
    // 通知处理完毕了
    outb(PIC0_OCW2, PIC_ICW_ECHO);
    c57a:	6a 20                	push   $0x20
    c57c:	6a 20                	push   $0x20
    c57e:	e8 3f ff             	call   c4c0 <inb+0x1b>
    c581:	ff                   	(bad)
    c582:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    if(fifo_can_write(&kdb_fifo)){
    c586:	83 ec 0c             	sub    $0xc,%sp
    c589:	68 98 ed             	push   $0xed98
    c58c:	00 00                	add    %al,(%bx,%si)
    c58e:	e8 30 da             	call   9fc1 <fifo_can_read+0x13>
    c591:	ff                   	(bad)
    c592:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    c596:	85 c0                	test   %ax,%ax
    c598:	74 25                	je     c5bf <handler_kbd+0x4b>
        uint8_t data= inb(PORT_KBD_DAT);
    c59a:	83 ec 0c             	sub    $0xc,%sp
    c59d:	6a 60                	push   $0x60
    c59f:	e8 01 ff             	call   c4a3 <init_graphic+0x5d>
    c5a2:	ff                   	(bad)
    c5a3:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    c5a7:	88 45 f7             	mov    %al,-0x9(%di)
        fifo_write(&kdb_fifo,data);
    c5aa:	0f b6 45 f7          	movzbw -0x9(%di),%ax
    c5ae:	83 ec 08             	sub    $0x8,%sp
    c5b1:	50                   	push   %ax
    c5b2:	68 98 ed             	push   $0xed98
    c5b5:	00 00                	add    %al,(%bx,%si)
    c5b7:	e8 7f da             	call   a039 <fifo_read+0x5a>
    c5ba:	ff                   	(bad)
    c5bb:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    }
}
    c5bf:	90                   	nop
    c5c0:	c9                   	leave
    c5c1:	c3                   	ret

0000c5c2 <handler_pit>:

/* 来自计数器的中断 中断号20 */
void handler_pit(uint32_t *esp){
    c5c2:	55                   	push   %bp
    c5c3:	89 e5                	mov    %sp,%bp
    c5c5:	83 ec 08             	sub    $0x8,%sp
    // 通知处理完毕了
    outb(PIC0_OCW2, PIC_ICW_ECHO);
    c5c8:	6a 20                	push   $0x20
    c5ca:	6a 20                	push   $0x20
    c5cc:	e8 f1 fe             	call   c4c0 <inb+0x1b>
    c5cf:	ff                   	(bad)
    c5d0:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    tick_timer();
    c5d4:	e8 66 0f             	call   d53d <remove_timer+0x20>
    c5d7:	00 00                	add    %al,(%bx,%si)
}
    c5d9:	90                   	nop
    c5da:	c9                   	leave
    c5db:	c3                   	ret

0000c5dc <handler_mouse>:

/* 来自PS/2鼠标的中断,中断号2c */
void handler_mouse(uint32_t *esp){
    c5dc:	55                   	push   %bp
    c5dd:	89 e5                	mov    %sp,%bp
    c5df:	83 ec 18             	sub    $0x18,%sp
    outb(PIC1_OCW2, PIC_ICW_ECHO);	/* 通知PIC IRQ-12 已经受理完毕 */
    c5e2:	6a 20                	push   $0x20
    c5e4:	68 a0 00             	push   $0xa0
    c5e7:	00 00                	add    %al,(%bx,%si)
    c5e9:	e8 d4 fe             	call   c4c0 <inb+0x1b>
    c5ec:	ff                   	(bad)
    c5ed:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(PIC0_OCW2, PIC_ICW_ECHO);	/* 通知PIC IRQ-02 已经受理完毕 */
    c5f1:	6a 20                	push   $0x20
    c5f3:	6a 20                	push   $0x20
    c5f5:	e8 c8 fe             	call   c4c0 <inb+0x1b>
    c5f8:	ff                   	(bad)
    c5f9:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    if(fifo_can_write(&mouse_fifo)){
    c5fd:	83 ec 0c             	sub    $0xc,%sp
    c600:	68 a4 ed             	push   $0xeda4
    c603:	00 00                	add    %al,(%bx,%si)
    c605:	e8 b9 d9             	call   9fc1 <fifo_can_read+0x13>
    c608:	ff                   	(bad)
    c609:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    c60d:	85 c0                	test   %ax,%ax
    c60f:	74 25                	je     c636 <handler_mouse+0x5a>
        uint8_t data = inb(PORT_KBD_DAT);
    c611:	83 ec 0c             	sub    $0xc,%sp
    c614:	6a 60                	push   $0x60
    c616:	e8 8a fe             	call   c4a3 <init_graphic+0x5d>
    c619:	ff                   	(bad)
    c61a:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    c61e:	88 45 f7             	mov    %al,-0x9(%di)
        fifo_write(&mouse_fifo,data);
    c621:	0f b6 45 f7          	movzbw -0x9(%di),%ax
    c625:	83 ec 08             	sub    $0x8,%sp
    c628:	50                   	push   %ax
    c629:	68 a4 ed             	push   $0xeda4
    c62c:	00 00                	add    %al,(%bx,%si)
    c62e:	e8 08 da             	call   a039 <fifo_read+0x5a>
    c631:	ff                   	(bad)
    c632:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    }
}
    c636:	90                   	nop
    c637:	c9                   	leave
    c638:	c3                   	ret

0000c639 <handler_noise>:
/* PIC0中断的不完整策略  中断号27 */
/* 这个中断在Athlon64X2上通过芯片组提供的便利，只需执行一次 */
/* 这个中断只是接收，不执行任何操作 */
/* 为什么不处理？
	→  因为这个中断可能是电气噪声引发的、只是处理一些重要的情况。*/
void handler_noise(uint32_t *esp){
    c639:	55                   	push   %bp
    c63a:	89 e5                	mov    %sp,%bp
    // 直接标记处理完毕
    outb(PIC0_OCW2, PIC_ICW_ECHO);
    c63c:	6a 20                	push   $0x20
    c63e:	6a 20                	push   $0x20
    c640:	e8 7d fe             	call   c4c0 <inb+0x1b>
    c643:	ff                   	(bad)
    c644:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    c648:	90                   	nop
    c649:	c9                   	leave
    c64a:	c3                   	ret

0000c64b <inb>:
static inline uint8_t inb(uint16_t  port) {
    c64b:	66 55                	push   %ebp
    c64d:	66 89 e5             	mov    %esp,%ebp
    c650:	66 83 ec 14          	sub    $0x14,%esp
    c654:	67 66 8b 45 08       	mov    0x8(%ebp),%eax
    c659:	67 89 45 ec          	mov    %ax,-0x14(%ebp)
	__asm__ __volatile__("inb %[p], %[v]" : [v]"=a" (rv) : [p]"d"(port));
    c65d:	67 66 0f b7 45 ec    	movzwl -0x14(%ebp),%eax
    c663:	66 89 c2             	mov    %eax,%edx
    c666:	ec                   	in     (%dx),%al
    c667:	67 88 45 ff          	mov    %al,-0x1(%ebp)
	return rv;
    c66b:	67 66 0f b6 45 ff    	movzbl -0x1(%ebp),%eax
}
    c671:	66 c9                	leavel
    c673:	66 c3                	retl

0000c675 <outb>:
static inline void outb(uint16_t port, uint8_t data) {
    c675:	66 55                	push   %ebp
    c677:	66 89 e5             	mov    %esp,%ebp
    c67a:	66 83 ec 08          	sub    $0x8,%esp
    c67e:	67 66 8b 55 08       	mov    0x8(%ebp),%edx
    c683:	67 66 8b 45 0c       	mov    0xc(%ebp),%eax
    c688:	67 89 55 fc          	mov    %dx,-0x4(%ebp)
    c68c:	67 88 45 f8          	mov    %al,-0x8(%ebp)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
    c690:	67 66 0f b7 55 fc    	movzwl -0x4(%ebp),%edx
    c696:	67 66 0f b6 45 f8    	movzbl -0x8(%ebp),%eax
    c69c:	ee                   	out    %al,(%dx)
}
    c69d:	90                   	nop
    c69e:	66 c9                	leavel
    c6a0:	66 c3                	retl

0000c6a2 <cli>:
static inline void cli() {
    c6a2:	66 55                	push   %ebp
    c6a4:	66 89 e5             	mov    %esp,%ebp
	__asm__ __volatile__("cli");
    c6a7:	fa                   	cli
}
    c6a8:	90                   	nop
    c6a9:	66 5d                	pop    %ebp
    c6ab:	66 c3                	retl

0000c6ad <lgdt>:
static inline void lgdt(uint32_t start, uint32_t size) {
    c6ad:	66 55                	push   %ebp
    c6af:	66 89 e5             	mov    %esp,%ebp
    c6b2:	66 83 ec 10          	sub    $0x10,%esp
	gdt.start31_16 = start >> 16;
    c6b6:	67 66 8b 45 08       	mov    0x8(%ebp),%eax
    c6bb:	66 c1 e8 10          	shr    $0x10,%eax
    c6bf:	67 89 45 fe          	mov    %ax,-0x2(%ebp)
	gdt.start15_0 = start & 0xFFFF;
    c6c3:	67 66 8b 45 08       	mov    0x8(%ebp),%eax
    c6c8:	67 89 45 fc          	mov    %ax,-0x4(%ebp)
	gdt.limit = size - 1;
    c6cc:	67 66 8b 45 0c       	mov    0xc(%ebp),%eax
    c6d1:	66 83 e8 01          	sub    $0x1,%eax
    c6d5:	67 89 45 fa          	mov    %ax,-0x6(%ebp)
	__asm__ __volatile__("lgdt %[g]"::[g]"m"(gdt));
    c6d9:	67 0f 01 55 fa       	lgdtw  -0x6(%ebp)
}
    c6de:	90                   	nop
    c6df:	66 c9                	leavel
    c6e1:	66 c3                	retl

0000c6e3 <read_cr0>:
static inline uint32_t read_cr0() {
    c6e3:	66 55                	push   %ebp
    c6e5:	66 89 e5             	mov    %esp,%ebp
    c6e8:	66 83 ec 10          	sub    $0x10,%esp
	__asm__ __volatile__("mov %%cr0, %[v]":[v]"=r"(cr0));
    c6ec:	0f 20 c0             	mov    %cr0,%eax
    c6ef:	67 66 89 45 fc       	mov    %eax,-0x4(%ebp)
	return cr0;
    c6f4:	67 66 8b 45 fc       	mov    -0x4(%ebp),%eax
}
    c6f9:	66 c9                	leavel
    c6fb:	66 c3                	retl

0000c6fd <write_cr0>:
static inline void write_cr0(uint32_t v) {
    c6fd:	66 55                	push   %ebp
    c6ff:	66 89 e5             	mov    %esp,%ebp
	__asm__ __volatile__("mov %[v], %%cr0"::[v]"r"(v));
    c702:	67 66 8b 45 08       	mov    0x8(%ebp),%eax
    c707:	0f 22 c0             	mov    %eax,%cr0
}
    c70a:	90                   	nop
    c70b:	66 5d                	pop    %ebp
    c70d:	66 c3                	retl

0000c70f <far_jump>:
static inline void far_jump(uint32_t selector, uint32_t offset) {
    c70f:	66 55                	push   %ebp
    c711:	66 89 e5             	mov    %esp,%ebp
    c714:	66 83 ec 10          	sub    $0x10,%esp
	uint32_t addr[] = {offset, selector };
    c718:	67 66 8b 45 0c       	mov    0xc(%ebp),%eax
    c71d:	67 66 89 45 f8       	mov    %eax,-0x8(%ebp)
    c722:	67 66 8b 45 08       	mov    0x8(%ebp),%eax
    c727:	67 66 89 45 fc       	mov    %eax,-0x4(%ebp)
	__asm__ __volatile__("ljmpl *(%[a])"::[a]"r"(addr));
    c72c:	67 66 8d 45 f8       	lea    -0x8(%ebp),%eax
    c731:	67 66 ff 28          	ljmpl  *(%eax)
}
    c735:	90                   	nop
    c736:	66 c9                	leavel
    c738:	66 c3                	retl

0000c73a <enter_protect_mode>:
};

/**
 * 进入保护模式
 */
static void  enter_protect_mode() {
    c73a:	66 55                	push   %ebp
    c73c:	66 89 e5             	mov    %esp,%ebp
    c73f:	66 83 ec 10          	sub    $0x10,%esp
    // 关中断
    cli();
    c743:	66 e8 59 ff ff ff    	calll  c6a2 <cli>

    // 开启A20地址线，使得可访问1M以上空间
    // 使用的是Fast A20 Gate方式，见https://wiki.osdev.org/A20#Fast_A20_Gate
    uint8_t v = inb(0x92);
    c749:	66 68 92 00 00 00    	pushl  $0x92
    c74f:	66 e8 f6 fe ff ff    	calll  c64b <inb>
    c755:	66 83 c4 04          	add    $0x4,%esp
    c759:	67 88 45 ff          	mov    %al,-0x1(%ebp)
    outb(0x92, v | 0x2);
    c75d:	67 66 0f b6 45 ff    	movzbl -0x1(%ebp),%eax
    c763:	66 83 c8 02          	or     $0x2,%eax
    c767:	66 0f b6 c0          	movzbl %al,%eax
    c76b:	66 50                	push   %eax
    c76d:	66 68 92 00 00 00    	pushl  $0x92
    c773:	66 e8 fc fe ff ff    	calll  c675 <outb>
    c779:	66 83 c4 08          	add    $0x8,%esp

    // 加载GDT。由于中断已经关掉，IDT不需要加载
    lgdt((uint32_t)gdt_table, sizeof(gdt_table));
    c77d:	66 b8 30 ec 00 00    	mov    $0xec30,%eax
    c783:	66 6a 18             	pushl  $0x18
    c786:	66 50                	push   %eax
    c788:	66 e8 1f ff ff ff    	calll  c6ad <lgdt>
    c78e:	66 83 c4 08          	add    $0x8,%esp

    // 打开CR0的保护模式位，进入保持模式
    uint32_t cr0 = read_cr0();
    c792:	66 e8 4b ff ff ff    	calll  c6e3 <read_cr0>
    c798:	67 66 89 45 f8       	mov    %eax,-0x8(%ebp)
    write_cr0(cr0 | (1 << 0));
    c79d:	67 66 8b 45 f8       	mov    -0x8(%ebp),%eax
    c7a2:	66 83 c8 01          	or     $0x1,%eax
    c7a6:	66 50                	push   %eax
    c7a8:	66 e8 4f ff ff ff    	calll  c6fd <write_cr0>
    c7ae:	66 83 c4 04          	add    $0x4,%esp

    // 长跳转进入到保护模式
    // 使用长跳转，以便清空流水线，将里面的16位代码给清空
    far_jump(8, (uint32_t)protect_mode_main);
    c7b2:	66 b8 09 80 00 00    	mov    $0x8009,%eax
    c7b8:	66 50                	push   %eax
    c7ba:	66 6a 08             	pushl  $0x8
    c7bd:	66 e8 4c ff ff ff    	calll  c70f <far_jump>
    c7c3:	66 83 c4 08          	add    $0x8,%esp
}
    c7c7:	90                   	nop
    c7c8:	66 c9                	leavel
    c7ca:	66 c3                	retl

0000c7cc <detect_memory>:

// 参考：https://wiki.osdev.org/Memory_Map_(x86)
// 1MB以下比较标准, 在1M以上会有差别
// 检测：https://wiki.osdev.org/Detecting_Memory_(x86)#BIOS_Function:_INT_0x15.2C_AH_.3D_0xC7
static void  detect_memory() {
    c7cc:	66 55                	push   %ebp
    c7ce:	66 89 e5             	mov    %esp,%ebp
    c7d1:	66 57                	push   %edi
    c7d3:	66 56                	push   %esi
    c7d5:	66 53                	push   %ebx
    c7d7:	66 83 ec 30          	sub    $0x30,%esp
    uint32_t contID = 0;
    c7db:	67 66 c7 45 f0 00 00 	movl   $0x0,-0x10(%ebp)
    c7e2:	00 00 
    int signature, bytes;

    // 初次：EDX=0x534D4150,EAX=0xE820,ECX=24,INT 0x15, EBX=0（初次）
    // 后续：EAX=0xE820,ECX=24,
    // 结束判断：EBX=0
    ram_info.ram_count = 0;
    c7e4:	c6 06 10 ee 00       	movb   $0x0,-0x11f0
    for (int i = 0; i < RAM_COUNT; i++) {
    c7e9:	67 66 c7 45 ec 00 00 	movl   $0x0,-0x14(%ebp)
    c7f0:	00 00 
    c7f2:	e9 cc 00             	jmp    c8c1 <detect_memory+0xf5>
        smap_t * smap = &temp;
    c7f5:	67 66 8d 45 c8       	lea    -0x38(%ebp),%eax
    c7fa:	67 66 89 45 e8       	mov    %eax,-0x18(%ebp)

        __asm__ __volatile__("int  $0x15"
    c7ff:	66 b8 20 e8 00 00    	mov    $0xe820,%eax
    c805:	67 66 8b 5d f0       	mov    -0x10(%ebp),%ebx
    c80a:	66 b9 18 00 00 00    	mov    $0x18,%ecx
    c810:	66 ba 50 41 4d 53    	mov    $0x534d4150,%edx
    c816:	67 66 8b 75 e8       	mov    -0x18(%ebp),%esi
    c81b:	66 89 f7             	mov    %esi,%edi
    c81e:	cd 15                	int    $0x15
    c820:	66 89 da             	mov    %ebx,%edx
    c823:	67 66 89 45 e4       	mov    %eax,-0x1c(%ebp)
    c828:	67 66 89 4d e0       	mov    %ecx,-0x20(%ebp)
    c82d:	67 66 89 55 f0       	mov    %edx,-0x10(%ebp)
                : "=a"(signature), "=c"(bytes), "=b"(contID)
                : "a"(0xE820), "b"(contID), "c"(24), "d"(0x534D4150), "D"(smap));
        if (signature != 0x534D4150) {
    c832:	67 66 81 7d e4 50 41 	cmpl   $0x534d4150,-0x1c(%ebp)
    c839:	4d 53 
    c83b:	0f 85 8e 00          	jne    c8cd <detect_memory+0x101>
            return;
        }

        // todo: 20字节
        if (bytes > 20 && (smap->acpi & 0x0001) == 0){
    c83f:	67 66 83 7d e0 14    	cmpl   $0x14,-0x20(%ebp)
    c845:	7e 13                	jle    c85a <detect_memory+0x8e>
    c847:	67 66 8b 45 e8       	mov    -0x18(%ebp),%eax
    c84c:	67 66 8b 40 14       	mov    0x14(%eax),%eax
    c851:	66 83 e0 01          	and    $0x1,%eax
    c855:	66 85 c0             	test   %eax,%eax
    c858:	74 60                	je     c8ba <detect_memory+0xee>
            continue;
        }

        // 保存RAM信息，只取32位，空间有限无需考虑更大容量的情况
        if (smap->type == 1) {
    c85a:	67 66 8b 45 e8       	mov    -0x18(%ebp),%eax
    c85f:	67 66 8b 40 10       	mov    0x10(%eax),%eax
    c864:	66 83 f8 01          	cmp    $0x1,%eax
    c868:	75 46                	jne    c8b0 <detect_memory+0xe4>
            ram_info.rams[ram_info.ram_count].start = smap->baseL;
    c86a:	66 0f b6 06 10 ee    	movzbl -0x11f0,%eax
    c870:	66 0f b6 c0          	movzbl %al,%eax
    c874:	67 66 8b 55 e8       	mov    -0x18(%ebp),%edx
    c879:	67 66 8b 12          	mov    (%edx),%edx
    c87d:	67 66 89 14 c5 c0 ed 	mov    %edx,0xedc0(,%eax,8)
    c884:	00 00 
            ram_info.rams[ram_info.ram_count].size = smap->lengthL;
    c886:	66 0f b6 06 10 ee    	movzbl -0x11f0,%eax
    c88c:	66 0f b6 c0          	movzbl %al,%eax
    c890:	67 66 8b 55 e8       	mov    -0x18(%ebp),%edx
    c895:	67 66 8b 52 08       	mov    0x8(%edx),%edx
    c89a:	67 66 89 14 c5 c4 ed 	mov    %edx,0xedc4(,%eax,8)
    c8a1:	00 00 
            ram_info.ram_count++;
    c8a3:	66 0f b6 06 10 ee    	movzbl -0x11f0,%eax
    c8a9:	66 83 c0 01          	add    $0x1,%eax
    c8ad:	a2 10 ee             	mov    %al,0xee10
        }

        if (contID == 0) {
    c8b0:	67 66 83 7d f0 00    	cmpl   $0x0,-0x10(%ebp)
    c8b6:	74 18                	je     c8d0 <detect_memory+0x104>
    c8b8:	eb 01                	jmp    c8bb <detect_memory+0xef>
            continue;
    c8ba:	90                   	nop
    for (int i = 0; i < RAM_COUNT; i++) {
    c8bb:	67 66 83 45 ec 01    	addl   $0x1,-0x14(%ebp)
    c8c1:	67 66 83 7d ec 09    	cmpl   $0x9,-0x14(%ebp)
    c8c7:	0f 8e 2a ff          	jle    c7f5 <detect_memory+0x29>
    c8cb:	eb 04                	jmp    c8d1 <detect_memory+0x105>
            return;
    c8cd:	90                   	nop
    c8ce:	eb 01                	jmp    c8d1 <detect_memory+0x105>
            break;
    c8d0:	90                   	nop
        }
    }
}
    c8d1:	66 83 c4 30          	add    $0x30,%esp
    c8d5:	66 5b                	pop    %ebx
    c8d7:	66 5e                	pop    %esi
    c8d9:	66 5f                	pop    %edi
    c8db:	66 5d                	pop    %ebp
    c8dd:	66 c3                	retl

0000c8df <kernel_main16>:

// 16位main
void kernel_main16() {
    c8df:	66 55                	push   %ebp
    c8e1:	66 89 e5             	mov    %esp,%ebp
    detect_memory();
    c8e4:	66 e8 e2 fe ff ff    	calll  c7cc <detect_memory>
    enter_protect_mode();
    c8ea:	66 e8 4a fe ff ff    	calll  c73a <enter_protect_mode>
}
    c8f0:	90                   	nop
    c8f1:	66 5d                	pop    %ebp
    c8f3:	66 c3                	retl

0000c8f5 <cli>:
static inline void cli() {
    c8f5:	55                   	push   %bp
    c8f6:	89 e5                	mov    %sp,%bp
	__asm__ __volatile__("cli");
    c8f8:	fa                   	cli
}
    c8f9:	90                   	nop
    c8fa:	5d                   	pop    %bp
    c8fb:	c3                   	ret

0000c8fc <sti>:
static inline void sti() {
    c8fc:	55                   	push   %bp
    c8fd:	89 e5                	mov    %sp,%bp
	__asm__ __volatile__("sti");
    c8ff:	fb                   	sti
}
    c900:	90                   	nop
    c901:	5d                   	pop    %bp
    c902:	c3                   	ret

0000c903 <hlt>:
static inline void hlt() {
    c903:	55                   	push   %bp
    c904:	89 e5                	mov    %sp,%bp
    __asm__ __volatile__("hlt");
    c906:	f4                   	hlt
}
    c907:	90                   	nop
    c908:	5d                   	pop    %bp
    c909:	c3                   	ret

0000c90a <test_task>:
#include "frame.h"
#include "task.h"
#include "file.h"
#include "app/console.h"

void test_task() {
    c90a:	55                   	push   %bp
    c90b:	89 e5                	mov    %sp,%bp
    c90d:	83 ec 28             	sub    $0x28,%sp
    uint32_t count = 0;
    c910:	c7 45 f4 00 00       	movw   $0x0,-0xc(%di)
    c915:	00 00                	add    %al,(%bx,%si)
    while (TRUE) {
        count++;
    c917:	83 45 f4 01          	addw   $0x1,-0xc(%di)
        char buff[16];
        mem_set(buff, 0, 16);
    c91b:	83 ec 04             	sub    $0x4,%sp
    c91e:	6a 10                	push   $0x10
    c920:	6a 00                	push   $0x0
    c922:	8d 45 e4             	lea    -0x1c(%di),%ax
    c925:	50                   	push   %ax
    c926:	e8 9d 0e             	call   d7c6 <fmt+0x140>
    c929:	00 00                	add    %al,(%bx,%si)
    c92b:	83 c4 10             	add    $0x10,%sp
        fmt(buff, "TEST %d", count);
    c92e:	83 ec 04             	sub    $0x4,%sp
    c931:	ff 75 f4             	push   -0xc(%di)
    c934:	68 83 da             	push   $0xda83
    c937:	00 00                	add    %al,(%bx,%si)
    c939:	8d 45 e4             	lea    -0x1c(%di),%ax
    c93c:	50                   	push   %ax
    c93d:	e8 44 0d             	call   d684 <append+0x37>
    c940:	00 00                	add    %al,(%bx,%si)
    c942:	83 c4 10             	add    $0x10,%sp
        fill_rect(window_frame->vram, window_frame->w, 0, 16, 16 * 8, 16, COL_000000);
    c945:	a1 e8 ec             	mov    0xece8,%ax
    c948:	00 00                	add    %al,(%bx,%si)
    c94a:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    c94e:	0f b7 d0             	movzww %ax,%dx
    c951:	a1 e8 ec             	mov    0xece8,%ax
    c954:	00 00                	add    %al,(%bx,%si)
    c956:	8b 00                	mov    (%bx,%si),%ax
    c958:	83 ec 04             	sub    $0x4,%sp
    c95b:	6a 00                	push   $0x0
    c95d:	6a 10                	push   $0x10
    c95f:	68 80 00             	push   $0x80
    c962:	00 00                	add    %al,(%bx,%si)
    c964:	6a 10                	push   $0x10
    c966:	6a 00                	push   $0x0
    c968:	52                   	push   %dx
    c969:	50                   	push   %ax
    c96a:	e8 e5 f6             	call   c052 <fill_alpha+0x34>
    c96d:	ff                   	(bad)
    c96e:	ff 83 c4 20          	incw   0x20c4(%bp,%di)
        draw_str(window_frame->vram, window_frame->w, 0, 16, buff, COL_FFFFFF);
    c972:	a1 e8 ec             	mov    0xece8,%ax
    c975:	00 00                	add    %al,(%bx,%si)
    c977:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    c97b:	0f b7 d0             	movzww %ax,%dx
    c97e:	a1 e8 ec             	mov    0xece8,%ax
    c981:	00 00                	add    %al,(%bx,%si)
    c983:	8b 00                	mov    (%bx,%si),%ax
    c985:	83 ec 08             	sub    $0x8,%sp
    c988:	6a 07                	push   $0x7
    c98a:	8d 4d e4             	lea    -0x1c(%di),%cx
    c98d:	51                   	push   %cx
    c98e:	6a 10                	push   $0x10
    c990:	6a 00                	push   $0x0
    c992:	52                   	push   %dx
    c993:	50                   	push   %ax
    c994:	e8 7f f9             	call   c316 <draw_char+0xb1>
    c997:	ff                   	(bad)
    c998:	ff 83 c4 20          	incw   0x20c4(%bp,%di)
        frame_refresh_sub(window_frame->x, window_frame->y + 16, 16 * 8, 16);
    c99c:	a1 e8 ec             	mov    0xece8,%ax
    c99f:	00 00                	add    %al,(%bx,%si)
    c9a1:	8b 40 08             	mov    0x8(%bx,%si),%ax
    c9a4:	8d 50 10             	lea    0x10(%bx,%si),%dx
    c9a7:	a1 e8 ec             	mov    0xece8,%ax
    c9aa:	00 00                	add    %al,(%bx,%si)
    c9ac:	8b 40 04             	mov    0x4(%bx,%si),%ax
    c9af:	6a 10                	push   $0x10
    c9b1:	68 80 00             	push   $0x80
    c9b4:	00 00                	add    %al,(%bx,%si)
    c9b6:	52                   	push   %dx
    c9b7:	50                   	push   %ax
    c9b8:	e8 45 f0             	call   ba00 <draw_frame_sub+0xbb>
    c9bb:	ff                   	(bad)
    c9bc:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
        task_switch();
    c9c0:	e8 97 07             	call   d15a <idle_task+0xce>
    c9c3:	00 00                	add    %al,(%bx,%si)
    while (TRUE) {
    c9c5:	e9 4d ff             	jmp    c915 <test_task+0xb>
    c9c8:	ff                   	(bad)
    c9c9:	ff                   	.byte 0xff

0000c9ca <kernel_main32>:
static int offsetY;

/**
 * 32位main
 */
void kernel_main32() {
    c9ca:	55                   	push   %bp
    c9cb:	89 e5                	mov    %sp,%bp
    c9cd:	53                   	push   %bx
    c9ce:	83 ec 14             	sub    $0x14,%sp
    init_mem();
    c9d1:	e8 3c 03             	call   cd10 <kernel_main32+0x346>
    c9d4:	00 00                	add    %al,(%bx,%si)
    init_file();
    c9d6:	e8 f0 d8             	call   a2c9 <disk_write+0x72>
    c9d9:	ff                   	(bad)
    c9da:	ff                   	(bad)
    init_gdt_idt();
    c9db:	e8 d8 cf             	call   99b6 <lidt+0x26>
    c9de:	ff                   	(bad)
    c9df:	ff                   	(bad)
    init_pic();
    c9e0:	e8 fc fa             	call   c4df <outb+0x1d>
    c9e3:	ff                   	(bad)
    c9e4:	ff                   	(bad)
    init_task();
    c9e5:	e8 80 09             	call   d368 <create_task+0x11e>
    c9e8:	00 00                	add    %al,(%bx,%si)
    sti(); //打开中断
    c9ea:	e8 0d ff             	call   c8fa <cli+0x5>
    c9ed:	ff                   	(bad)
    c9ee:	ff 83 ec 08          	incw   0x8ec(%bp,%di)
    fifo_init(&kdb_fifo, 128);
    c9f2:	68 80 00             	push   $0x80
    c9f5:	00 00                	add    %al,(%bx,%si)
    c9f7:	68 98 ed             	push   $0xed98
    c9fa:	00 00                	add    %al,(%bx,%si)
    c9fc:	e8 33 d5             	call   9f32 <beep+0xa4>
    c9ff:	ff                   	(bad)
    ca00:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    fifo_init(&mouse_fifo, 128);
    ca04:	83 ec 08             	sub    $0x8,%sp
    ca07:	68 80 00             	push   $0x80
    ca0a:	00 00                	add    %al,(%bx,%si)
    ca0c:	68 a4 ed             	push   $0xeda4
    ca0f:	00 00                	add    %al,(%bx,%si)
    ca11:	e8 1e d5             	call   9f32 <beep+0xa4>
    ca14:	ff                   	(bad)
    ca15:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    fifo_init(&timer_fifo, 128);
    ca19:	83 ec 08             	sub    $0x8,%sp
    ca1c:	68 80 00             	push   $0x80
    ca1f:	00 00                	add    %al,(%bx,%si)
    ca21:	68 30 1e             	push   $0x1e30
    ca24:	01 00                	add    %ax,(%bx,%si)
    ca26:	e8 09 d5             	call   9f32 <beep+0xa4>
    ca29:	ff                   	(bad)
    ca2a:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    init_kbd();
    ca2e:	e8 6d d2             	call   9c9e <wait_kbd_ready+0x1b>
    ca31:	ff                   	(bad)
    ca32:	ff                   	(bad)
    init_mouse();
    ca33:	e8 90 d2             	call   9cc6 <init_kbd+0x26>
    ca36:	ff                   	(bad)
    ca37:	ff                   	(bad)
    init_pit();
    ca38:	e8 24 d4             	call   9e5f <mouse_decode+0x14e>
    ca3b:	ff                   	(bad)
    ca3c:	ff                   	(bad)
    init_timer();
    ca3d:	e8 e5 09             	call   d425 <init_task+0xbb>
    ca40:	00 00                	add    %al,(%bx,%si)

    init_graphic();
    ca42:	e8 ff f9             	call   c444 <palette_init+0x15>
    ca45:	ff                   	(bad)
    ca46:	ff                   	(bad)
    init_frame();
    ca47:	e8 d7 e9             	call   b421 <draw_textbox+0x273>
    ca4a:	ff                   	(bad)
    ca4b:	ff                   	(bad)

//    uint32_t count =0;
    while (TRUE) {
        // task_sleep(timer+300);
        cli();
    ca4c:	e8 a4 fe             	call   c8f3 <kernel_main16+0x14>
    ca4f:	ff                   	(bad)
    ca50:	ff 83 ec 0c          	incw   0xcec(%bp,%di)
        if (fifo_can_read(&mouse_fifo)) {
    ca54:	68 a4 ed             	push   $0xeda4
    ca57:	00 00                	add    %al,(%bx,%si)
    ca59:	e8 50 d5             	call   9fac <fifo_free+0x2a>
    ca5c:	ff                   	(bad)
    ca5d:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    ca61:	85 c0                	test   %ax,%ax
    ca63:	0f 84 1a 02          	je     cc81 <kernel_main32+0x2b7>
    ca67:	00 00                	add    %al,(%bx,%si)
            uint8_t data = fifo_read(&mouse_fifo);
    ca69:	83 ec 0c             	sub    $0xc,%sp
    ca6c:	68 a4 ed             	push   $0xeda4
    ca6f:	00 00                	add    %al,(%bx,%si)
    ca71:	e8 69 d5             	call   9fdd <fifo_can_write+0x1a>
    ca74:	ff                   	(bad)
    ca75:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    ca79:	88 45 f6             	mov    %al,-0xa(%di)
            sti();
    ca7c:	e8 7b fe             	call   c8fa <cli+0x5>
    ca7f:	ff                   	(bad)
    ca80:	ff 0f                	decw   (%bx)
            if (mouse_decode(data)) {
    ca82:	b6 45                	mov    $0x45,%dh
    ca84:	f6 83 ec 0c 50       	testb  $0x50,0xcec(%bp,%di)
    ca89:	e8 83 d2             	call   9d0f <init_mouse+0x47>
    ca8c:	ff                   	(bad)
    ca8d:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    ca91:	85 c0                	test   %ax,%ax
    ca93:	74 b7                	je     ca4c <kernel_main32+0x82>
                frame_move(cursor_frame, mouse.x, mouse.y);
    ca95:	8b 0d                	mov    (%di),%cx
    ca97:	c8 ec 00 00          	enter  $0xec,$0x0
    ca9b:	8b 15                	mov    (%di),%dx
    ca9d:	c4                   	(bad)
    ca9e:	ec                   	in     (%dx),%al
    ca9f:	00 00                	add    %al,(%bx,%si)
    caa1:	a1 e4 ec             	mov    0xece4,%ax
    caa4:	00 00                	add    %al,(%bx,%si)
    caa6:	83 ec 04             	sub    $0x4,%sp
    caa9:	51                   	push   %cx
    caaa:	52                   	push   %dx
    caab:	50                   	push   %ax
    caac:	e8 fb ec             	call   b7aa <frame_sort+0xab>
    caaf:	ff                   	(bad)
    cab0:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
                // 没有数据时才尝试移动窗口，减少无谓的移动
                if(move_frame&&!fifo_can_read(&mouse_fifo)){
    cab4:	a1 b4 ed             	mov    0xedb4,%ax
    cab7:	00 00                	add    %al,(%bx,%si)
    cab9:	85 c0                	test   %ax,%ax
    cabb:	74 42                	je     caff <kernel_main32+0x135>
    cabd:	83 ec 0c             	sub    $0xc,%sp
    cac0:	68 a4 ed             	push   $0xeda4
    cac3:	00 00                	add    %al,(%bx,%si)
    cac5:	e8 e4 d4             	call   9fac <fifo_free+0x2a>
    cac8:	ff                   	(bad)
    cac9:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    cacd:	85 c0                	test   %ax,%ax
    cacf:	75 2e                	jne    caff <kernel_main32+0x135>
                    frame_move(move_frame,mouse.x+offsetX,mouse.y+offsetY);
    cad1:	8b 15                	mov    (%di),%dx
    cad3:	c8 ec 00 00          	enter  $0xec,$0x0
    cad7:	a1 bc ed             	mov    0xedbc,%ax
    cada:	00 00                	add    %al,(%bx,%si)
    cadc:	8d 0c                	lea    (%si),%cx
    cade:	02 8b 15 c4          	add    -0x3beb(%bp,%di),%cl
    cae2:	ec                   	in     (%dx),%al
    cae3:	00 00                	add    %al,(%bx,%si)
    cae5:	a1 b8 ed             	mov    0xedb8,%ax
    cae8:	00 00                	add    %al,(%bx,%si)
    caea:	01 c2                	add    %ax,%dx
    caec:	a1 b4 ed             	mov    0xedb4,%ax
    caef:	00 00                	add    %al,(%bx,%si)
    caf1:	83 ec 04             	sub    $0x4,%sp
    caf4:	51                   	push   %cx
    caf5:	52                   	push   %dx
    caf6:	50                   	push   %ax
    caf7:	e8 b0 ec             	call   b7aa <frame_sort+0xab>
    cafa:	ff                   	(bad)
    cafb:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
                }
                if (mouse.btn & MOUSE_BTN_L) {
    caff:	0f b6 05             	movzbw (%di),%ax
    cb02:	b8 ec 00             	mov    $0xec,%ax
    cb05:	00 0f                	add    %cl,(%bx)
    cb07:	b6 c0                	mov    $0xc0,%dh
    cb09:	83 e0 01             	and    $0x1,%ax
    cb0c:	85 c0                	test   %ax,%ax
    cb0e:	0f 84 38 ff          	je     ca4a <kernel_main32+0x80>
    cb12:	ff                   	(bad)
    cb13:	ff 8b 15 c8          	decw   -0x37eb(%bp,%di)
                    frame_t *frame=click_frame(mouse.x,mouse.y);
    cb17:	ec                   	in     (%dx),%al
    cb18:	00 00                	add    %al,(%bx,%si)
    cb1a:	a1 c4 ec             	mov    0xecc4,%ax
    cb1d:	00 00                	add    %al,(%bx,%si)
    cb1f:	83 ec 08             	sub    $0x8,%sp
    cb22:	52                   	push   %dx
    cb23:	50                   	push   %ax
    cb24:	e8 26 f0             	call   bb4d <frame_refresh_sub+0x14b>
    cb27:	ff                   	(bad)
    cb28:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    cb2c:	89 45 f0             	mov    %ax,-0x10(%di)
                    if(!frame){// 取消所有窗口
    cb2f:	83 7d f0 00          	cmpw   $0x0,-0x10(%di)
    cb33:	75 5a                	jne    cb8f <kernel_main32+0x1c5>
                        active_frame=0;
    cb35:	c7 05 b0 ed          	movw   $0xedb0,(%di)
    cb39:	00 00                	add    %al,(%bx,%si)
    cb3b:	00 00                	add    %al,(%bx,%si)
    cb3d:	00 00                	add    %al,(%bx,%si)
                        move_frame=0;
    cb3f:	c7 05 b4 ed          	movw   $0xedb4,(%di)
    cb43:	00 00                	add    %al,(%bx,%si)
    cb45:	00 00                	add    %al,(%bx,%si)
    cb47:	00 00                	add    %al,(%bx,%si)
                        // 点击到开始按钮创建命令行窗口
                        if(mouse.x>=2&&mouse.x<=60&&mouse.y>=SCREEN_H-24&&mouse.y<=SCREEN_H-4){
    cb49:	a1 c4 ec             	mov    0xecc4,%ax
    cb4c:	00 00                	add    %al,(%bx,%si)
    cb4e:	83 f8 01             	cmp    $0x1,%ax
    cb51:	0f 8e af 01          	jle    cd04 <kernel_main32+0x33a>
    cb55:	00 00                	add    %al,(%bx,%si)
    cb57:	a1 c4 ec             	mov    0xecc4,%ax
    cb5a:	00 00                	add    %al,(%bx,%si)
    cb5c:	83 f8 3c             	cmp    $0x3c,%ax
    cb5f:	0f 8f a1 01          	jg     cd04 <kernel_main32+0x33a>
    cb63:	00 00                	add    %al,(%bx,%si)
    cb65:	a1 c8 ec             	mov    0xecc8,%ax
    cb68:	00 00                	add    %al,(%bx,%si)
    cb6a:	3d af 00             	cmp    $0xaf,%ax
    cb6d:	00 00                	add    %al,(%bx,%si)
    cb6f:	0f 8e 91 01          	jle    cd04 <kernel_main32+0x33a>
    cb73:	00 00                	add    %al,(%bx,%si)
    cb75:	a1 c8 ec             	mov    0xecc8,%ax
    cb78:	00 00                	add    %al,(%bx,%si)
    cb7a:	3d c4 00             	cmp    $0xc4,%ax
    cb7d:	00 00                	add    %al,(%bx,%si)
    cb7f:	0f 8f 81 01          	jg     cd04 <kernel_main32+0x33a>
    cb83:	00 00                	add    %al,(%bx,%si)
                            init_console();
    cb85:	e8 ea c4             	call   9072 <console_click+0x32>
    cb88:	ff                   	(bad)
    cb89:	ff                   	(bad)
                        }
                        continue;
    cb8a:	e9 77 01             	jmp    cd04 <kernel_main32+0x33a>
    cb8d:	00 00                	add    %al,(%bx,%si)
                    }
                    if(frame!=active_frame){// 激活窗口
    cb8f:	a1 b0 ed             	mov    0xedb0,%ax
    cb92:	00 00                	add    %al,(%bx,%si)
    cb94:	39 45 f0             	cmp    %ax,-0x10(%di)
    cb97:	74 52                	je     cbeb <kernel_main32+0x221>
                        active_frame=frame;
    cb99:	8b 45 f0             	mov    -0x10(%di),%ax
    cb9c:	a3 b0 ed             	mov    %ax,0xedb0
    cb9f:	00 00                	add    %al,(%bx,%si)
                        frame_top(active_frame);
    cba1:	a1 b0 ed             	mov    0xedb0,%ax
    cba4:	00 00                	add    %al,(%bx,%si)
    cba6:	83 ec 0c             	sub    $0xc,%sp
    cba9:	50                   	push   %ax
    cbaa:	e8 2a eb             	call   b6d7 <frame_alloc+0xe0>
    cbad:	ff                   	(bad)
    cbae:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
                        frame_refresh_sub(active_frame->x,active_frame->y,active_frame->w,active_frame->h);
    cbb2:	a1 b0 ed             	mov    0xedb0,%ax
    cbb5:	00 00                	add    %al,(%bx,%si)
    cbb7:	0f b7 40 0e          	movzww 0xe(%bx,%si),%ax
    cbbb:	0f b7 d8             	movzww %ax,%bx
    cbbe:	a1 b0 ed             	mov    0xedb0,%ax
    cbc1:	00 00                	add    %al,(%bx,%si)
    cbc3:	0f b7 40 0c          	movzww 0xc(%bx,%si),%ax
    cbc7:	0f b7 c8             	movzww %ax,%cx
    cbca:	a1 b0 ed             	mov    0xedb0,%ax
    cbcd:	00 00                	add    %al,(%bx,%si)
    cbcf:	8b 50 08             	mov    0x8(%bx,%si),%dx
    cbd2:	a1 b0 ed             	mov    0xedb0,%ax
    cbd5:	00 00                	add    %al,(%bx,%si)
    cbd7:	8b 40 04             	mov    0x4(%bx,%si),%ax
    cbda:	53                   	push   %bx
    cbdb:	51                   	push   %cx
    cbdc:	52                   	push   %dx
    cbdd:	50                   	push   %ax
    cbde:	e8 1f ee             	call   ba00 <draw_frame_sub+0xbb>
    cbe1:	ff                   	(bad)
    cbe2:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
                        continue;
    cbe6:	e9 22 01             	jmp    cd0b <kernel_main32+0x341>
    cbe9:	00 00                	add    %al,(%bx,%si)
                    }
                    if(frame->click&&frame->click(mouse.x,mouse.y)){// 事件被内部处理了
    cbeb:	8b 45 f0             	mov    -0x10(%di),%ax
    cbee:	8b 40 18             	mov    0x18(%bx,%si),%ax
    cbf1:	85 c0                	test   %ax,%ax
    cbf3:	74 3f                	je     cc34 <kernel_main32+0x26a>
    cbf5:	8b 45 f0             	mov    -0x10(%di),%ax
    cbf8:	8b 40 18             	mov    0x18(%bx,%si),%ax
    cbfb:	8b 0d                	mov    (%di),%cx
    cbfd:	c8 ec 00 00          	enter  $0xec,$0x0
    cc01:	8b 15                	mov    (%di),%dx
    cc03:	c4                   	(bad)
    cc04:	ec                   	in     (%dx),%al
    cc05:	00 00                	add    %al,(%bx,%si)
    cc07:	83 ec 08             	sub    $0x8,%sp
    cc0a:	51                   	push   %cx
    cc0b:	52                   	push   %dx
    cc0c:	ff d0                	call   *%ax
    cc0e:	83 c4 10             	add    $0x10,%sp
    cc11:	85 c0                	test   %ax,%ax
    cc13:	74 1f                	je     cc34 <kernel_main32+0x26a>
                        if(!active_frame->used){// 可能触发的是关闭事件
    cc15:	a1 b0 ed             	mov    0xedb0,%ax
    cc18:	00 00                	add    %al,(%bx,%si)
    cc1a:	8b 40 14             	mov    0x14(%bx,%si),%ax
    cc1d:	85 c0                	test   %ax,%ax
    cc1f:	0f 85 e7 00          	jne    cd0a <kernel_main32+0x340>
    cc23:	00 00                	add    %al,(%bx,%si)
                            active_frame=0;
    cc25:	c7 05 b0 ed          	movw   $0xedb0,(%di)
    cc29:	00 00                	add    %al,(%bx,%si)
    cc2b:	00 00                	add    %al,(%bx,%si)
    cc2d:	00 00                	add    %al,(%bx,%si)
                        }
                        continue;
    cc2f:	e9 d8 00             	jmp    cd0a <kernel_main32+0x340>
    cc32:	00 00                	add    %al,(%bx,%si)
                    }
                    if(move_frame){// 移动状态切换
    cc34:	a1 b4 ed             	mov    0xedb4,%ax
    cc37:	00 00                	add    %al,(%bx,%si)
    cc39:	85 c0                	test   %ax,%ax
    cc3b:	74 0f                	je     cc4c <kernel_main32+0x282>
                        move_frame=0;
    cc3d:	c7 05 b4 ed          	movw   $0xedb4,(%di)
    cc41:	00 00                	add    %al,(%bx,%si)
    cc43:	00 00                	add    %al,(%bx,%si)
    cc45:	00 00                	add    %al,(%bx,%si)
    cc47:	e9 00 fe             	jmp    ca4a <kernel_main32+0x80>
    cc4a:	ff                   	(bad)
    cc4b:	ff 8b 45 f0          	decw   -0xfbb(%bp,%di)
                    } else{
                        move_frame= frame;
    cc4f:	a3 b4 ed             	mov    %ax,0xedb4
    cc52:	00 00                	add    %al,(%bx,%si)
                        offsetX=move_frame->x-mouse.x;
    cc54:	a1 b4 ed             	mov    0xedb4,%ax
    cc57:	00 00                	add    %al,(%bx,%si)
    cc59:	8b 50 04             	mov    0x4(%bx,%si),%dx
    cc5c:	a1 c4 ec             	mov    0xecc4,%ax
    cc5f:	00 00                	add    %al,(%bx,%si)
    cc61:	29 c2                	sub    %ax,%dx
    cc63:	89 15                	mov    %dx,(%di)
    cc65:	b8 ed 00             	mov    $0xed,%ax
    cc68:	00 a1 b4 ed          	add    %ah,-0x124c(%bx,%di)
                        offsetY=move_frame->y-mouse.y;
    cc6c:	00 00                	add    %al,(%bx,%si)
    cc6e:	8b 50 08             	mov    0x8(%bx,%si),%dx
    cc71:	a1 c8 ec             	mov    0xecc8,%ax
    cc74:	00 00                	add    %al,(%bx,%si)
    cc76:	29 c2                	sub    %ax,%dx
    cc78:	89 15                	mov    %dx,(%di)
    cc7a:	bc ed 00             	mov    $0xed,%sp
    cc7d:	00 e9                	add    %ch,%cl
    cc7f:	c9                   	leave
    cc80:	fd                   	std
    cc81:	ff                   	(bad)
    cc82:	ff 83 ec 0c          	incw   0xcec(%bp,%di)
                    }
                }
            }
        } else if(fifo_can_read(&kdb_fifo)){
    cc86:	68 98 ed             	push   $0xed98
    cc89:	00 00                	add    %al,(%bx,%si)
    cc8b:	e8 1e d3             	call   9fac <fifo_free+0x2a>
    cc8e:	ff                   	(bad)
    cc8f:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    cc93:	85 c0                	test   %ax,%ax
    cc95:	74 60                	je     ccf7 <kernel_main32+0x32d>
            // 还有直接分发，否则丢失按钮事件
            uint8_t data= fifo_read(&kdb_fifo);
    cc97:	83 ec 0c             	sub    $0xc,%sp
    cc9a:	68 98 ed             	push   $0xed98
    cc9d:	00 00                	add    %al,(%bx,%si)
    cc9f:	e8 3b d3             	call   9fdd <fifo_can_write+0x1a>
    cca2:	ff                   	(bad)
    cca3:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    cca7:	88 45 f7             	mov    %al,-0x9(%di)
            sti();
    ccaa:	e8 4d fc             	call   c8fa <cli+0x5>
    ccad:	ff                   	(bad)
    ccae:	ff a1 b0 ed          	jmp    *-0x1250(%bx,%di)
            if(active_frame&& fifo_can_write(&active_frame->kdb_fifo)){
    ccb2:	00 00                	add    %al,(%bx,%si)
    ccb4:	85 c0                	test   %ax,%ax
    ccb6:	0f 84 90 fd          	je     ca4a <kernel_main32+0x80>
    ccba:	ff                   	(bad)
    ccbb:	ff a1 b0 ed          	jmp    *-0x1250(%bx,%di)
    ccbf:	00 00                	add    %al,(%bx,%si)
    ccc1:	83 c0 1c             	add    $0x1c,%ax
    ccc4:	83 ec 0c             	sub    $0xc,%sp
    ccc7:	50                   	push   %ax
    ccc8:	e8 f6 d2             	call   9fc1 <fifo_can_read+0x13>
    cccb:	ff                   	(bad)
    cccc:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    ccd0:	85 c0                	test   %ax,%ax
    ccd2:	0f 84 74 fd          	je     ca4a <kernel_main32+0x80>
    ccd6:	ff                   	(bad)
    ccd7:	ff 0f                	decw   (%bx)
                fifo_write(&active_frame->kdb_fifo,data);
    ccd9:	b6 45                	mov    $0x45,%dh
    ccdb:	f7 8b 15 b0 ed 00    	testw  $0xed,-0x4feb(%bp,%di)
    cce1:	00 83 c2 1c          	add    %al,0x1cc2(%bp,%di)
    cce5:	83 ec 08             	sub    $0x8,%sp
    cce8:	50                   	push   %ax
    cce9:	52                   	push   %dx
    ccea:	e8 4c d3             	call   a039 <fifo_read+0x5a>
    cced:	ff                   	(bad)
    ccee:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    ccf2:	e9 55 fd             	jmp    ca4a <kernel_main32+0x80>
    ccf5:	ff                   	(bad)
    ccf6:	ff                   	(bad)
            }
        } else {
            sti();
    ccf7:	e8 00 fc             	call   c8fa <cli+0x5>
    ccfa:	ff                   	(bad)
    ccfb:	ff                   	(bad)
            hlt();
    ccfc:	e8 02 fc             	call   c901 <sti+0x5>
    ccff:	ff                   	(bad)
    cd00:	ff                   	(bad)
    cd01:	e9 46 fd             	jmp    ca4a <kernel_main32+0x80>
    cd04:	ff                   	(bad)
    cd05:	ff 90 e9 40          	call   *0x40e9(%bx,%si)
                        continue;
    cd09:	fd                   	std
    cd0a:	ff                   	(bad)
    cd0b:	ff 90 e9 3a          	call   *0x3ae9(%bx,%si)
        cli();
    cd0f:	fd                   	std
    cd10:	ff                   	(bad)
    cd11:	ff                   	.byte 0xff

0000cd12 <init_mem>:
#include "tool.h"

ram_info_t ram_info;			// 启动参数信息 因为必须在16位模式下获取内存大小，初始化在 kernel_16.c 中完成
static mem_t mems[MEM_SIZE];

void init_mem(){
    cd12:	55                   	push   %bp
    cd13:	89 e5                	mov    %sp,%bp
    cd15:	83 ec 18             	sub    $0x18,%sp
    mem_set(mems,0, sizeof(mems));
    cd18:	83 ec 04             	sub    $0x4,%sp
    cd1b:	68 00 30             	push   $0x3000
    cd1e:	00 00                	add    %al,(%bx,%si)
    cd20:	6a 00                	push   $0x0
    cd22:	68 20 ee             	push   $0xee20
    cd25:	00 00                	add    %al,(%bx,%si)
    cd27:	e8 9c 0a             	call   d7c6 <fmt+0x140>
    cd2a:	00 00                	add    %al,(%bx,%si)
    cd2c:	83 c4 10             	add    $0x10,%sp
    // 忽略第一块可用内存，那个已经被当前代码占用了
    for (int i = 1; i < ram_info.ram_count; ++i) {
    cd2f:	c7 45 f4 01 00       	movw   $0x1,-0xc(%di)
    cd34:	00 00                	add    %al,(%bx,%si)
    cd36:	eb 44                	jmp    cd7c <init_mem+0x6a>
        mem_t *mem=mems+i-1;
    cd38:	8b 55 f4             	mov    -0xc(%di),%dx
    cd3b:	89 d0                	mov    %dx,%ax
    cd3d:	01 c0                	add    %ax,%ax
    cd3f:	01 d0                	add    %dx,%ax
    cd41:	c1 e0 02             	shl    $0x2,%ax
    cd44:	83 e8 0c             	sub    $0xc,%ax
    cd47:	05 20 ee             	add    $0xee20,%ax
    cd4a:	00 00                	add    %al,(%bx,%si)
    cd4c:	89 45 f0             	mov    %ax,-0x10(%di)
        mem->used=TRUE;
    cd4f:	8b 45 f0             	mov    -0x10(%di),%ax
    cd52:	c7 40 08 01 00       	movw   $0x1,0x8(%bx,%si)
    cd57:	00 00                	add    %al,(%bx,%si)
        mem->start=ram_info.rams[i].start;
    cd59:	8b 45 f4             	mov    -0xc(%di),%ax
    cd5c:	8b 14                	mov    (%si),%dx
    cd5e:	c5 c0 ed             	(bad)
    cd61:	00 00                	add    %al,(%bx,%si)
    cd63:	8b 45 f0             	mov    -0x10(%di),%ax
    cd66:	89 10                	mov    %dx,(%bx,%si)
        mem->size= ram_info.rams[i].size;
    cd68:	8b 45 f4             	mov    -0xc(%di),%ax
    cd6b:	8b 14                	mov    (%si),%dx
    cd6d:	c5 c4 ed             	(bad)
    cd70:	00 00                	add    %al,(%bx,%si)
    cd72:	8b 45 f0             	mov    -0x10(%di),%ax
    cd75:	89 50 04             	mov    %dx,0x4(%bx,%si)
    for (int i = 1; i < ram_info.ram_count; ++i) {
    cd78:	83 45 f4 01          	addw   $0x1,-0xc(%di)
    cd7c:	0f b6 05             	movzbw (%di),%ax
    cd7f:	10 ee                	adc    %ch,%dh
    cd81:	00 00                	add    %al,(%bx,%si)
    cd83:	0f b6 c0             	movzbw %al,%ax
    cd86:	39 45 f4             	cmp    %ax,-0xc(%di)
    cd89:	7c ad                	jl     cd38 <init_mem+0x26>
    }
}
    cd8b:	90                   	nop
    cd8c:	90                   	nop
    cd8d:	c9                   	leave
    cd8e:	c3                   	ret

0000cd8f <mem_total>:

uint32_t mem_total(){
    cd8f:	55                   	push   %bp
    cd90:	89 e5                	mov    %sp,%bp
    cd92:	83 ec 10             	sub    $0x10,%sp
    uint32_t sum=0;
    cd95:	c7 45 fc 00 00       	movw   $0x0,-0x4(%di)
    cd9a:	00 00                	add    %al,(%bx,%si)
    for (int i = 0; i < MEM_SIZE; ++i) {
    cd9c:	c7 45 f8 00 00       	movw   $0x0,-0x8(%di)
    cda1:	00 00                	add    %al,(%bx,%si)
    cda3:	eb 31                	jmp    cdd6 <mem_total+0x47>
        if(mems[i].used){
    cda5:	8b 55 f8             	mov    -0x8(%di),%dx
    cda8:	89 d0                	mov    %dx,%ax
    cdaa:	01 c0                	add    %ax,%ax
    cdac:	01 d0                	add    %dx,%ax
    cdae:	c1 e0 02             	shl    $0x2,%ax
    cdb1:	05 28 ee             	add    $0xee28,%ax
    cdb4:	00 00                	add    %al,(%bx,%si)
    cdb6:	8b 00                	mov    (%bx,%si),%ax
    cdb8:	85 c0                	test   %ax,%ax
    cdba:	74 16                	je     cdd2 <mem_total+0x43>
            sum+=mems[i].size;
    cdbc:	8b 55 f8             	mov    -0x8(%di),%dx
    cdbf:	89 d0                	mov    %dx,%ax
    cdc1:	01 c0                	add    %ax,%ax
    cdc3:	01 d0                	add    %dx,%ax
    cdc5:	c1 e0 02             	shl    $0x2,%ax
    cdc8:	05 24 ee             	add    $0xee24,%ax
    cdcb:	00 00                	add    %al,(%bx,%si)
    cdcd:	8b 00                	mov    (%bx,%si),%ax
    cdcf:	01 45 fc             	add    %ax,-0x4(%di)
    for (int i = 0; i < MEM_SIZE; ++i) {
    cdd2:	83 45 f8 01          	addw   $0x1,-0x8(%di)
    cdd6:	81 7d f8 ff 03       	cmpw   $0x3ff,-0x8(%di)
    cddb:	00 00                	add    %al,(%bx,%si)
    cddd:	7e c6                	jle    cda5 <mem_total+0x16>
        }
    }
    return sum;
    cddf:	8b 45 fc             	mov    -0x4(%di),%ax
}
    cde2:	c9                   	leave
    cde3:	c3                   	ret

0000cde4 <mem_alloc>:

void *mem_alloc(uint32_t size){
    cde4:	55                   	push   %bp
    cde5:	89 e5                	mov    %sp,%bp
    cde7:	83 ec 18             	sub    $0x18,%sp
    for (int i = 0; i < MEM_SIZE; ++i) {
    cdea:	c7 45 f4 00 00       	movw   $0x0,-0xc(%di)
    cdef:	00 00                	add    %al,(%bx,%si)
    cdf1:	e9 d7 00             	jmp    cecb <mem_alloc+0xe7>
    cdf4:	00 00                	add    %al,(%bx,%si)
        if(mems[i].used&&mems[i].size>size){
    cdf6:	8b 55 f4             	mov    -0xc(%di),%dx
    cdf9:	89 d0                	mov    %dx,%ax
    cdfb:	01 c0                	add    %ax,%ax
    cdfd:	01 d0                	add    %dx,%ax
    cdff:	c1 e0 02             	shl    $0x2,%ax
    ce02:	05 28 ee             	add    $0xee28,%ax
    ce05:	00 00                	add    %al,(%bx,%si)
    ce07:	8b 00                	mov    (%bx,%si),%ax
    ce09:	85 c0                	test   %ax,%ax
    ce0b:	0f 84 b8 00          	je     cec7 <mem_alloc+0xe3>
    ce0f:	00 00                	add    %al,(%bx,%si)
    ce11:	8b 55 f4             	mov    -0xc(%di),%dx
    ce14:	89 d0                	mov    %dx,%ax
    ce16:	01 c0                	add    %ax,%ax
    ce18:	01 d0                	add    %dx,%ax
    ce1a:	c1 e0 02             	shl    $0x2,%ax
    ce1d:	05 24 ee             	add    $0xee24,%ax
    ce20:	00 00                	add    %al,(%bx,%si)
    ce22:	8b 00                	mov    (%bx,%si),%ax
    ce24:	39 45 08             	cmp    %ax,0x8(%di)
    ce27:	0f 83 9c 00          	jae    cec7 <mem_alloc+0xe3>
    ce2b:	00 00                	add    %al,(%bx,%si)
            mems[i].size-=size;// 从后面移除分配的并返回分配地址
    ce2d:	8b 55 f4             	mov    -0xc(%di),%dx
    ce30:	89 d0                	mov    %dx,%ax
    ce32:	01 c0                	add    %ax,%ax
    ce34:	01 d0                	add    %dx,%ax
    ce36:	c1 e0 02             	shl    $0x2,%ax
    ce39:	05 24 ee             	add    $0xee24,%ax
    ce3c:	00 00                	add    %al,(%bx,%si)
    ce3e:	8b 00                	mov    (%bx,%si),%ax
    ce40:	2b 45 08             	sub    0x8(%di),%ax
    ce43:	89 c1                	mov    %ax,%cx
    ce45:	8b 55 f4             	mov    -0xc(%di),%dx
    ce48:	89 d0                	mov    %dx,%ax
    ce4a:	01 c0                	add    %ax,%ax
    ce4c:	01 d0                	add    %dx,%ax
    ce4e:	c1 e0 02             	shl    $0x2,%ax
    ce51:	05 24 ee             	add    $0xee24,%ax
    ce54:	00 00                	add    %al,(%bx,%si)
    ce56:	89 08                	mov    %cx,(%bx,%si)
            if(mems[i].size==0){ // 正好分配完啦
    ce58:	8b 55 f4             	mov    -0xc(%di),%dx
    ce5b:	89 d0                	mov    %dx,%ax
    ce5d:	01 c0                	add    %ax,%ax
    ce5f:	01 d0                	add    %dx,%ax
    ce61:	c1 e0 02             	shl    $0x2,%ax
    ce64:	05 24 ee             	add    $0xee24,%ax
    ce67:	00 00                	add    %al,(%bx,%si)
    ce69:	8b 00                	mov    (%bx,%si),%ax
    ce6b:	85 c0                	test   %ax,%ax
    ce6d:	75 17                	jne    ce86 <mem_alloc+0xa2>
                mems[i].used=FALSE;
    ce6f:	8b 55 f4             	mov    -0xc(%di),%dx
    ce72:	89 d0                	mov    %dx,%ax
    ce74:	01 c0                	add    %ax,%ax
    ce76:	01 d0                	add    %dx,%ax
    ce78:	c1 e0 02             	shl    $0x2,%ax
    ce7b:	05 28 ee             	add    $0xee28,%ax
    ce7e:	00 00                	add    %al,(%bx,%si)
    ce80:	c7 00 00 00          	movw   $0x0,(%bx,%si)
    ce84:	00 00                	add    %al,(%bx,%si)
            }
            // 默认进行初始化
            void *ptr=(void *)(mems[i].start+mems[i].size);
    ce86:	8b 55 f4             	mov    -0xc(%di),%dx
    ce89:	89 d0                	mov    %dx,%ax
    ce8b:	01 c0                	add    %ax,%ax
    ce8d:	01 d0                	add    %dx,%ax
    ce8f:	c1 e0 02             	shl    $0x2,%ax
    ce92:	05 20 ee             	add    $0xee20,%ax
    ce95:	00 00                	add    %al,(%bx,%si)
    ce97:	8b 08                	mov    (%bx,%si),%cx
    ce99:	8b 55 f4             	mov    -0xc(%di),%dx
    ce9c:	89 d0                	mov    %dx,%ax
    ce9e:	01 c0                	add    %ax,%ax
    cea0:	01 d0                	add    %dx,%ax
    cea2:	c1 e0 02             	shl    $0x2,%ax
    cea5:	05 24 ee             	add    $0xee24,%ax
    cea8:	00 00                	add    %al,(%bx,%si)
    ceaa:	8b 00                	mov    (%bx,%si),%ax
    ceac:	01 c8                	add    %cx,%ax
    ceae:	89 45 f0             	mov    %ax,-0x10(%di)
            mem_set(ptr,0,size);
    ceb1:	83 ec 04             	sub    $0x4,%sp
    ceb4:	ff 75 08             	push   0x8(%di)
    ceb7:	6a 00                	push   $0x0
    ceb9:	ff 75 f0             	push   -0x10(%di)
    cebc:	e8 07 09             	call   d7c6 <fmt+0x140>
    cebf:	00 00                	add    %al,(%bx,%si)
    cec1:	83 c4 10             	add    $0x10,%sp
            return ptr;
    cec4:	8b 45 f0             	mov    -0x10(%di),%ax
    cec7:	eb 16                	jmp    cedf <mem_alloc+0xfb>
    for (int i = 0; i < MEM_SIZE; ++i) {
    cec9:	83 45 f4 01          	addw   $0x1,-0xc(%di)
    cecd:	81 7d f4 ff 03       	cmpw   $0x3ff,-0xc(%di)
    ced2:	00 00                	add    %al,(%bx,%si)
    ced4:	0f 8e 1c ff          	jle    cdf4 <mem_alloc+0x10>
    ced8:	ff                   	(bad)
    ced9:	ff                   	(bad)
        }
    }
    return 0;// 没有内存了，不太可能出现
    ceda:	b8 00 00             	mov    $0x0,%ax
    cedd:	00 00                	add    %al,(%bx,%si)
}
    cedf:	c9                   	leave
    cee0:	c3                   	ret

0000cee1 <mem_free>:

void mem_free(void *ptr,uint32_t size){
    cee1:	55                   	push   %bp
    cee2:	89 e5                	mov    %sp,%bp
    cee4:	83 ec 20             	sub    $0x20,%sp
    mem_t *mem=0; // 先找到一块空的用于记录
    cee7:	c7 45 fc 00 00       	movw   $0x0,-0x4(%di)
    ceec:	00 00                	add    %al,(%bx,%si)
    for (int i = 0; i < MEM_SIZE; ++i) {
    ceee:	c7 45 f8 00 00       	movw   $0x0,-0x8(%di)
    cef3:	00 00                	add    %al,(%bx,%si)
    cef5:	eb 4c                	jmp    cf43 <mem_free+0x62>
        if(!mems[i].used){
    cef7:	8b 55 f8             	mov    -0x8(%di),%dx
    cefa:	89 d0                	mov    %dx,%ax
    cefc:	01 c0                	add    %ax,%ax
    cefe:	01 d0                	add    %dx,%ax
    cf00:	c1 e0 02             	shl    $0x2,%ax
    cf03:	05 28 ee             	add    $0xee28,%ax
    cf06:	00 00                	add    %al,(%bx,%si)
    cf08:	8b 00                	mov    (%bx,%si),%ax
    cf0a:	85 c0                	test   %ax,%ax
    cf0c:	75 31                	jne    cf3f <mem_free+0x5e>
            mem=&mems[i];
    cf0e:	8b 55 f8             	mov    -0x8(%di),%dx
    cf11:	89 d0                	mov    %dx,%ax
    cf13:	01 c0                	add    %ax,%ax
    cf15:	01 d0                	add    %dx,%ax
    cf17:	c1 e0 02             	shl    $0x2,%ax
    cf1a:	05 20 ee             	add    $0xee20,%ax
    cf1d:	00 00                	add    %al,(%bx,%si)
    cf1f:	89 45 fc             	mov    %ax,-0x4(%di)
            mem->used=TRUE;
    cf22:	8b 45 fc             	mov    -0x4(%di),%ax
    cf25:	c7 40 08 01 00       	movw   $0x1,0x8(%bx,%si)
    cf2a:	00 00                	add    %al,(%bx,%si)
            mem->start=(uint32_t)ptr;
    cf2c:	8b 55 08             	mov    0x8(%di),%dx
    cf2f:	8b 45 fc             	mov    -0x4(%di),%ax
    cf32:	89 10                	mov    %dx,(%bx,%si)
            mem->size=size;
    cf34:	8b 45 fc             	mov    -0x4(%di),%ax
    cf37:	8b 55 0c             	mov    0xc(%di),%dx
    cf3a:	89 50 04             	mov    %dx,0x4(%bx,%si)
            break;
    cf3d:	eb 0d                	jmp    cf4c <mem_free+0x6b>
    for (int i = 0; i < MEM_SIZE; ++i) {
    cf3f:	83 45 f8 01          	addw   $0x1,-0x8(%di)
    cf43:	81 7d f8 ff 03       	cmpw   $0x3ff,-0x8(%di)
    cf48:	00 00                	add    %al,(%bx,%si)
    cf4a:	7e ab                	jle    cef7 <mem_free+0x16>
        }
    }
    if(mem==0){// 没有表项可以使用了，直接丢弃内存
    cf4c:	83 7d fc 00          	cmpw   $0x0,-0x4(%di)
    cf50:	0f 84 06 01          	je     d05a <mem_free+0x179>
    cf54:	00 00                	add    %al,(%bx,%si)
        return;
    }

    // 试图合并前后相连的内存
    for (int i = 0; i < MEM_SIZE; ++i) {
    cf56:	c7 45 f4 00 00       	movw   $0x0,-0xc(%di)
    cf5b:	00 00                	add    %al,(%bx,%si)
    cf5d:	e9 eb 00             	jmp    d04b <mem_free+0x16a>
    cf60:	00 00                	add    %al,(%bx,%si)
        if(!mems[i].used){
    cf62:	8b 55 f4             	mov    -0xc(%di),%dx
    cf65:	89 d0                	mov    %dx,%ax
    cf67:	01 c0                	add    %ax,%ax
    cf69:	01 d0                	add    %dx,%ax
    cf6b:	c1 e0 02             	shl    $0x2,%ax
    cf6e:	05 28 ee             	add    $0xee28,%ax
    cf71:	00 00                	add    %al,(%bx,%si)
    cf73:	8b 00                	mov    (%bx,%si),%ax
    cf75:	85 c0                	test   %ax,%ax
    cf77:	0f 84 cb 00          	je     d046 <mem_free+0x165>
    cf7b:	00 00                	add    %al,(%bx,%si)
            continue;
        }
        uint32_t start=mems[i].start;
    cf7d:	8b 55 f4             	mov    -0xc(%di),%dx
    cf80:	89 d0                	mov    %dx,%ax
    cf82:	01 c0                	add    %ax,%ax
    cf84:	01 d0                	add    %dx,%ax
    cf86:	c1 e0 02             	shl    $0x2,%ax
    cf89:	05 20 ee             	add    $0xee20,%ax
    cf8c:	00 00                	add    %al,(%bx,%si)
    cf8e:	8b 00                	mov    (%bx,%si),%ax
    cf90:	89 45 f0             	mov    %ax,-0x10(%di)
        uint32_t end=start+ mems[i].size;
    cf93:	8b 55 f4             	mov    -0xc(%di),%dx
    cf96:	89 d0                	mov    %dx,%ax
    cf98:	01 c0                	add    %ax,%ax
    cf9a:	01 d0                	add    %dx,%ax
    cf9c:	c1 e0 02             	shl    $0x2,%ax
    cf9f:	05 24 ee             	add    $0xee24,%ax
    cfa2:	00 00                	add    %al,(%bx,%si)
    cfa4:	8b 10                	mov    (%bx,%si),%dx
    cfa6:	8b 45 f0             	mov    -0x10(%di),%ax
    cfa9:	01 d0                	add    %dx,%ax
    cfab:	89 45 ec             	mov    %ax,-0x14(%di)
        if(end==mem->start){
    cfae:	8b 45 fc             	mov    -0x4(%di),%ax
    cfb1:	8b 00                	mov    (%bx,%si),%ax
    cfb3:	39 45 ec             	cmp    %ax,-0x14(%di)
    cfb6:	75 43                	jne    cffb <mem_free+0x11a>
            mem->start=start;
    cfb8:	8b 45 fc             	mov    -0x4(%di),%ax
    cfbb:	8b 55 f0             	mov    -0x10(%di),%dx
    cfbe:	89 10                	mov    %dx,(%bx,%si)
            mem->size+=mems[i].size;
    cfc0:	8b 45 fc             	mov    -0x4(%di),%ax
    cfc3:	8b 48 04             	mov    0x4(%bx,%si),%cx
    cfc6:	8b 55 f4             	mov    -0xc(%di),%dx
    cfc9:	89 d0                	mov    %dx,%ax
    cfcb:	01 c0                	add    %ax,%ax
    cfcd:	01 d0                	add    %dx,%ax
    cfcf:	c1 e0 02             	shl    $0x2,%ax
    cfd2:	05 24 ee             	add    $0xee24,%ax
    cfd5:	00 00                	add    %al,(%bx,%si)
    cfd7:	8b 00                	mov    (%bx,%si),%ax
    cfd9:	8d 14                	lea    (%si),%dx
    cfdb:	01 8b 45 fc          	add    %cx,-0x3bb(%bp,%di)
    cfdf:	89 50 04             	mov    %dx,0x4(%bx,%si)
            mems[i].used=FALSE;
    cfe2:	8b 55 f4             	mov    -0xc(%di),%dx
    cfe5:	89 d0                	mov    %dx,%ax
    cfe7:	01 c0                	add    %ax,%ax
    cfe9:	01 d0                	add    %dx,%ax
    cfeb:	c1 e0 02             	shl    $0x2,%ax
    cfee:	05 28 ee             	add    $0xee28,%ax
    cff1:	00 00                	add    %al,(%bx,%si)
    cff3:	c7 00 00 00          	movw   $0x0,(%bx,%si)
    cff7:	00 00                	add    %al,(%bx,%si)
    cff9:	eb 4e                	jmp    d049 <mem_free+0x168>
        } else if(start==mem->start+mem->size){
    cffb:	8b 45 fc             	mov    -0x4(%di),%ax
    cffe:	8b 10                	mov    (%bx,%si),%dx
    d000:	8b 45 fc             	mov    -0x4(%di),%ax
    d003:	8b 40 04             	mov    0x4(%bx,%si),%ax
    d006:	01 d0                	add    %dx,%ax
    d008:	39 45 f0             	cmp    %ax,-0x10(%di)
    d00b:	75 3c                	jne    d049 <mem_free+0x168>
            mem->size+=mems[i].size;
    d00d:	8b 45 fc             	mov    -0x4(%di),%ax
    d010:	8b 48 04             	mov    0x4(%bx,%si),%cx
    d013:	8b 55 f4             	mov    -0xc(%di),%dx
    d016:	89 d0                	mov    %dx,%ax
    d018:	01 c0                	add    %ax,%ax
    d01a:	01 d0                	add    %dx,%ax
    d01c:	c1 e0 02             	shl    $0x2,%ax
    d01f:	05 24 ee             	add    $0xee24,%ax
    d022:	00 00                	add    %al,(%bx,%si)
    d024:	8b 00                	mov    (%bx,%si),%ax
    d026:	8d 14                	lea    (%si),%dx
    d028:	01 8b 45 fc          	add    %cx,-0x3bb(%bp,%di)
    d02c:	89 50 04             	mov    %dx,0x4(%bx,%si)
            mems[i].used=FALSE;
    d02f:	8b 55 f4             	mov    -0xc(%di),%dx
    d032:	89 d0                	mov    %dx,%ax
    d034:	01 c0                	add    %ax,%ax
    d036:	01 d0                	add    %dx,%ax
    d038:	c1 e0 02             	shl    $0x2,%ax
    d03b:	05 28 ee             	add    $0xee28,%ax
    d03e:	00 00                	add    %al,(%bx,%si)
    d040:	c7 00 00 00          	movw   $0x0,(%bx,%si)
    d044:	00 00                	add    %al,(%bx,%si)
    d046:	eb 01                	jmp    d049 <mem_free+0x168>
            continue;
    d048:	90                   	nop
    for (int i = 0; i < MEM_SIZE; ++i) {
    d049:	83 45 f4 01          	addw   $0x1,-0xc(%di)
    d04d:	81 7d f4 ff 03       	cmpw   $0x3ff,-0xc(%di)
    d052:	00 00                	add    %al,(%bx,%si)
    d054:	0f 8e 08 ff          	jle    cf60 <mem_free+0x7f>
    d058:	ff                   	(bad)
    d059:	ff                   	(bad)
    d05a:	eb 01                	jmp    d05d <mem_free+0x17c>
        return;
    d05c:	90                   	nop
        }
    }
}
    d05d:	c9                   	leave
    d05e:	c3                   	ret

0000d05f <far_jump>:
static inline void far_jump(uint32_t selector, uint32_t offset) {
    d05f:	55                   	push   %bp
    d060:	89 e5                	mov    %sp,%bp
    d062:	83 ec 10             	sub    $0x10,%sp
	uint32_t addr[] = {offset, selector };
    d065:	8b 45 0c             	mov    0xc(%di),%ax
    d068:	89 45 f8             	mov    %ax,-0x8(%di)
    d06b:	8b 45 08             	mov    0x8(%di),%ax
    d06e:	89 45 fc             	mov    %ax,-0x4(%di)
	__asm__ __volatile__("ljmpl *(%[a])"::[a]"r"(addr));
    d071:	8d 45 f8             	lea    -0x8(%di),%ax
    d074:	ff 28                	ljmp   *(%bx,%si)
}
    d076:	90                   	nop
    d077:	c9                   	leave
    d078:	c3                   	ret

0000d079 <hlt>:
static inline void hlt() {
    d079:	55                   	push   %bp
    d07a:	89 e5                	mov    %sp,%bp
    __asm__ __volatile__("hlt");
    d07c:	f4                   	hlt
}
    d07d:	90                   	nop
    d07e:	5d                   	pop    %bp
    d07f:	c3                   	ret

0000d080 <write_tr>:
static inline void write_tr (uint32_t tss_selector) {
    d080:	55                   	push   %bp
    d081:	89 e5                	mov    %sp,%bp
    __asm__ __volatile__("ltr %%ax"::"a"(tss_selector));
    d083:	8b 45 08             	mov    0x8(%di),%ax
    d086:	0f 00 d8             	ltr    %ax
}
    d089:	90                   	nop
    d08a:	5d                   	pop    %bp
    d08b:	c3                   	ret

0000d08c <idle_task>:
static uint16_t tss_index;
static task_t *curr_task;
static bool_t task_die;

// 永远不会进行休眠的进程，用于为其他进程提供基础服务，例如定时任务
void idle_task(){
    d08c:	55                   	push   %bp
    d08d:	89 e5                	mov    %sp,%bp
    d08f:	83 ec 18             	sub    $0x18,%sp
    while (TRUE){
        // 只有这一个地方使用 无需关中断
        if(fifo_can_read(&timer_fifo)){// 管理回掉
    d092:	83 ec 0c             	sub    $0xc,%sp
    d095:	68 30 1e             	push   $0x1e30
    d098:	01 00                	add    %ax,(%bx,%si)
    d09a:	e8 0f cf             	call   9fac <fifo_free+0x2a>
    d09d:	ff                   	(bad)
    d09e:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    d0a2:	85 c0                	test   %ax,%ax
    d0a4:	74 1a                	je     d0c0 <idle_task+0x34>
            uint32_t data= fifo_read(&timer_fifo);
    d0a6:	83 ec 0c             	sub    $0xc,%sp
    d0a9:	68 30 1e             	push   $0x1e30
    d0ac:	01 00                	add    %ax,(%bx,%si)
    d0ae:	e8 2c cf             	call   9fdd <fifo_can_write+0x1a>
    d0b1:	ff                   	(bad)
    d0b2:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    d0b6:	89 45 ec             	mov    %ax,-0x14(%di)
            ((void (*)())data)();
    d0b9:	8b 45 ec             	mov    -0x14(%di),%ax
    d0bc:	ff d0                	call   *%ax
    d0be:	eb d2                	jmp    d092 <idle_task+0x6>
        } else if(task_die){
    d0c0:	a1 28 1e             	mov    0x1e28,%ax
    d0c3:	01 00                	add    %ax,(%bx,%si)
    d0c5:	85 c0                	test   %ax,%ax
    d0c7:	0f 84 85 00          	je     d150 <idle_task+0xc4>
    d0cb:	00 00                	add    %al,(%bx,%si)
            task_die=FALSE;
    d0cd:	c7 05 28 1e          	movw   $0x1e28,(%di)
    d0d1:	01 00                	add    %ax,(%bx,%si)
    d0d3:	00 00                	add    %al,(%bx,%si)
    d0d5:	00 00                	add    %al,(%bx,%si)
            task_t *task=curr_task->next;// 当前进程就是idle_task无需检察
    d0d7:	a1 24 1e             	mov    0x1e24,%ax
    d0da:	01 00                	add    %ax,(%bx,%si)
    d0dc:	8b 40 0c             	mov    0xc(%bx,%si),%ax
    d0df:	89 45 f4             	mov    %ax,-0xc(%di)
            task_t *pre_task=curr_task;
    d0e2:	a1 24 1e             	mov    0x1e24,%ax
    d0e5:	01 00                	add    %ax,(%bx,%si)
    d0e7:	89 45 f0             	mov    %ax,-0x10(%di)
            while (task!=curr_task){
    d0ea:	eb 57                	jmp    d143 <idle_task+0xb7>
                if(task->die){
    d0ec:	8b 45 f4             	mov    -0xc(%di),%ax
    d0ef:	8b 40 14             	mov    0x14(%bx,%si),%ax
    d0f2:	85 c0                	test   %ax,%ax
    d0f4:	74 3b                	je     d131 <idle_task+0xa5>
                    // 移除任务
                    pre_task->next=task->next;
    d0f6:	8b 45 f4             	mov    -0xc(%di),%ax
    d0f9:	8b 50 0c             	mov    0xc(%bx,%si),%dx
    d0fc:	8b 45 f0             	mov    -0x10(%di),%ax
    d0ff:	89 50 0c             	mov    %dx,0xc(%bx,%si)
                    // 回收资源
                    mem_free(task->tss, sizeof(tss_t));
    d102:	8b 45 f4             	mov    -0xc(%di),%ax
    d105:	8b 40 08             	mov    0x8(%bx,%si),%ax
    d108:	83 ec 08             	sub    $0x8,%sp
    d10b:	6a 68                	push   $0x68
    d10d:	50                   	push   %ax
    d10e:	e8 ce fd             	call   cedf <mem_alloc+0xfb>
    d111:	ff                   	(bad)
    d112:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
                    mem_free(task, sizeof(task_t));
    d116:	83 ec 08             	sub    $0x8,%sp
    d119:	6a 18                	push   $0x18
    d11b:	ff 75 f4             	push   -0xc(%di)
    d11e:	e8 be fd             	call   cedf <mem_alloc+0xfb>
    d121:	ff                   	(bad)
    d122:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
                    // 继续循环
                    task=task->next;
    d126:	8b 45 f4             	mov    -0xc(%di),%ax
    d129:	8b 40 0c             	mov    0xc(%bx,%si),%ax
    d12c:	89 45 f4             	mov    %ax,-0xc(%di)
    d12f:	eb 12                	jmp    d143 <idle_task+0xb7>
                } else{
                    // 继续循环
                    pre_task=pre_task->next;
    d131:	8b 45 f0             	mov    -0x10(%di),%ax
    d134:	8b 40 0c             	mov    0xc(%bx,%si),%ax
    d137:	89 45 f0             	mov    %ax,-0x10(%di)
                    task=task->next;
    d13a:	8b 45 f4             	mov    -0xc(%di),%ax
    d13d:	8b 40 0c             	mov    0xc(%bx,%si),%ax
    d140:	89 45 f4             	mov    %ax,-0xc(%di)
            while (task!=curr_task){
    d143:	a1 24 1e             	mov    0x1e24,%ax
    d146:	01 00                	add    %ax,(%bx,%si)
    d148:	39 45 f4             	cmp    %ax,-0xc(%di)
    d14b:	75 9f                	jne    d0ec <idle_task+0x60>
    d14d:	e9 40 ff             	jmp    d090 <idle_task+0x4>
    d150:	ff                   	(bad)
    d151:	ff                   	(bad)
                }
            }
        } else{
            hlt();
    d152:	e8 22 ff             	call   d077 <far_jump+0x18>
    d155:	ff                   	(bad)
    d156:	ff                   	(bad)
        if(fifo_can_read(&timer_fifo)){// 管理回掉
    d157:	e9 36 ff             	jmp    d090 <idle_task+0x4>
    d15a:	ff                   	(bad)
    d15b:	ff                   	.byte 0xff

0000d15c <task_switch>:
        }
    }
    // 这里若是直接return 会导致cpu不知道返回到哪里执行完毕切换就行了
}

void task_switch(){
    d15c:	55                   	push   %bp
    d15d:	89 e5                	mov    %sp,%bp
    d15f:	83 ec 10             	sub    $0x10,%sp
    curr_task->last_slice--;
    d162:	a1 24 1e             	mov    0x1e24,%ax
    d165:	01 00                	add    %ax,(%bx,%si)
    d167:	0f b6 50 11          	movzbw 0x11(%bx,%si),%dx
    d16b:	83 ea 01             	sub    $0x1,%dx
    d16e:	88 50 11             	mov    %dl,0x11(%bx,%si)
    if(curr_task->last_slice>0){
    d171:	a1 24 1e             	mov    0x1e24,%ax
    d174:	01 00                	add    %ax,(%bx,%si)
    d176:	0f b6 40 11          	movzbw 0x11(%bx,%si),%ax
    d17a:	84 c0                	test   %al,%al
    d17c:	7f 68                	jg     d1e6 <task_switch+0x8a>
        return;
    }
    task_t *task=curr_task->next;
    d17e:	a1 24 1e             	mov    0x1e24,%ax
    d181:	01 00                	add    %ax,(%bx,%si)
    d183:	8b 40 0c             	mov    0xc(%bx,%si),%ax
    d186:	89 45 fc             	mov    %ax,-0x4(%di)
    while (task->time>timer||task->die){
    d189:	eb 09                	jmp    d194 <task_switch+0x38>
        task=task->next;
    d18b:	8b 45 fc             	mov    -0x4(%di),%ax
    d18e:	8b 40 0c             	mov    0xc(%bx,%si),%ax
    d191:	89 45 fc             	mov    %ax,-0x4(%di)
    while (task->time>timer||task->die){
    d194:	8b 45 fc             	mov    -0x4(%di),%ax
    d197:	8b 00                	mov    (%bx,%si),%ax
    d199:	8b 15                	mov    (%di),%dx
    d19b:	2c 1e                	sub    $0x1e,%al
    d19d:	01 00                	add    %ax,(%bx,%si)
    d19f:	39 c2                	cmp    %ax,%dx
    d1a1:	72 e8                	jb     d18b <task_switch+0x2f>
    d1a3:	8b 45 fc             	mov    -0x4(%di),%ax
    d1a6:	8b 40 14             	mov    0x14(%bx,%si),%ax
    d1a9:	85 c0                	test   %ax,%ax
    d1ab:	75 de                	jne    d18b <task_switch+0x2f>
    }
    if(curr_task==task){
    d1ad:	a1 24 1e             	mov    0x1e24,%ax
    d1b0:	01 00                	add    %ax,(%bx,%si)
    d1b2:	39 45 fc             	cmp    %ax,-0x4(%di)
    d1b5:	74 32                	je     d1e9 <task_switch+0x8d>
        return;
    }
    curr_task=task;
    d1b7:	8b 45 fc             	mov    -0x4(%di),%ax
    d1ba:	a3 24 1e             	mov    %ax,0x1e24
    d1bd:	01 00                	add    %ax,(%bx,%si)
    curr_task->last_slice=curr_task->slice;
    d1bf:	8b 15                	mov    (%di),%dx
    d1c1:	24 1e                	and    $0x1e,%al
    d1c3:	01 00                	add    %ax,(%bx,%si)
    d1c5:	a1 24 1e             	mov    0x1e24,%ax
    d1c8:	01 00                	add    %ax,(%bx,%si)
    d1ca:	0f b6 52 10          	movzbw 0x10(%bp,%si),%dx
    d1ce:	88 50 11             	mov    %dl,0x11(%bx,%si)
    far_jump(curr_task->selector,0); // 任务再切换回来还会从这里回来
    d1d1:	a1 24 1e             	mov    0x1e24,%ax
    d1d4:	01 00                	add    %ax,(%bx,%si)
    d1d6:	8b 40 04             	mov    0x4(%bx,%si),%ax
    d1d9:	6a 00                	push   $0x0
    d1db:	50                   	push   %ax
    d1dc:	e8 7e fe             	call   d05d <mem_free+0x17c>
    d1df:	ff                   	(bad)
    d1e0:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    d1e4:	eb 04                	jmp    d1ea <task_switch+0x8e>
        return;
    d1e6:	90                   	nop
    d1e7:	eb 01                	jmp    d1ea <task_switch+0x8e>
        return;
    d1e9:	90                   	nop
}
    d1ea:	c9                   	leave
    d1eb:	c3                   	ret

0000d1ec <task_sleep>:

// 睡眠到指定时间
void task_sleep(uint32_t time){
    d1ec:	55                   	push   %bp
    d1ed:	89 e5                	mov    %sp,%bp
    if(time<=timer){
    d1ef:	a1 2c 1e             	mov    0x1e2c,%ax
    d1f2:	01 00                	add    %ax,(%bx,%si)
    d1f4:	3b 45 08             	cmp    0x8(%di),%ax
    d1f7:	73 1a                	jae    d213 <task_sleep+0x27>
        return;
    }
    // 保证立即切换
    curr_task->time=time;
    d1f9:	a1 24 1e             	mov    0x1e24,%ax
    d1fc:	01 00                	add    %ax,(%bx,%si)
    d1fe:	8b 55 08             	mov    0x8(%di),%dx
    d201:	89 10                	mov    %dx,(%bx,%si)
    curr_task->last_slice=0;
    d203:	a1 24 1e             	mov    0x1e24,%ax
    d206:	01 00                	add    %ax,(%bx,%si)
    d208:	c6 40 11 00          	movb   $0x0,0x11(%bx,%si)
    task_switch();
    d20c:	e8 4b ff             	call   d15a <idle_task+0xce>
    d20f:	ff                   	(bad)
    d210:	ff                   	(bad)
    d211:	eb 01                	jmp    d214 <task_sleep+0x28>
        return;
    d213:	90                   	nop
}
    d214:	5d                   	pop    %bp
    d215:	c3                   	ret

0000d216 <task_exit>:

// 操作当前进程退出 tss 描述符无法复用了，一直递增使用的，再回头使用不方便先直接抛弃
void task_exit(task_t *task){
    d216:	55                   	push   %bp
    d217:	89 e5                	mov    %sp,%bp
    if(!task){// 传空使用当前进程
    d219:	83 7d 08 00          	cmpw   $0x0,0x8(%di)
    d21d:	75 08                	jne    d227 <task_exit+0x11>
        task=curr_task;
    d21f:	a1 24 1e             	mov    0x1e24,%ax
    d222:	01 00                	add    %ax,(%bx,%si)
    d224:	89 45 08             	mov    %ax,0x8(%di)
    }
    // 标记死亡，依赖idle_task回收资源 不会回收tss描述符
    task->die=TRUE;
    d227:	8b 45 08             	mov    0x8(%di),%ax
    d22a:	c7 40 14 01 00       	movw   $0x1,0x14(%bx,%si)
    d22f:	00 00                	add    %al,(%bx,%si)
    task_die=TRUE;
    d231:	c7 05 28 1e          	movw   $0x1e28,(%di)
    d235:	01 00                	add    %ax,(%bx,%si)
    d237:	01 00                	add    %ax,(%bx,%si)
    d239:	00 00                	add    %al,(%bx,%si)
    // 切换进程
    task->last_slice=0;
    d23b:	8b 45 08             	mov    0x8(%di),%ax
    d23e:	c6 40 11 00          	movb   $0x0,0x11(%bx,%si)
    task_switch();
    d242:	e8 15 ff             	call   d15a <idle_task+0xce>
    d245:	ff                   	(bad)
    d246:	ff 90 5d c3          	call   *-0x3ca3(%bx,%si)

0000d24a <create_task>:
}

task_t *create_task(void (*func)(),int8_t slice){
    d24a:	55                   	push   %bp
    d24b:	89 e5                	mov    %sp,%bp
    d24d:	83 ec 28             	sub    $0x28,%sp
    d250:	8b 45 0c             	mov    0xc(%di),%ax
    d253:	88 45 e4             	mov    %al,-0x1c(%di)
    tss_t *tss= mem_alloc(sizeof(tss_t));
    d256:	83 ec 0c             	sub    $0xc,%sp
    d259:	6a 68                	push   $0x68
    d25b:	e8 84 fb             	call   cde2 <mem_total+0x53>
    d25e:	ff                   	(bad)
    d25f:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    d263:	89 45 f4             	mov    %ax,-0xc(%di)
    tss->ldtr=0;
    d266:	8b 45 f4             	mov    -0xc(%di),%ax
    d269:	c7 40 60 00 00       	movw   $0x0,0x60(%bx,%si)
    d26e:	00 00                	add    %al,(%bx,%si)
    tss->iomap=0x40000000;
    d270:	8b 45 f4             	mov    -0xc(%di),%ax
    d273:	c7 40 64 00 00       	movw   $0x0,0x64(%bx,%si)
    d278:	00 40 8b             	add    %al,-0x75(%bx,%si)
    tss->eip=(uint32_t)func;
    d27b:	55                   	push   %bp
    d27c:	08 8b 45 f4          	or     %cl,-0xbbb(%bp,%di)
    d280:	89 50 20             	mov    %dx,0x20(%bx,%si)
    tss->esp=(uint32_t)(mem_alloc(1024) + 1024); // 新分配的栈空间
    d283:	83 ec 0c             	sub    $0xc,%sp
    d286:	68 00 04             	push   $0x400
    d289:	00 00                	add    %al,(%bx,%si)
    d28b:	e8 54 fb             	call   cde2 <mem_total+0x53>
    d28e:	ff                   	(bad)
    d28f:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    d293:	05 00 04             	add    $0x400,%ax
    d296:	00 00                	add    %al,(%bx,%si)
    d298:	89 c2                	mov    %ax,%dx
    d29a:	8b 45 f4             	mov    -0xc(%di),%ax
    d29d:	89 50 38             	mov    %dx,0x38(%bx,%si)
    tss->eflags=0x00000202;
    d2a0:	8b 45 f4             	mov    -0xc(%di),%ax
    d2a3:	c7 40 24 02 02       	movw   $0x202,0x24(%bx,%si)
    d2a8:	00 00                	add    %al,(%bx,%si)
    tss->es = 2 * 8;
    d2aa:	8b 45 f4             	mov    -0xc(%di),%ax
    d2ad:	c7 40 48 10 00       	movw   $0x10,0x48(%bx,%si)
    d2b2:	00 00                	add    %al,(%bx,%si)
    tss->cs = 1 * 8;
    d2b4:	8b 45 f4             	mov    -0xc(%di),%ax
    d2b7:	c7 40 4c 08 00       	movw   $0x8,0x4c(%bx,%si)
    d2bc:	00 00                	add    %al,(%bx,%si)
    tss->ss = 2 * 8;
    d2be:	8b 45 f4             	mov    -0xc(%di),%ax
    d2c1:	c7 40 50 10 00       	movw   $0x10,0x50(%bx,%si)
    d2c6:	00 00                	add    %al,(%bx,%si)
    tss->ds = 2 * 8;
    d2c8:	8b 45 f4             	mov    -0xc(%di),%ax
    d2cb:	c7 40 54 10 00       	movw   $0x10,0x54(%bx,%si)
    d2d0:	00 00                	add    %al,(%bx,%si)
    tss->fs = 2 * 8;
    d2d2:	8b 45 f4             	mov    -0xc(%di),%ax
    d2d5:	c7 40 58 10 00       	movw   $0x10,0x58(%bx,%si)
    d2da:	00 00                	add    %al,(%bx,%si)
    tss->gs = 2 * 8;
    d2dc:	8b 45 f4             	mov    -0xc(%di),%ax
    d2df:	c7 40 5c 10 00       	movw   $0x10,0x5c(%bx,%si)
    d2e4:	00 00                	add    %al,(%bx,%si)
    create_seg_desc(tss_index, 103, (uint32_t)tss, ATTR_TSS);
    d2e6:	8b 55 f4             	mov    -0xc(%di),%dx
    d2e9:	0f b7 05             	movzww (%di),%ax
    d2ec:	20 1e 01 00          	and    %bl,0x1
    d2f0:	0f b7 c0             	movzww %ax,%ax
    d2f3:	68 89 00             	push   $0x89
    d2f6:	00 00                	add    %al,(%bx,%si)
    d2f8:	52                   	push   %dx
    d2f9:	6a 67                	push   $0x67
    d2fb:	50                   	push   %ax
    d2fc:	e8 0d c8             	call   9b0c <init_gdt_idt+0x154>
    d2ff:	ff                   	(bad)
    d300:	ff 83 c4 10          	incw   0x10c4(%bp,%di)

    task_t *task= mem_alloc(sizeof(task_t));
    d304:	83 ec 0c             	sub    $0xc,%sp
    d307:	6a 18                	push   $0x18
    d309:	e8 d6 fa             	call   cde2 <mem_total+0x53>
    d30c:	ff                   	(bad)
    d30d:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    d311:	89 45 f0             	mov    %ax,-0x10(%di)
    task->selector=tss_index*8;
    d314:	0f b7 05             	movzww (%di),%ax
    d317:	20 1e 01 00          	and    %bl,0x1
    d31b:	0f b7 c0             	movzww %ax,%ax
    d31e:	c1 e0 03             	shl    $0x3,%ax
    d321:	89 c2                	mov    %ax,%dx
    d323:	8b 45 f0             	mov    -0x10(%di),%ax
    d326:	89 50 04             	mov    %dx,0x4(%bx,%si)
    task->tss=tss;
    d329:	8b 45 f0             	mov    -0x10(%di),%ax
    d32c:	8b 55 f4             	mov    -0xc(%di),%dx
    d32f:	89 50 08             	mov    %dx,0x8(%bx,%si)
    task->slice=slice;
    d332:	8b 45 f0             	mov    -0x10(%di),%ax
    d335:	0f b6 55 e4          	movzbw -0x1c(%di),%dx
    d339:	88 50 10             	mov    %dl,0x10(%bx,%si)
    // 构建环形单链表
    task->next=curr_task->next;
    d33c:	a1 24 1e             	mov    0x1e24,%ax
    d33f:	01 00                	add    %ax,(%bx,%si)
    d341:	8b 50 0c             	mov    0xc(%bx,%si),%dx
    d344:	8b 45 f0             	mov    -0x10(%di),%ax
    d347:	89 50 0c             	mov    %dx,0xc(%bx,%si)
    curr_task->next=task;
    d34a:	a1 24 1e             	mov    0x1e24,%ax
    d34d:	01 00                	add    %ax,(%bx,%si)
    d34f:	8b 55 f0             	mov    -0x10(%di),%dx
    d352:	89 50 0c             	mov    %dx,0xc(%bx,%si)
    tss_index++;
    d355:	0f b7 05             	movzww (%di),%ax
    d358:	20 1e 01 00          	and    %bl,0x1
    d35c:	83 c0 01             	add    $0x1,%ax
    d35f:	66 a3 20 1e          	mov    %eax,0x1e20
    d363:	01 00                	add    %ax,(%bx,%si)
    return task;
    d365:	8b 45 f0             	mov    -0x10(%di),%ax
}
    d368:	c9                   	leave
    d369:	c3                   	ret

0000d36a <init_task>:

void init_task(){
    d36a:	55                   	push   %bp
    d36b:	89 e5                	mov    %sp,%bp
    d36d:	83 ec 18             	sub    $0x18,%sp
    // 初始化主进程
    tss_t *main= mem_alloc(sizeof(tss_t));
    d370:	83 ec 0c             	sub    $0xc,%sp
    d373:	6a 68                	push   $0x68
    d375:	e8 6a fa             	call   cde2 <mem_total+0x53>
    d378:	ff                   	(bad)
    d379:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    d37d:	89 45 f4             	mov    %ax,-0xc(%di)
    main->ldtr=0;
    d380:	8b 45 f4             	mov    -0xc(%di),%ax
    d383:	c7 40 60 00 00       	movw   $0x0,0x60(%bx,%si)
    d388:	00 00                	add    %al,(%bx,%si)
    main->iomap=0x40000000;
    d38a:	8b 45 f4             	mov    -0xc(%di),%ax
    d38d:	c7 40 64 00 00       	movw   $0x0,0x64(%bx,%si)
    d392:	00 40 8b             	add    %al,-0x75(%bx,%si)
    create_seg_desc(3, 103, (uint32_t)main, ATTR_TSS);
    d395:	45                   	inc    %bp
    d396:	f4                   	hlt
    d397:	68 89 00             	push   $0x89
    d39a:	00 00                	add    %al,(%bx,%si)
    d39c:	50                   	push   %ax
    d39d:	6a 67                	push   $0x67
    d39f:	6a 03                	push   $0x3
    d3a1:	e8 68 c7             	call   9b0c <init_gdt_idt+0x154>
    d3a4:	ff                   	(bad)
    d3a5:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    curr_task= mem_alloc(sizeof(task_t));
    d3a9:	83 ec 0c             	sub    $0xc,%sp
    d3ac:	6a 18                	push   $0x18
    d3ae:	e8 31 fa             	call   cde2 <mem_total+0x53>
    d3b1:	ff                   	(bad)
    d3b2:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    d3b6:	a3 24 1e             	mov    %ax,0x1e24
    d3b9:	01 00                	add    %ax,(%bx,%si)
    curr_task->selector=3*8;
    d3bb:	a1 24 1e             	mov    0x1e24,%ax
    d3be:	01 00                	add    %ax,(%bx,%si)
    d3c0:	c7 40 04 18 00       	movw   $0x18,0x4(%bx,%si)
    d3c5:	00 00                	add    %al,(%bx,%si)
    curr_task->tss=main;
    d3c7:	a1 24 1e             	mov    0x1e24,%ax
    d3ca:	01 00                	add    %ax,(%bx,%si)
    d3cc:	8b 55 f4             	mov    -0xc(%di),%dx
    d3cf:	89 50 08             	mov    %dx,0x8(%bx,%si)
    curr_task->next=curr_task;
    d3d2:	a1 24 1e             	mov    0x1e24,%ax
    d3d5:	01 00                	add    %ax,(%bx,%si)
    d3d7:	8b 15                	mov    (%di),%dx
    d3d9:	24 1e                	and    $0x1e,%al
    d3db:	01 00                	add    %ax,(%bx,%si)
    d3dd:	89 50 0c             	mov    %dx,0xc(%bx,%si)
    curr_task->slice=5;
    d3e0:	a1 24 1e             	mov    0x1e24,%ax
    d3e3:	01 00                	add    %ax,(%bx,%si)
    d3e5:	c6 40 10 05          	movb   $0x5,0x10(%bx,%si)
    curr_task->last_slice=5;
    d3e9:	a1 24 1e             	mov    0x1e24,%ax
    d3ec:	01 00                	add    %ax,(%bx,%si)
    d3ee:	c6 40 11 05          	movb   $0x5,0x11(%bx,%si)
    write_tr(3*8);// 为cpu设置当前任务默认值
    d3f2:	83 ec 0c             	sub    $0xc,%sp
    d3f5:	6a 18                	push   $0x18
    d3f7:	e8 84 fc             	call   d07e <hlt+0x5>
    d3fa:	ff                   	(bad)
    d3fb:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    // 为创建其他进程做处理
    tss_index=4;// 1,2是代码段，3要留给main进程使用，其他进程从4开始
    d3ff:	66 c7 05 20 1e 01 00 	movl   $0x11e20,(%di)
    d406:	04 00                	add    $0x0,%al
    task_die=FALSE;
    d408:	c7 05 28 1e          	movw   $0x1e28,(%di)
    d40c:	01 00                	add    %ax,(%bx,%si)
    d40e:	00 00                	add    %al,(%bx,%si)
    d410:	00 00                	add    %al,(%bx,%si)
    create_task(idle_task,1);
    d412:	83 ec 08             	sub    $0x8,%sp
    d415:	6a 01                	push   $0x1
    d417:	68 8c d0             	push   $0xd08c
    d41a:	00 00                	add    %al,(%bx,%si)
    d41c:	e8 29 fe             	call   d248 <task_exit+0x32>
    d41f:	ff                   	(bad)
    d420:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
}
    d424:	90                   	nop
    d425:	c9                   	leave
    d426:	c3                   	ret

0000d427 <init_timer>:
static event_t *curr_event;

uint32_t timer;
fifo_t timer_fifo;

void init_timer(){
    d427:	55                   	push   %bp
    d428:	89 e5                	mov    %sp,%bp
    curr_event=0;
    d42a:	c7 05 3c 1e          	movw   $0x1e3c,(%di)
    d42e:	01 00                	add    %ax,(%bx,%si)
    d430:	00 00                	add    %al,(%bx,%si)
    d432:	00 00                	add    %al,(%bx,%si)
    timer=0;
    d434:	c7 05 2c 1e          	movw   $0x1e2c,(%di)
    d438:	01 00                	add    %ax,(%bx,%si)
    d43a:	00 00                	add    %al,(%bx,%si)
    d43c:	00 00                	add    %al,(%bx,%si)
}
    d43e:	90                   	nop
    d43f:	5d                   	pop    %bp
    d440:	c3                   	ret

0000d441 <insert_event>:

event_t *insert_event(event_t *curr, event_t *next) {
    d441:	55                   	push   %bp
    d442:	89 e5                	mov    %sp,%bp
    d444:	83 ec 08             	sub    $0x8,%sp
    if(!curr){
    d447:	83 7d 08 00          	cmpw   $0x0,0x8(%di)
    d44b:	75 05                	jne    d452 <insert_event+0x11>
        return next;
    d44d:	8b 45 0c             	mov    0xc(%di),%ax
    d450:	eb 3a                	jmp    d48c <insert_event+0x4b>
    }
    if(curr->time>next->time){
    d452:	8b 45 08             	mov    0x8(%di),%ax
    d455:	8b 00                	mov    (%bx,%si),%ax
    d457:	8b 55 0c             	mov    0xc(%di),%dx
    d45a:	8b 12                	mov    (%bp,%si),%dx
    d45c:	39 c2                	cmp    %ax,%dx
    d45e:	73 0e                	jae    d46e <insert_event+0x2d>
        next->next=curr;
    d460:	8b 45 0c             	mov    0xc(%di),%ax
    d463:	8b 55 08             	mov    0x8(%di),%dx
    d466:	89 50 08             	mov    %dx,0x8(%bx,%si)
        return next;
    d469:	8b 45 0c             	mov    0xc(%di),%ax
    d46c:	eb 1e                	jmp    d48c <insert_event+0x4b>
    }
    curr->next=insert_event(curr->next,next);
    d46e:	8b 45 08             	mov    0x8(%di),%ax
    d471:	8b 40 08             	mov    0x8(%bx,%si),%ax
    d474:	83 ec 08             	sub    $0x8,%sp
    d477:	ff 75 0c             	push   0xc(%di)
    d47a:	50                   	push   %ax
    d47b:	e8 c1 ff             	call   d43f <init_timer+0x18>
    d47e:	ff                   	(bad)
    d47f:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    d483:	8b 55 08             	mov    0x8(%di),%dx
    d486:	89 42 08             	mov    %ax,0x8(%bp,%si)
    return curr;
    d489:	8b 45 08             	mov    0x8(%di),%ax
}
    d48c:	c9                   	leave
    d48d:	c3                   	ret

0000d48e <add_timer>:

void add_timer(uint32_t time, void (*callback)()){
    d48e:	55                   	push   %bp
    d48f:	89 e5                	mov    %sp,%bp
    d491:	83 ec 18             	sub    $0x18,%sp
    event_t *event= mem_alloc(sizeof(event_t));
    d494:	83 ec 0c             	sub    $0xc,%sp
    d497:	6a 0c                	push   $0xc
    d499:	e8 46 f9             	call   cde2 <mem_total+0x53>
    d49c:	ff                   	(bad)
    d49d:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    d4a1:	89 45 f4             	mov    %ax,-0xc(%di)
    if(!event){
    d4a4:	83 7d f4 00          	cmpw   $0x0,-0xc(%di)
    d4a8:	74 2c                	je     d4d6 <add_timer+0x48>
        return;
    }
    event->time=time;
    d4aa:	8b 45 f4             	mov    -0xc(%di),%ax
    d4ad:	8b 55 08             	mov    0x8(%di),%dx
    d4b0:	89 10                	mov    %dx,(%bx,%si)
    event->callback=callback;
    d4b2:	8b 45 f4             	mov    -0xc(%di),%ax
    d4b5:	8b 55 0c             	mov    0xc(%di),%dx
    d4b8:	89 50 04             	mov    %dx,0x4(%bx,%si)
    curr_event=insert_event(curr_event,event);
    d4bb:	a1 3c 1e             	mov    0x1e3c,%ax
    d4be:	01 00                	add    %ax,(%bx,%si)
    d4c0:	83 ec 08             	sub    $0x8,%sp
    d4c3:	ff 75 f4             	push   -0xc(%di)
    d4c6:	50                   	push   %ax
    d4c7:	e8 75 ff             	call   d43f <init_timer+0x18>
    d4ca:	ff                   	(bad)
    d4cb:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    d4cf:	a3 3c 1e             	mov    %ax,0x1e3c
    d4d2:	01 00                	add    %ax,(%bx,%si)
    d4d4:	eb 01                	jmp    d4d7 <add_timer+0x49>
        return;
    d4d6:	90                   	nop
}
    d4d7:	c9                   	leave
    d4d8:	c3                   	ret

0000d4d9 <remove_event>:

event_t *remove_event(event_t *curr, void (*target)()) {
    d4d9:	55                   	push   %bp
    d4da:	89 e5                	mov    %sp,%bp
    d4dc:	83 ec 08             	sub    $0x8,%sp
    if(curr==0){
    d4df:	83 7d 08 00          	cmpw   $0x0,0x8(%di)
    d4e3:	75 05                	jne    d4ea <remove_event+0x11>
        return curr;
    d4e5:	8b 45 08             	mov    0x8(%di),%ax
    d4e8:	eb 31                	jmp    d51b <remove_event+0x42>
    }
    if(curr->callback==target){// 移除成功
    d4ea:	8b 45 08             	mov    0x8(%di),%ax
    d4ed:	8b 40 04             	mov    0x4(%bx,%si),%ax
    d4f0:	39 45 0c             	cmp    %ax,0xc(%di)
    d4f3:	75 08                	jne    d4fd <remove_event+0x24>
        return curr->next;
    d4f5:	8b 45 08             	mov    0x8(%di),%ax
    d4f8:	8b 40 08             	mov    0x8(%bx,%si),%ax
    d4fb:	eb 1e                	jmp    d51b <remove_event+0x42>
    }
    curr->next= remove_event(curr->next,target);
    d4fd:	8b 45 08             	mov    0x8(%di),%ax
    d500:	8b 40 08             	mov    0x8(%bx,%si),%ax
    d503:	83 ec 08             	sub    $0x8,%sp
    d506:	ff 75 0c             	push   0xc(%di)
    d509:	50                   	push   %ax
    d50a:	e8 ca ff             	call   d4d7 <add_timer+0x49>
    d50d:	ff                   	(bad)
    d50e:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    d512:	8b 55 08             	mov    0x8(%di),%dx
    d515:	89 42 08             	mov    %ax,0x8(%bp,%si)
    return curr;
    d518:	8b 45 08             	mov    0x8(%di),%ax
}
    d51b:	c9                   	leave
    d51c:	c3                   	ret

0000d51d <remove_timer>:

void remove_timer(void (*callback)()){
    d51d:	55                   	push   %bp
    d51e:	89 e5                	mov    %sp,%bp
    d520:	83 ec 08             	sub    $0x8,%sp
    curr_event=remove_event(curr_event,callback);
    d523:	a1 3c 1e             	mov    0x1e3c,%ax
    d526:	01 00                	add    %ax,(%bx,%si)
    d528:	83 ec 08             	sub    $0x8,%sp
    d52b:	ff 75 08             	push   0x8(%di)
    d52e:	50                   	push   %ax
    d52f:	e8 a5 ff             	call   d4d7 <add_timer+0x49>
    d532:	ff                   	(bad)
    d533:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    d537:	a3 3c 1e             	mov    %ax,0x1e3c
    d53a:	01 00                	add    %ax,(%bx,%si)
}
    d53c:	90                   	nop
    d53d:	c9                   	leave
    d53e:	c3                   	ret

0000d53f <tick_timer>:

// 每10ms调用一次
void tick_timer(){
    d53f:	55                   	push   %bp
    d540:	89 e5                	mov    %sp,%bp
    d542:	83 ec 08             	sub    $0x8,%sp
    timer++;
    d545:	a1 2c 1e             	mov    0x1e2c,%ax
    d548:	01 00                	add    %ax,(%bx,%si)
    d54a:	83 c0 01             	add    $0x1,%ax
    d54d:	a3 2c 1e             	mov    %ax,0x1e2c
    d550:	01 00                	add    %ax,(%bx,%si)
    // 其他异步任务回掉还是使用fifo队列
    while (curr_event&&curr_event->time<=timer&& fifo_can_write(&timer_fifo)){
    d552:	eb 39                	jmp    d58d <tick_timer+0x4e>
        fifo_write(&timer_fifo,(uint32_t)curr_event->callback);
    d554:	a1 3c 1e             	mov    0x1e3c,%ax
    d557:	01 00                	add    %ax,(%bx,%si)
    d559:	8b 40 04             	mov    0x4(%bx,%si),%ax
    d55c:	83 ec 08             	sub    $0x8,%sp
    d55f:	50                   	push   %ax
    d560:	68 30 1e             	push   $0x1e30
    d563:	01 00                	add    %ax,(%bx,%si)
    d565:	e8 d1 ca             	call   a039 <fifo_read+0x5a>
    d568:	ff                   	(bad)
    d569:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
        mem_free(curr_event, sizeof(event_t));
    d56d:	a1 3c 1e             	mov    0x1e3c,%ax
    d570:	01 00                	add    %ax,(%bx,%si)
    d572:	83 ec 08             	sub    $0x8,%sp
    d575:	6a 0c                	push   $0xc
    d577:	50                   	push   %ax
    d578:	e8 64 f9             	call   cedf <mem_alloc+0xfb>
    d57b:	ff                   	(bad)
    d57c:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
        curr_event=curr_event->next;
    d580:	a1 3c 1e             	mov    0x1e3c,%ax
    d583:	01 00                	add    %ax,(%bx,%si)
    d585:	8b 40 08             	mov    0x8(%bx,%si),%ax
    d588:	a3 3c 1e             	mov    %ax,0x1e3c
    d58b:	01 00                	add    %ax,(%bx,%si)
    while (curr_event&&curr_event->time<=timer&& fifo_can_write(&timer_fifo)){
    d58d:	a1 3c 1e             	mov    0x1e3c,%ax
    d590:	01 00                	add    %ax,(%bx,%si)
    d592:	85 c0                	test   %ax,%ax
    d594:	74 25                	je     d5bb <tick_timer+0x7c>
    d596:	a1 3c 1e             	mov    0x1e3c,%ax
    d599:	01 00                	add    %ax,(%bx,%si)
    d59b:	8b 00                	mov    (%bx,%si),%ax
    d59d:	8b 15                	mov    (%di),%dx
    d59f:	2c 1e                	sub    $0x1e,%al
    d5a1:	01 00                	add    %ax,(%bx,%si)
    d5a3:	39 c2                	cmp    %ax,%dx
    d5a5:	72 14                	jb     d5bb <tick_timer+0x7c>
    d5a7:	83 ec 0c             	sub    $0xc,%sp
    d5aa:	68 30 1e             	push   $0x1e30
    d5ad:	01 00                	add    %ax,(%bx,%si)
    d5af:	e8 0f ca             	call   9fc1 <fifo_can_read+0x13>
    d5b2:	ff                   	(bad)
    d5b3:	ff 83 c4 10          	incw   0x10c4(%bp,%di)
    d5b7:	85 c0                	test   %ax,%ax
    d5b9:	75 99                	jne    d554 <tick_timer+0x15>
    }
    if(timer%2==0){
    d5bb:	a1 2c 1e             	mov    0x1e2c,%ax
    d5be:	01 00                	add    %ax,(%bx,%si)
    d5c0:	83 e0 01             	and    $0x1,%ax
    d5c3:	85 c0                	test   %ax,%ax
    d5c5:	75 05                	jne    d5cc <tick_timer+0x8d>
        // 定时切换task若是需要监听 fifo 实现，要保证每个进程都去查看fifo队列太麻烦了，直接在这里处理尽可能快速解决
        task_switch();
    d5c7:	e8 90 fb             	call   d15a <idle_task+0xce>
    d5ca:	ff                   	(bad)
    d5cb:	ff 90 c9 c3          	call   *-0x3c37(%bx,%si)

0000d5cf <itoa>:
#include <stdarg.h>
#include "tool.h"

static char num2char[]="0123456789ABCDEF";

int itoa(char *buff, uint32_t num, uint8_t base) {
    d5cf:	55                   	push   %bp
    d5d0:	89 e5                	mov    %sp,%bp
    d5d2:	83 ec 34             	sub    $0x34,%sp
    d5d5:	8b 45 10             	mov    0x10(%di),%ax
    d5d8:	88 45 cc             	mov    %al,-0x34(%di)
    char temp[32];//暂定 32位 再多就不行了
    int index =0;
    d5db:	c7 45 fc 00 00       	movw   $0x0,-0x4(%di)
    d5e0:	00 00                	add    %al,(%bx,%si)
    while (num){
    d5e2:	eb 36                	jmp    d61a <itoa+0x4b>
        temp[index]=num2char[num%base];
    d5e4:	0f b6 4d cc          	movzbw -0x34(%di),%cx
    d5e8:	8b 45 0c             	mov    0xc(%di),%ax
    d5eb:	ba 00 00             	mov    $0x0,%dx
    d5ee:	00 00                	add    %al,(%bx,%si)
    d5f0:	f7 f1                	div    %cx
    d5f2:	89 d0                	mov    %dx,%ax
    d5f4:	0f b6 80 48 ec       	movzbw -0x13b8(%bx,%si),%ax
    d5f9:	00 00                	add    %al,(%bx,%si)
    d5fb:	8d 4d d8             	lea    -0x28(%di),%cx
    d5fe:	8b 55 fc             	mov    -0x4(%di),%dx
    d601:	01 ca                	add    %cx,%dx
    d603:	88 02                	mov    %al,(%bp,%si)
        index++;
    d605:	83 45 fc 01          	addw   $0x1,-0x4(%di)
        num/=base;
    d609:	0f b6 4d cc          	movzbw -0x34(%di),%cx
    d60d:	8b 45 0c             	mov    0xc(%di),%ax
    d610:	ba 00 00             	mov    $0x0,%dx
    d613:	00 00                	add    %al,(%bx,%si)
    d615:	f7 f1                	div    %cx
    d617:	89 45 0c             	mov    %ax,0xc(%di)
    while (num){
    d61a:	83 7d 0c 00          	cmpw   $0x0,0xc(%di)
    d61e:	75 c4                	jne    d5e4 <itoa+0x15>
    }
    int res = index;
    d620:	8b 45 fc             	mov    -0x4(%di),%ax
    d623:	89 45 f8             	mov    %ax,-0x8(%di)
    while (index>0){
    d626:	eb 1a                	jmp    d642 <itoa+0x73>
        *buff++=temp[index-1];
    d628:	8b 45 fc             	mov    -0x4(%di),%ax
    d62b:	8d 48 ff             	lea    -0x1(%bx,%si),%cx
    d62e:	8b 45 08             	mov    0x8(%di),%ax
    d631:	8d 50 01             	lea    0x1(%bx,%si),%dx
    d634:	89 55 08             	mov    %dx,0x8(%di)
    d637:	0f b6 54 0d          	movzbw 0xd(%si),%dx
    d63b:	d8 88 10 83          	fmuls  -0x7cf0(%bx,%si)
        index--;
    d63f:	6d                   	insw   (%dx),%es:(%di)
    d640:	fc                   	cld
    d641:	01 83 7d fc          	add    %ax,-0x383(%bp,%di)
    while (index>0){
    d645:	00 7f e0             	add    %bh,-0x20(%bx)
    }
    return res;
    d648:	8b 45 f8             	mov    -0x8(%di),%ax
}
    d64b:	c9                   	leave
    d64c:	c3                   	ret

0000d64d <append>:

int append(char *buff,char *sub){
    d64d:	55                   	push   %bp
    d64e:	89 e5                	mov    %sp,%bp
    d650:	83 ec 10             	sub    $0x10,%sp
    int res =0;
    d653:	c7 45 fc 00 00       	movw   $0x0,-0x4(%di)
    d658:	00 00                	add    %al,(%bx,%si)
    while (*sub){
    d65a:	eb 1b                	jmp    d677 <append+0x2a>
        *buff++=*sub++;
    d65c:	8b 55 0c             	mov    0xc(%di),%dx
    d65f:	8d 42 01             	lea    0x1(%bp,%si),%ax
    d662:	89 45 0c             	mov    %ax,0xc(%di)
    d665:	8b 45 08             	mov    0x8(%di),%ax
    d668:	8d 48 01             	lea    0x1(%bx,%si),%cx
    d66b:	89 4d 08             	mov    %cx,0x8(%di)
    d66e:	0f b6 12             	movzbw (%bp,%si),%dx
    d671:	88 10                	mov    %dl,(%bx,%si)
        res++;
    d673:	83 45 fc 01          	addw   $0x1,-0x4(%di)
    while (*sub){
    d677:	8b 45 0c             	mov    0xc(%di),%ax
    d67a:	0f b6 00             	movzbw (%bx,%si),%ax
    d67d:	84 c0                	test   %al,%al
    d67f:	75 db                	jne    d65c <append+0xf>
    }
    return res;
    d681:	8b 45 fc             	mov    -0x4(%di),%ax
}
    d684:	c9                   	leave
    d685:	c3                   	ret

0000d686 <fmt>:

void fmt(char * buff, char * fmt, ...) {
    d686:	55                   	push   %bp
    d687:	89 e5                	mov    %sp,%bp
    d689:	83 ec 10             	sub    $0x10,%sp
    va_list args;
    va_start(args, fmt);
    d68c:	8d 45 10             	lea    0x10(%di),%ax
    d68f:	89 45 f0             	mov    %ax,-0x10(%di)

    bool_t in_fmt=FALSE;
    d692:	c7 45 fc 00 00       	movw   $0x0,-0x4(%di)
    d697:	00 00                	add    %al,(%bx,%si)
    char ch;
    int val;
    while (*fmt){
    d699:	e9 13 01             	jmp    d7af <fmt+0x129>
    d69c:	00 00                	add    %al,(%bx,%si)
        ch=*fmt;
    d69e:	8b 45 0c             	mov    0xc(%di),%ax
    d6a1:	0f b6 00             	movzbw (%bx,%si),%ax
    d6a4:	88 45 fb             	mov    %al,-0x5(%di)
        fmt++;
    d6a7:	83 45 0c 01          	addw   $0x1,0xc(%di)
        if(in_fmt){// 格式化
    d6ab:	83 7d fc 00          	cmpw   $0x0,-0x4(%di)
    d6af:	0f 84 de 00          	je     d791 <fmt+0x10b>
    d6b3:	00 00                	add    %al,(%bx,%si)
            switch (ch) {
    d6b5:	0f be 45 fb          	movsbw -0x5(%di),%ax
    d6b9:	83 e8 62             	sub    $0x62,%ax
    d6bc:	83 f8 16             	cmp    $0x16,%ax
    d6bf:	0f 87 b8 00          	ja     d77b <fmt+0xf5>
    d6c3:	00 00                	add    %al,(%bx,%si)
    d6c5:	8b 04                	mov    (%si),%ax
    d6c7:	85 8c da 00          	test   %cx,0xda(%si)
    d6cb:	00 ff                	add    %bh,%bh
    d6cd:	e0 8b                	loopne d65a <append+0xd>
                case 'd':
                    val = va_arg(args, int);
    d6cf:	45                   	inc    %bp
    d6d0:	f0 8d 50 04          	lock lea 0x4(%bx,%si),%dx
    d6d4:	89 55 f0             	mov    %dx,-0x10(%di)
    d6d7:	8b 00                	mov    (%bx,%si),%ax
    d6d9:	89 45 f4             	mov    %ax,-0xc(%di)
                    buff += itoa(buff, val, 10);
    d6dc:	8b 45 f4             	mov    -0xc(%di),%ax
    d6df:	6a 0a                	push   $0xa
    d6e1:	50                   	push   %ax
    d6e2:	ff 75 08             	push   0x8(%di)
    d6e5:	e8 e5 fe             	call   d5cd <tick_timer+0x8e>
    d6e8:	ff                   	(bad)
    d6e9:	ff 83 c4 0c          	incw   0xcc4(%bp,%di)
    d6ed:	01 45 08             	add    %ax,0x8(%di)
                    break;
    d6f0:	e9 95 00             	jmp    d788 <fmt+0x102>
    d6f3:	00 00                	add    %al,(%bx,%si)
                case 'x':
                    val = va_arg(args, int);
    d6f5:	8b 45 f0             	mov    -0x10(%di),%ax
    d6f8:	8d 50 04             	lea    0x4(%bx,%si),%dx
    d6fb:	89 55 f0             	mov    %dx,-0x10(%di)
    d6fe:	8b 00                	mov    (%bx,%si),%ax
    d700:	89 45 f4             	mov    %ax,-0xc(%di)
                    buff += itoa(buff, val, 16);
    d703:	8b 45 f4             	mov    -0xc(%di),%ax
    d706:	6a 10                	push   $0x10
    d708:	50                   	push   %ax
    d709:	ff 75 08             	push   0x8(%di)
    d70c:	e8 be fe             	call   d5cd <tick_timer+0x8e>
    d70f:	ff                   	(bad)
    d710:	ff 83 c4 0c          	incw   0xcc4(%bp,%di)
    d714:	01 45 08             	add    %ax,0x8(%di)
                    break;
    d717:	eb 71                	jmp    d78a <fmt+0x104>
                case 'b':
                    val = va_arg(args, int);
    d719:	8b 45 f0             	mov    -0x10(%di),%ax
    d71c:	8d 50 04             	lea    0x4(%bx,%si),%dx
    d71f:	89 55 f0             	mov    %dx,-0x10(%di)
    d722:	8b 00                	mov    (%bx,%si),%ax
    d724:	89 45 f4             	mov    %ax,-0xc(%di)
                    buff += itoa(buff, val, 2);
    d727:	8b 45 f4             	mov    -0xc(%di),%ax
    d72a:	6a 02                	push   $0x2
    d72c:	50                   	push   %ax
    d72d:	ff 75 08             	push   0x8(%di)
    d730:	e8 9a fe             	call   d5cd <tick_timer+0x8e>
    d733:	ff                   	(bad)
    d734:	ff 83 c4 0c          	incw   0xcc4(%bp,%di)
    d738:	01 45 08             	add    %ax,0x8(%di)
                    break;
    d73b:	eb 4d                	jmp    d78a <fmt+0x104>
                case 'c':
                    val = va_arg(args, int);
    d73d:	8b 45 f0             	mov    -0x10(%di),%ax
    d740:	8d 50 04             	lea    0x4(%bx,%si),%dx
    d743:	89 55 f0             	mov    %dx,-0x10(%di)
    d746:	8b 00                	mov    (%bx,%si),%ax
    d748:	89 45 f4             	mov    %ax,-0xc(%di)
                    *buff++=(char )val;
    d74b:	8b 45 08             	mov    0x8(%di),%ax
    d74e:	8d 50 01             	lea    0x1(%bx,%si),%dx
    d751:	89 55 08             	mov    %dx,0x8(%di)
    d754:	8b 55 f4             	mov    -0xc(%di),%dx
    d757:	88 10                	mov    %dl,(%bx,%si)
                    break;
    d759:	eb 2f                	jmp    d78a <fmt+0x104>
                case 's':
                    val = va_arg(args, int );
    d75b:	8b 45 f0             	mov    -0x10(%di),%ax
    d75e:	8d 50 04             	lea    0x4(%bx,%si),%dx
    d761:	89 55 f0             	mov    %dx,-0x10(%di)
    d764:	8b 00                	mov    (%bx,%si),%ax
    d766:	89 45 f4             	mov    %ax,-0xc(%di)
                    buff+= append(buff,(char *)val);
    d769:	8b 45 f4             	mov    -0xc(%di),%ax
    d76c:	50                   	push   %ax
    d76d:	ff 75 08             	push   0x8(%di)
    d770:	e8 d8 fe             	call   d64b <itoa+0x7c>
    d773:	ff                   	(bad)
    d774:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    d778:	01 45 08             	add    %ax,0x8(%di)
                    break;
    d77b:	eb 0d                	jmp    d78a <fmt+0x104>
                default:
                    *buff++='?';
    d77d:	8b 45 08             	mov    0x8(%di),%ax
    d780:	8d 50 01             	lea    0x1(%bx,%si),%dx
    d783:	89 55 08             	mov    %dx,0x8(%di)
    d786:	c6 00 3f             	movb   $0x3f,(%bx,%si)
                    break;
    d789:	90                   	nop
            }
            in_fmt=FALSE;
    d78a:	c7 45 fc 00 00       	movw   $0x0,-0x4(%di)
    d78f:	00 00                	add    %al,(%bx,%si)
    d791:	eb 1e                	jmp    d7b1 <fmt+0x12b>
        } else if(ch=='%'){// 进入格式化模式
    d793:	80 7d fb 25          	cmpb   $0x25,-0x5(%di)
    d797:	75 09                	jne    d7a2 <fmt+0x11c>
            in_fmt=TRUE;
    d799:	c7 45 fc 01 00       	movw   $0x1,-0x4(%di)
    d79e:	00 00                	add    %al,(%bx,%si)
    d7a0:	eb 0f                	jmp    d7b1 <fmt+0x12b>
        } else{// 普通字符串
            *buff++=ch;
    d7a2:	8b 45 08             	mov    0x8(%di),%ax
    d7a5:	8d 50 01             	lea    0x1(%bx,%si),%dx
    d7a8:	89 55 08             	mov    %dx,0x8(%di)
    d7ab:	0f b6 55 fb          	movzbw -0x5(%di),%dx
    d7af:	88 10                	mov    %dl,(%bx,%si)
    while (*fmt){
    d7b1:	8b 45 0c             	mov    0xc(%di),%ax
    d7b4:	0f b6 00             	movzbw (%bx,%si),%ax
    d7b7:	84 c0                	test   %al,%al
    d7b9:	0f 85 df fe          	jne    d69c <fmt+0x16>
    d7bd:	ff                   	(bad)
    d7be:	ff 8b 45 08          	decw   0x845(%bp,%di)
        }
    }
    *buff='\0'; // 直接截断
    d7c2:	c6 00 00             	movb   $0x0,(%bx,%si)
    va_end(args);
}
    d7c5:	90                   	nop
    d7c6:	c9                   	leave
    d7c7:	c3                   	ret

0000d7c8 <mem_set>:

void mem_set(void *ptr,uint8_t val,uint32_t size){
    d7c8:	55                   	push   %bp
    d7c9:	89 e5                	mov    %sp,%bp
    d7cb:	83 ec 14             	sub    $0x14,%sp
    d7ce:	8b 45 0c             	mov    0xc(%di),%ax
    d7d1:	88 45 ec             	mov    %al,-0x14(%di)
    uint8_t *temp=ptr;
    d7d4:	8b 45 08             	mov    0x8(%di),%ax
    d7d7:	89 45 fc             	mov    %ax,-0x4(%di)
    for (int i = 0; i < size; ++i) {
    d7da:	c7 45 f8 00 00       	movw   $0x0,-0x8(%di)
    d7df:	00 00                	add    %al,(%bx,%si)
    d7e1:	eb 13                	jmp    d7f6 <mem_set+0x2e>
        *temp++=val;
    d7e3:	8b 45 fc             	mov    -0x4(%di),%ax
    d7e6:	8d 50 01             	lea    0x1(%bx,%si),%dx
    d7e9:	89 55 fc             	mov    %dx,-0x4(%di)
    d7ec:	0f b6 55 ec          	movzbw -0x14(%di),%dx
    d7f0:	88 10                	mov    %dl,(%bx,%si)
    for (int i = 0; i < size; ++i) {
    d7f2:	83 45 f8 01          	addw   $0x1,-0x8(%di)
    d7f6:	8b 45 f8             	mov    -0x8(%di),%ax
    d7f9:	3b 45 10             	cmp    0x10(%di),%ax
    d7fc:	72 e5                	jb     d7e3 <mem_set+0x1b>
    }
}
    d7fe:	90                   	nop
    d7ff:	90                   	nop
    d800:	c9                   	leave
    d801:	c3                   	ret

0000d802 <mem_eq>:

bool_t mem_eq(void *ptr1,void *ptr2){
    d802:	55                   	push   %bp
    d803:	89 e5                	mov    %sp,%bp
    d805:	83 ec 10             	sub    $0x10,%sp
    uint8_t *p1=ptr1;
    d808:	8b 45 08             	mov    0x8(%di),%ax
    d80b:	89 45 fc             	mov    %ax,-0x4(%di)
    uint8_t *p2=ptr2;
    d80e:	8b 45 0c             	mov    0xc(%di),%ax
    d811:	89 45 f8             	mov    %ax,-0x8(%di)
    while (*p1&&*p2&&*p1==*p2){
    d814:	eb 08                	jmp    d81e <mem_eq+0x1c>
        p1++;
    d816:	83 45 fc 01          	addw   $0x1,-0x4(%di)
        p2++;
    d81a:	83 45 f8 01          	addw   $0x1,-0x8(%di)
    while (*p1&&*p2&&*p1==*p2){
    d81e:	8b 45 fc             	mov    -0x4(%di),%ax
    d821:	0f b6 00             	movzbw (%bx,%si),%ax
    d824:	84 c0                	test   %al,%al
    d826:	74 1a                	je     d842 <mem_eq+0x40>
    d828:	8b 45 f8             	mov    -0x8(%di),%ax
    d82b:	0f b6 00             	movzbw (%bx,%si),%ax
    d82e:	84 c0                	test   %al,%al
    d830:	74 10                	je     d842 <mem_eq+0x40>
    d832:	8b 45 fc             	mov    -0x4(%di),%ax
    d835:	0f b6 10             	movzbw (%bx,%si),%dx
    d838:	8b 45 f8             	mov    -0x8(%di),%ax
    d83b:	0f b6 00             	movzbw (%bx,%si),%ax
    d83e:	38 c2                	cmp    %al,%dl
    d840:	74 d4                	je     d816 <mem_eq+0x14>
    }
    return (!*p1)&&(!*p2);
    d842:	8b 45 fc             	mov    -0x4(%di),%ax
    d845:	0f b6 00             	movzbw (%bx,%si),%ax
    d848:	84 c0                	test   %al,%al
    d84a:	75 11                	jne    d85d <mem_eq+0x5b>
    d84c:	8b 45 f8             	mov    -0x8(%di),%ax
    d84f:	0f b6 00             	movzbw (%bx,%si),%ax
    d852:	84 c0                	test   %al,%al
    d854:	75 07                	jne    d85d <mem_eq+0x5b>
    d856:	b8 01 00             	mov    $0x1,%ax
    d859:	00 00                	add    %al,(%bx,%si)
    d85b:	eb 05                	jmp    d862 <mem_eq+0x60>
    d85d:	b8 00 00             	mov    $0x0,%ax
    d860:	00 00                	add    %al,(%bx,%si)
}
    d862:	c9                   	leave
    d863:	c3                   	ret

0000d864 <mem_copy>:

void mem_copy(void *desc,void *src,uint32_t size){
    d864:	55                   	push   %bp
    d865:	89 e5                	mov    %sp,%bp
    d867:	83 ec 20             	sub    $0x20,%sp
    uint32_t count=size/4;
    d86a:	8b 45 10             	mov    0x10(%di),%ax
    d86d:	c1 e8 02             	shr    $0x2,%ax
    d870:	89 45 e4             	mov    %ax,-0x1c(%di)
    uint32_t *d32=desc;
    d873:	8b 45 08             	mov    0x8(%di),%ax
    d876:	89 45 fc             	mov    %ax,-0x4(%di)
    uint32_t *s32=src; // 先4个一批拷贝，再单个拷贝
    d879:	8b 45 0c             	mov    0xc(%di),%ax
    d87c:	89 45 f8             	mov    %ax,-0x8(%di)
    for (int i = 0; i < count; ++i) {
    d87f:	c7 45 f4 00 00       	movw   $0x0,-0xc(%di)
    d884:	00 00                	add    %al,(%bx,%si)
    d886:	eb 1a                	jmp    d8a2 <mem_copy+0x3e>
        *d32++=*s32++;
    d888:	8b 55 f8             	mov    -0x8(%di),%dx
    d88b:	8d 42 04             	lea    0x4(%bp,%si),%ax
    d88e:	89 45 f8             	mov    %ax,-0x8(%di)
    d891:	8b 45 fc             	mov    -0x4(%di),%ax
    d894:	8d 48 04             	lea    0x4(%bx,%si),%cx
    d897:	89 4d fc             	mov    %cx,-0x4(%di)
    d89a:	8b 12                	mov    (%bp,%si),%dx
    d89c:	89 10                	mov    %dx,(%bx,%si)
    for (int i = 0; i < count; ++i) {
    d89e:	83 45 f4 01          	addw   $0x1,-0xc(%di)
    d8a2:	8b 45 f4             	mov    -0xc(%di),%ax
    d8a5:	3b 45 e4             	cmp    -0x1c(%di),%ax
    d8a8:	72 de                	jb     d888 <mem_copy+0x24>
    }
    count=size%4;
    d8aa:	8b 45 10             	mov    0x10(%di),%ax
    d8ad:	83 e0 03             	and    $0x3,%ax
    d8b0:	89 45 e4             	mov    %ax,-0x1c(%di)
    uint8_t *d8=(uint8_t*)d32;
    d8b3:	8b 45 fc             	mov    -0x4(%di),%ax
    d8b6:	89 45 f0             	mov    %ax,-0x10(%di)
    uint8_t *s8=(uint8_t*)s32;
    d8b9:	8b 45 f8             	mov    -0x8(%di),%ax
    d8bc:	89 45 ec             	mov    %ax,-0x14(%di)
    for (int i = 0; i < count; ++i) {
    d8bf:	c7 45 e8 00 00       	movw   $0x0,-0x18(%di)
    d8c4:	00 00                	add    %al,(%bx,%si)
    d8c6:	eb 1b                	jmp    d8e3 <mem_copy+0x7f>
        *d8++=*s8++;
    d8c8:	8b 55 ec             	mov    -0x14(%di),%dx
    d8cb:	8d 42 01             	lea    0x1(%bp,%si),%ax
    d8ce:	89 45 ec             	mov    %ax,-0x14(%di)
    d8d1:	8b 45 f0             	mov    -0x10(%di),%ax
    d8d4:	8d 48 01             	lea    0x1(%bx,%si),%cx
    d8d7:	89 4d f0             	mov    %cx,-0x10(%di)
    d8da:	0f b6 12             	movzbw (%bp,%si),%dx
    d8dd:	88 10                	mov    %dl,(%bx,%si)
    for (int i = 0; i < count; ++i) {
    d8df:	83 45 e8 01          	addw   $0x1,-0x18(%di)
    d8e3:	8b 45 e8             	mov    -0x18(%di),%ax
    d8e6:	3b 45 e4             	cmp    -0x1c(%di),%ax
    d8e9:	72 dd                	jb     d8c8 <mem_copy+0x64>
    }
}
    d8eb:	90                   	nop
    d8ec:	90                   	nop
    d8ed:	c9                   	leave
    d8ee:	c3                   	ret

0000d8ef <str_pfx>:

bool_t str_pfx(char *str, char *pfx){
    d8ef:	55                   	push   %bp
    d8f0:	89 e5                	mov    %sp,%bp
    while (*str&&*pfx&&*str==*pfx){
    d8f2:	eb 08                	jmp    d8fc <str_pfx+0xd>
        str++;
    d8f4:	83 45 08 01          	addw   $0x1,0x8(%di)
        pfx++;
    d8f8:	83 45 0c 01          	addw   $0x1,0xc(%di)
    while (*str&&*pfx&&*str==*pfx){
    d8fc:	8b 45 08             	mov    0x8(%di),%ax
    d8ff:	0f b6 00             	movzbw (%bx,%si),%ax
    d902:	84 c0                	test   %al,%al
    d904:	74 1a                	je     d920 <str_pfx+0x31>
    d906:	8b 45 0c             	mov    0xc(%di),%ax
    d909:	0f b6 00             	movzbw (%bx,%si),%ax
    d90c:	84 c0                	test   %al,%al
    d90e:	74 10                	je     d920 <str_pfx+0x31>
    d910:	8b 45 08             	mov    0x8(%di),%ax
    d913:	0f b6 10             	movzbw (%bx,%si),%dx
    d916:	8b 45 0c             	mov    0xc(%di),%ax
    d919:	0f b6 00             	movzbw (%bx,%si),%ax
    d91c:	38 c2                	cmp    %al,%dl
    d91e:	74 d4                	je     d8f4 <str_pfx+0x5>
    }
    return !*pfx;
    d920:	8b 45 0c             	mov    0xc(%di),%ax
    d923:	0f b6 00             	movzbw (%bx,%si),%ax
    d926:	84 c0                	test   %al,%al
    d928:	0f 94 c0             	sete   %al
    d92b:	0f b6 c0             	movzbw %al,%ax
}
    d92e:	5d                   	pop    %bp
    d92f:	c3                   	ret

0000d930 <str_len>:

uint32_t str_len(char *buff){
    d930:	55                   	push   %bp
    d931:	89 e5                	mov    %sp,%bp
    d933:	83 ec 10             	sub    $0x10,%sp
    uint32_t res=0;
    d936:	c7 45 fc 00 00       	movw   $0x0,-0x4(%di)
    d93b:	00 00                	add    %al,(%bx,%si)
    while (*buff){
    d93d:	eb 08                	jmp    d947 <str_len+0x17>
        buff++;
    d93f:	83 45 08 01          	addw   $0x1,0x8(%di)
        res++;
    d943:	83 45 fc 01          	addw   $0x1,-0x4(%di)
    while (*buff){
    d947:	8b 45 08             	mov    0x8(%di),%ax
    d94a:	0f b6 00             	movzbw (%bx,%si),%ax
    d94d:	84 c0                	test   %al,%al
    d94f:	75 ee                	jne    d93f <str_len+0xf>
    }
    return res;
    d951:	8b 45 fc             	mov    -0x4(%di),%ax
    d954:	c9                   	leave
    d955:	c3                   	ret
